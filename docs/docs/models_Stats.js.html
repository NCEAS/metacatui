<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>MetacatUI Dev Docs: Source: models/Stats.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="style.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: models/Stats.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*global define */
define(['jquery', 'underscore', 'backbone', 'models/LogsSearch', 'promise'],
  function($, _, Backbone, LogsSearch, Promise) {
  'use strict';

  /**
  * @class Stats
  * @classdesc This model contains all a collection of statistics/metrics about a collection of DataONE objects
  * @name Stats
  * @extends Backbone.Model
  * @constructor
  */
  var Stats = Backbone.Model.extend(
    /** @lends Stats.prototype */{

    /**
    * Default attributes for Stats models
    * @type {Object}
    * @property {string} query - The base query that defines the data collection to get statistis about.
    * @property {string} postQuery - A copy of the `query`, but without any URL encoding
    * @property {number} metadataCount - The number of metadata objects in this data collection @readonly
    * @property {number} dataCount - The number of data objects in this data collection
    * @property {number} totalCount - The number of metadata and data objects in this data collection. Essentially this is the sum of metadataCount and dataCount
    * @property {number|string[]} metadataFormatIDs
    * @property {number|string[]} dataFormatIDs
    * @property {number|string[]} dataUpdateDates
    * @property {number|string[]} metadataUpdateDates
    * @property {string} firstBeginDate - An ISO date string of the earliest year that this data collection describes, from the science metadata
    * @property {number|string[]} temporalCoverage
    * @property {number} metadataTotalSize - The total number of bytes of all metadata files
    * @property {number} dataTotalSize - The total number of bytes of all data files
    * @property {number} totalSize - The total number of bytes or metadata and data files
    * @property {number} queryCoverageFrom - The year to start the temporal coverage range query
    * @property {number} queryCoverageUntil - The year to end the temporal coverage range query
    */
    defaults: {
      query: "*:* ", //Show everything
      postQuery: "", //An unencoded version of the query

      metadataCount: 0,
      dataCount: 0,
      totalCount: 0,
      metadataFormatIDs: [], //Uses same structure as Solr facet counts: ["text/csv", 5]
      dataFormatIDs: [], //Uses same structure as Solr facet counts: ["text/csv", 5]

      firstUpload: 0,
      totalUploads: 0, //total data and metadata objects uploaded, including now obsoleted objects
      metadataUploads: null,
      dataUploads: null,
      metadataUploadDates: null,
      dataUploadDates: null,

      //Number of updates to content for each time period
      dataUpdateDates: null,
      metadataUpdateDates: null,

      firstBeginDate: null,
      temporalCoverage: 0,
      queryCoverageFrom: null,
      queryCoverageUntil: null,

      metadataTotalSize: 0,
      dataTotalSize: 0,
      totalSize: 0,

      hideMetadataAssessment: false,
      mdqScoresImage: null,

      //HTTP GET requests are typically limited to 2,083 characters. So query lengths
      // should have this maximum before switching over to HTTP POST
      maxQueryLength: 2000,
      usePOST: false
    },

    /**
    * This function serves as a shorthand way to get all of the statistics stored in the model
    */
    getAll: function(){

      // Only get the MetaDIG scores if MetacatUI is configured to display metadata assesments
      // AND this model has them enabled, too.
      if ( !MetacatUI.appModel.get("hideSummaryMetadataAssessment") &amp;&amp; !this.get("hideMetadataAssessment") ){
        this.getMdqScores();
      }

      //Send the call the get both the metadata and data stats
      this.getMetadataStats();
      this.getDataStats();

    },

    /**
    * Queries for statistics about metadata objects
    */
    getMetadataStats: function(){

      var query = this.get("query"),
          //Filter out the portal and collection documents
          filterQuery = "-formatId:*dataone.org/collections* AND -formatId:*dataone.org/portals*",
          //Use the stats feature to get the sum of the file size
          stats = "true",
          statsField = "size",
          //Get the facet counts for formatIds
          facet = "true",
          facetFormatIdField = "formatId",
          facetFormatIdMin = "1",
          facetFormatIdMissing = "false",
          facetLimit = "-1",
          //Get the upload counts for each month
          facetRange = "dateUploaded",
          facetRangeGap = "+1MONTH",
          facetRangeStart = "1900-01-01T00:00:00.000Z",
          facetRangeEnd = (new Date()).toISOString(),
          facetMissing = "true",
          //Query for the temporal coverage ranges
          facetQueries = [],
          facetBeginDateField = "beginDate",
          facetEndDateField = "endDate",
          facetDateMin = "1",
          facetDateMissing = "false",
          //Don't return any result docs
          rows = "0",
          //Use JSON for the response format
          wt = "json";

      //How many years back should we look for temporal coverage?
      var lastYear =  this.get('queryCoverageUntil') || new Date().getUTCFullYear(),
          firstYear = this.get('queryCoverageFrom')  || 1950,
          totalYears = lastYear - firstYear,
          today = new Date().getUTCFullYear(),
          yearsFromToday = {
           fromBeginning: today - firstYear,
           fromEnd: today - lastYear
          };

      //Determine our year range/bin size
      var binSize = 1;

      if((totalYears > 10) &amp;&amp; (totalYears &lt;= 20)){
        binSize = 2;
      }
      else if((totalYears > 20) &amp;&amp; (totalYears &lt;= 50)){
        binSize = 5;
      }
      else if((totalYears > 50) &amp;&amp; (totalYears &lt;= 100)){
        binSize = 10;
      }
      else if(totalYears > 100){
        binSize = 25;
      }

      //Count all the datasets with coverage before the first year in the year range queries
      var beginDateLimit = new Date(Date.UTC(firstYear-1));
      facetQueries.push("{!key=&lt;" + firstYear + "}(beginDate:[* TO " +
                        beginDateLimit.toISOString() +"/YEAR])");

      //Construct our facet.queries for the beginDate and endDates, starting with all years before this current year
      var key = "";

      for(var yearsAgo = yearsFromToday.fromBeginning; (yearsAgo >= yearsFromToday.fromEnd &amp;&amp; yearsAgo > 0); yearsAgo -= binSize){
        // The query logic here is: If the beginnning year is anytime before or
        //  during the last year of the bin AND the ending year is anytime after
        //  or during the first year of the bin, it counts.
        if(binSize == 1){
          //Querying for just the current year needs to be treated a bit differently
          // and won't be caught in our for loop
          if(lastYear == today){
            var oneYearFromNow = new Date(Date.UTC(today+1, 0, 1));
            var now = new Date();

            facetQueries.push("{!key=" + lastYear + "}(beginDate:[* TO " +
                              oneYearFromNow.toISOString() + "/YEAR] AND endDate:[" +
                              now.toISOString() + "/YEAR TO *])");
          }
          else{
            key = today - yearsAgo;

            //The coverage should start sometime in this year range or earlier.
            var beginDateLimit = new Date(Date.UTC(today-(yearsAgo-1), 0, 1));
            //The coverage should end sometime in this year range or later.
            var endDateLimit = new Date(Date.UTC(today-yearsAgo, 0, 1));

            facetQueries.push("{!key=" + key + "}(beginDate:[* TO " +
                              beginDateLimit.toISOString() + "/YEAR] AND endDate:[" +
                              endDateLimit.toISOString() + "/YEAR TO *])");
          }
        }
        //If this is the last date range
        else if (yearsAgo &lt;= binSize){
          //Label the facet query with a key for easier parsing
          // Because this is the last year range, which could be uneven with the other year ranges, use the exact end year
          key = (today - yearsAgo) + "-" + lastYear;

          //The coverage should start sometime in this year range or earlier.
          // Because this is the last year range, which could be uneven with the other year ranges, use the exact end year
          var beginDateLimit = new Date(Date.UTC(today-yearsFromToday.fromEnd, 0, 1));
          //The coverage should end sometime in this year range or later.
          var endDateLimit = new Date(Date.UTC(today-yearsAgo, 0, 1));

          facetQueries.push("{!key=" + key + "}(beginDate:[* TO " +
                            beginDateLimit.toISOString() +"/YEAR] AND endDate:[" +
                            endDateLimit.toISOString() + "/YEAR TO *])");
        }
        //For all other bins,
        else{
          //Label the facet query with a key for easier parsing
          key = (today - yearsAgo) + "-" + (today - yearsAgo + binSize-1);

          //The coverage should start sometime in this year range or earlier.
          var beginDateLimit = new Date(Date.UTC(today - (yearsAgo - binSize), 0, 1));
          //The coverage should end sometime in this year range or later.
          var endDateLimit = new Date(Date.UTC(today-yearsAgo, 0, 1));

          facetQueries.push("{!key=" + key + "}(beginDate:[* TO " +
                         beginDateLimit.toISOString() + "/YEAR] AND endDate:[" +
                         endDateLimit.toISOString() + "/YEAR TO *])");
        }
      }

      var model = this;
      var successCallback = function(data, textStatus, xhr) {

        if( !data || !data.response || !data.response.numFound ){
          //Store falsey data
          model.set("totalCount", 0);
          model.trigger("change:totalCount");
          model.set('metadataCount', 0);
          model.trigger("change:metadataCount");
          model.set('metadataFormatIDs', ["", 0]);
          model.set('firstUpdate', null);
          model.set("metadataUpdateDates", []);
        }
        else{
          //Save tthe number of metadata docs found
          model.set('metadataCount', data.response.numFound);
          model.set("totalCount", model.get("dataCount") + data.response.numFound);

          //Save the format ID facet counts
          if( data.facet_counts &amp;&amp; data.facet_counts.facet_fields &amp;&amp; data.facet_counts.facet_fields.formatId ){
            model.set("metadataFormatIDs", data.facet_counts.facet_fields.formatId);
          }
          else{
            model.set("metadataFormatIDs", ["", 0]);
          }

          //Save the metadata update date counts
          if( data.facet_counts &amp;&amp; data.facet_counts.facet_ranges &amp;&amp; data.facet_counts.facet_ranges.dateUploaded ){

            //Find the index of the first update date
            var updateFacets = data.facet_counts.facet_ranges.dateUploaded.counts,
                cropAt = 0;

            for( var i=1; i&lt;updateFacets.length; i+=2 ){
              //If there was at least one update/upload in this date range, then save this as the first update
              if( typeof updateFacets[i] == "number" &amp;&amp; updateFacets[i] > 0){
                //Save the first first update date
                cropAt = i;
                model.set('firstUpdate', updateFacets[i-1]);
                //Save the update dates, but crop out months that are empty
                model.set("metadataUpdateDates", updateFacets.slice(cropAt+1));
                i = updateFacets.length;
              }
            }

            //If no update dates were found, save falsey values
            if( cropAt === 0 ){
              model.set('firstUpdate', null);
              model.set("metadataUpdateDates", []);
            }
          }

          //Save the temporal coverage dates
          if( data.facet_counts &amp;&amp; data.facet_counts.facet_queries ){

            //Find the beginDate and facets so we can store the earliest beginDate
            if( data.facet_counts.facet_fields &amp;&amp; data.facet_counts.facet_fields.beginDate ){
              var earliestBeginDate = _.find(data.facet_counts.facet_fields.beginDate, function(value){
                return ( typeof value == "string" &amp;&amp; parseInt(value.substring(0,4)) > 1000 );
              });
              if( earliestBeginDate ){
                model.set("firstBeginDate", earliestBeginDate);
              }
            }

            //Find the endDate and facets so we can store the latest endDate
            if( data.facet_counts.facet_fields &amp;&amp; data.facet_counts.facet_fields.endDate ){
              var latestEndDate,
                  endDates = data.facet_counts.facet_fields.endDate,
                  nextYear = (new Date()).getUTCFullYear() + 1,
                  i = 0;

              //Iterate over each endDate and find the first valid one. (After year 1000 but not after today)
              while( !latestEndDate &amp;&amp; i&lt;endDates.length ){
                var endDate = endDates[i];
                if( typeof endDate == "string" ){
                  endDate = parseInt(endDate.substring(0,3));
                  if( endDate > 1000 &amp;&amp; endDate &lt; nextYear){
                    latestEndDate = endDate;
                  }
                }
                i++;
              }

              //Save the latest endDate if one was found
              if( latestEndDate ){
                model.set("lastEndDate", latestEndDate);
              }
            }

            //Save the temporal coverage year ranges
            var tempCoverages = data.facet_counts.facet_queries;
            model.set("temporalCoverage", tempCoverages);
          }
          else{
            model.set("temporalCoverage", 0);
            model.triggerChange("temporalCoverage");
          }

          //Get the total size of all the files in the index
          if( data.stats &amp;&amp; data.stats.stats_fields &amp;&amp; data.stats.stats_fields.size &amp;&amp; data.stats.stats_fields.size.sum ){
            //Save the size sum
            model.set("metadataTotalSize", data.stats.stats_fields.size.sum);
            //If there is a data size sum,
            if( model.get("dataTotalSize") > 0 ){
              //Add it to the metadata size sum as the total sum
              model.set("totalSize", model.get("dataTotalSize") + data.stats.stats_fields.size.sum);
            }
          }
        }
      }

      //Construct the full URL for the query
      var fullQueryURL = MetacatUI.appModel.get('queryServiceUrl') +
          "q=" + query +
          "&amp;fq=" + filterQuery +
          "&amp;stats=" + stats +
          "&amp;stats.field=" + statsField +
          "&amp;facet=" + facet +
          "&amp;facet.field=" + facetFormatIdField +
          "&amp;facet.field=" + facetBeginDateField +
          "&amp;facet.field=" + facetEndDateField +
          "&amp;f." + facetFormatIdField  + ".facet.mincount=" + facetFormatIdMin +
          "&amp;f." + facetFormatIdField  + ".facet.missing=" + facetFormatIdMissing +
          "&amp;f." + facetBeginDateField + ".facet.mincount=" + facetDateMin +
          "&amp;f." + facetEndDateField   + ".facet.mincount=" + facetDateMin +
          "&amp;f." + facetBeginDateField + ".facet.missing=" + facetDateMissing +
          "&amp;f." + facetEndDateField   + ".facet.missing=" + facetDateMissing +
          "&amp;facet.limit=" + facetLimit +
          "&amp;f." + facetRange + ".facet.missing=" + facetMissing +
          "&amp;facet.range=" + facetRange +
          "&amp;facet.range.start=" + facetRangeStart +
          "&amp;facet.range.end=" + facetRangeEnd +
          "&amp;facet.range.gap=" + encodeURIComponent(facetRangeGap) +
          "&amp;facet.query=" + facetQueries.join("&amp;facet.query=") +
          "&amp;rows=" + rows +
          "&amp;wt=" + wt;

      if( this.getRequestType(fullQueryURL) == "POST" ){

        if( this.get("postQuery") ){
          query = this.get("postQuery");
        }
        else if( this.get("searchModel") ){
          query = this.get("searchModel").getQuery(undefined, { forPOST: true });
          this.set("postQuery", query);
        }

        var queryData = new FormData();
        queryData.append("q", query);
        queryData.append("fq", filterQuery);
        queryData.append("stats", stats);
        queryData.append("stats.field", statsField);
        queryData.append("facet", facet);
        queryData.append("facet.field", facetFormatIdField);
        queryData.append("facet.field", facetBeginDateField);
        queryData.append("facet.field", facetEndDateField);
        queryData.append("f." + facetFormatIdField  + ".facet.mincount", facetFormatIdMin);
        queryData.append("f." + facetFormatIdField  + ".facet.missing", facetFormatIdMissing);
        queryData.append("f." + facetBeginDateField + ".facet.mincount", facetDateMin);
        queryData.append("f." + facetEndDateField   + ".facet.mincount", facetDateMin);
        queryData.append("f." + facetBeginDateField + ".facet.missing", facetDateMissing);
        queryData.append("f." + facetEndDateField   + ".facet.missing", facetDateMissing);
        queryData.append("facet.limit", facetLimit);
        queryData.append("facet.range", facetRange);
        queryData.append("facet.range.start", facetRangeStart);
        queryData.append("facet.range.end", facetRangeEnd);
        queryData.append("facet.range.gap", facetRangeGap);
        queryData.append("f." + facetRange + ".facet.missing", facetMissing);
        queryData.append("rows", rows);
        queryData.append("wt", wt);

        //Add the facet queries to the POST body
        _.each(facetQueries, function(facetQuery){
          queryData.append("facet.query", facetQuery);
        });

        //Create the request settings for POST requests
        var requestSettings = {
          url: MetacatUI.appModel.get('queryServiceUrl'),
          type: "POST",
          contentType: false,
          processData: false,
          data: queryData,
          dataType: "json",
          success: successCallback
        }
      }
      else{
        //Create the request settings for GET requests
        var requestSettings = {
          url: fullQueryURL,
          type: "GET",
          dataType: "json",
          success: successCallback
        }
      }

      //Send the request
      $.ajax(_.extend(requestSettings, MetacatUI.appUserModel.createAjaxSettings()));

    },

    /**
    * Queries for statistics about data objects
    */
    getDataStats: function(){

      var query = "{!join from=resourceMap to=resourceMap}" + this.get("query"),
          //Filter out resource maps and metatdata objects
          filterQuery = "formatType:DATA",
          //Use the stats feature to get the sum of the file size
          stats = "true",
          statsField = "size",
          //Get the facet counts for formatIds
          facet = "true",
          facetField = "formatId",
          facetFormatIdMin = "1",
          facetFormatIdMissing = "false",
          facetLimit = "-1",
          //Get the upload counts for each month
          facetRange = "dateUploaded",
          facetRangeGap = "+1MONTH",
          facetRangeStart = "1900-01-01T00:00:00.000Z",
          facetRangeEnd = (new Date()).toISOString(),
          facetRangeMissing = "true",
          //Don't return any result docs
          rows = "0",
          //Use JSON for the response format
          wt = "json";

      var fullQueryURL = MetacatUI.appModel.get('queryServiceUrl') +
          "q=" + query +
          "&amp;fq=" + filterQuery +
          "&amp;stats=" + stats +
          "&amp;stats.field=" + statsField +
          "&amp;facet=" + facet +
          "&amp;facet.field=" + facetField +
          "&amp;facet.limit=" + facetLimit +
          "&amp;f." + facetField + ".facet.mincount=" + facetFormatIdMin +
          "&amp;f." + facetField + ".facet.missing=" + facetFormatIdMissing +
          "&amp;f." + facetRange + ".facet.missing=" + facetRangeMissing +
          "&amp;facet.range=" + facetRange +
          "&amp;facet.range.start=" + facetRangeStart +
          "&amp;facet.range.end=" + facetRangeEnd +
          "&amp;facet.range.gap=" + encodeURIComponent(facetRangeGap) +
          "&amp;rows=" + rows +
          "&amp;wt=" + wt;

      var model = this;
      var successCallback = function(data, textStatus, xhr) {

        if( !data || !data.response || !data.response.numFound ){
          //Store falsey data
          model.set("totalCount", 0);
          model.trigger("change:totalCount");
          model.set('dataCount', 0);
          model.trigger("change:dataCount");
          model.set('dataFormatIDs', ["", 0]);
          model.set('firstUpdate', null);
          model.set("dataUpdateDates", []);
        }
        else{
          //Save the number of data docs found
          model.set('dataCount', data.response.numFound);
          model.set("totalCount", model.get("metadataCount") + data.response.numFound);

          //Save the format ID facet counts
          if( data.facet_counts &amp;&amp; data.facet_counts.facet_fields &amp;&amp; data.facet_counts.facet_fields.formatId ){
            model.set("dataFormatIDs", data.facet_counts.facet_fields.formatId);
          }
          else{
            model.set("dataFormatIDs", ["", 0]);
          }

          //Save the data update date counts
          if( data.facet_counts &amp;&amp; data.facet_counts.facet_ranges &amp;&amp; data.facet_counts.facet_ranges.dateUploaded ){

            //Find the index of the first update date
            var updateFacets = data.facet_counts.facet_ranges.dateUploaded.counts,
                cropAt = 0;

            for( var i=1; i&lt;updateFacets.length; i+=2 ){
              //If there was at least one update/upload in this date range, then save this as the first update
              if( typeof updateFacets[i] == "number" &amp;&amp; updateFacets[i] > 0){
                //Save the first first update date
                cropAt = i;
                model.set('firstUpdate', updateFacets[i-1]);
                //Save the update dates, but crop out months that are empty
                model.set("dataUpdateDates", updateFacets.slice(cropAt+1));
                i = updateFacets.length;
              }
            }

            //If no update dates were found, save falsey values
            if( cropAt === 0 ){
              model.set('firstUpdate', null);
              model.set("dataUpdateDates", []);
            }
          }

          //Get the total size of all the files in the index
          if( data.stats &amp;&amp; data.stats.stats_fields &amp;&amp; data.stats.stats_fields.size &amp;&amp; data.stats.stats_fields.size.sum ){
            //Save the size sum
            model.set("dataTotalSize", data.stats.stats_fields.size.sum);
            //If there is a metadata size sum,
            if( model.get("metadataTotalSize") > 0 ){
              //Add it to the data size sum as the total sum
              model.set("totalSize", model.get("metadataTotalSize") + data.stats.stats_fields.size.sum);
            }
          }
        }
      }

      if( this.getRequestType(fullQueryURL) == "POST" ){

        if( this.get("postQuery") ){
          query = this.get("postQuery");
        }
        else if( this.get("searchModel") ){
          query = this.get("searchModel").getQuery(undefined, { forPOST: true });
          this.set("postQuery", query);
        }

        var queryData = new FormData();
        queryData.append("q", query);
        queryData.append("fq", filterQuery);
        queryData.append("stats", stats);
        queryData.append("stats.field", statsField);
        queryData.append("facet", facet);
        queryData.append("facet.field", facetField);
        queryData.append("facet.limit", facetLimit);
        queryData.append("f." + facetField + ".facet.mincount", facetFormatIdMin);
        queryData.append("f." + facetField + ".facet.missing", facetFormatIdMissing);
        queryData.append("f." + facetRange + ".facet.missing", facetRangeMissing);
        queryData.append("facet.range", facetRange);
        queryData.append("facet.range.start", facetRangeStart);
        queryData.append("facet.range.end", facetRangeEnd);
        queryData.append("facet.range.gap", facetRangeGap);
        queryData.append("rows", rows);
        queryData.append("wt", wt);

        //Create the request settings for POST requests
        var requestSettings = {
          url: MetacatUI.appModel.get('queryServiceUrl'),
          type: "POST",
          contentType: false,
          processData: false,
          data: queryData,
          dataType: "json",
          success: successCallback
        }
      }
      else{
        //Create the request settings for GET requests
        var requestSettings = {
          url: fullQueryURL,
          type: "GET",
          dataType: "json",
          success: successCallback
        }
      }

      //Send the request
      $.ajax(_.extend(requestSettings, MetacatUI.appUserModel.createAjaxSettings()));

    },

    /**
    * @deprecated as of MetacatUI version 2.11.1. Use {@link Stats#getMetadataStats} and {@link Stats#getDataStats} to get the formatTypes.
    * This function may be removed in a future release.
    */
    getFormatTypes: function(){
      this.getMetadataStats();
      this.getDataStats();
    },

    /**
    * @deprecated as of MetacatUI version 2.11.1. Use {@link Stats#getDataStats} to get the formatTypes.
    * This function may be removed in a future release.
    */
    getDataFormatIDs: function(){
      this.getDataStats();
    },

    /**
    * @deprecated as of MetacatUI version 2.11.1. Use {@link Stats#getMetadataStats} to get the formatTypes.
    * This function may be removed in a future release.
    */
    getMetadataFormatIDs: function(){
      this.getMetadataStats();
    },

    /**
    * @deprecated as of MetacatUI version 2.11.1. Use {@link Stats#getMetadataStats} and {@link Stats#getDataStats} to get the formatTypes.
    * This function may be removed in a future release.
    */
    getUpdateDates: function(){
      this.getMetadataStats();
      this.getDataStats();
    },

    /**
    * @deprecated as of MetacatUI version 2.11.1. Use {@link Stats#getMetadataStats} to get the formatTypes.
    * This function may be removed in a future release.
    */
    getCollectionYearFacets: function(){
      this.getMetadataStats();
    },

    /**
    * Retrieves an image of the metadata assessment scores
    */
    getMdqScores: function(){
      try{
        var myImage = new Image();
        var model = this;
        myImage.crossOrigin = ""; // or "anonymous"
        if(MetacatUI.appView.currentView === null) return;

        // Call the function with the URL we want to load, but then chain the
        // promise then() method on to the end of it. This contains two callbacks
        var serviceUrl = MetacatUI.appModel.get('mdqScoresServiceUrl');

        if( !serviceUrl ){
          this.set("mdqScoresImage", this.defaults.mdqScoresImage);
          this.trigger("change:mdqScoresImage");
          return;
        }

        if( Array.isArray(MetacatUI.appModel.get('mdqAggregatedSuiteIds')) &amp;&amp; MetacatUI.appModel.get('mdqAggregatedSuiteIds').length ){
          var suite = MetacatUI.appModel.get('mdqAggregatedSuiteIds')[0];
          var id = MetacatUI.appView.currentView.model.get("id");
          var url = serviceUrl + "?collection=" + id + "&amp;suite=" + suite;
          this.imgLoad(url).then(function (response) {
              // The first runs when the promise resolves, with the request.reponse specified within the resolve() method.
              var imageURL = window.URL.createObjectURL(response);
              myImage.src = imageURL;
              model.set('mdqScoresImage', myImage);
              // The second runs when the promise is rejected, and logs the Error specified with the reject() method.
          }, function (Error) {
              console.error(Error);
          });
        }
        else{
          this.set("mdqScoresImage", this.defaults.mdqScoresImage);
        }
      }
      catch(e){
        this.set("mdqScoresImage", this.defaults.mdqScoresImage);
        this.trigger("change:mdqScoresImage");
        console.error("Cannot get the Metadata Quality scores: ", e);
      }
    },

    /**
    * Retrieves an image via a Promise. Primarily used by {@link Stats#getMdqScores}
    * @param {string} url - The URL of the image
    */
    imgLoad: function(url) {
        // Create new promise with the Promise() constructor;
        // This has as its argument a function with two parameters, resolve and reject
        var model = this;
        return new Promise(function (resolve, reject) {
            // Standard XHR to load an image
            var request = new XMLHttpRequest();
            request.open('GET', url);
            request.responseType = 'blob';

            // When the request loads, check whether it was successful
            request.onload = function () {
                if (request.status === 200) {
                    // If successful, resolve the promise by passing back the request response
                    resolve(request.response);
                } else {
                    // If it fails, reject the promise with a error message
                    reject(new Error('Image didn\'t load successfully; error code:' + request.statusText));
                    model.set('mdqScoresError', request.statusText);
                }
            };

            request.onerror = function () {
                console.log("onerror");
                // Also deal with the case when the entire request fails to begin with
                // This is probably a network error, so reject the promise with an appropriate message
                reject(new Error('There was a network error.'));
            };

            // Send the request
            request.send();
        });
    },

    /**
    * Given the query or URL, determine whether this model should send GET or POST
    * requests, because of URL length restrictions in browsers.
    * @param {string} queryOrURLString - The full query or URL that will be sent to the query service
    * @returns {string} The request type to use. Either `GET` or `POST`
    */
    getRequestType: function(queryOrURLString){
      //If POSTs to the query service are disabled completely, use GET
      if( MetacatUI.appModel.get("disableQueryPOSTs") ){
        return "GET";
      }
      //If POSTs are enabled and the URL is over the maximum, use POST
      else if( queryOrURLString &amp;&amp; queryOrURLString.length > this.get("maxQueryLength") ){
        return "POST";
      }
      //Otherwise, default to GET
      else{
        return "GET";
      }
    }

  });
  return Stats;
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AccessPolicy.html">AccessPolicy</a></li><li><a href="AccessPolicyView.html">AccessPolicyView</a></li><li><a href="AccessRule.html">AccessRule</a></li><li><a href="AppModel.html">AppModel</a></li><li><a href="BooleanFilter.html">BooleanFilter</a></li><li><a href="ChoiceFilter.html">ChoiceFilter</a></li><li><a href="Citations.html">Citations</a></li><li><a href="CollectionModel.html">CollectionModel</a></li><li><a href="ColorPaletteView.html">ColorPaletteView</a></li><li><a href="DataCatalogView_drawTiles-TextOverlay.html">TextOverlay</a></li><li><a href="DataCatalogViewWithFilters.html">DataCatalogViewWithFilters</a></li><li><a href="DataItemView.html">DataItemView</a></li><li><a href="DataPackage.html">DataPackage</a></li><li><a href="DateFilter.html">DateFilter</a></li><li><a href="EditCollectionView.html">EditCollectionView</a></li><li><a href="EditorView.html">EditorView</a></li><li><a href="EML211EditorView.html">EML211EditorView</a></li><li><a href="EMLEntity.html">EMLEntity</a></li><li><a href="EMLGeoCoverage.html">EMLGeoCoverage</a></li><li><a href="EMlGeoCoverageView.html">EMlGeoCoverageView</a></li><li><a href="EMLNonNumericDomain.html">EMLNonNumericDomain</a></li><li><a href="EMLNumericDomain.html">EMLNumericDomain</a></li><li><a href="EMLPartyView.html">EMLPartyView</a></li><li><a href="EMLTemporalCoverage.html">EMLTemporalCoverage</a></li><li><a href="Filter.html">Filter</a></li><li><a href="FilterGroup.html">FilterGroup</a></li><li><a href="FilterGroupsView.html">FilterGroupsView</a></li><li><a href="Filters.html">Filters</a></li><li><a href="ImageUploaderView.html">ImageUploaderView</a></li><li><a href="MetadataView.html">MetadataView</a></li><li><a href="NavbarView.html">NavbarView</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="ObjectFormats.html">ObjectFormats</a></li><li><a href="PortalDataView.html">PortalDataView</a></li><li><a href="PortalEditorView.html">PortalEditorView</a></li><li><a href="PortalListView.html">PortalListView</a></li><li><a href="PortalMembersView.html">PortalMembersView</a></li><li><a href="PortalModel.html">PortalModel</a></li><li><a href="PortalSectionView.html">PortalSectionView</a></li><li><a href="PortalView.html">PortalView</a></li><li><a href="PortEditorDataView.html">PortEditorDataView</a></li><li><a href="PortEditorImageView.html">PortEditorImageView</a></li><li><a href="PortEditorLogosView.html">PortEditorLogosView</a></li><li><a href="PortEditorMdSectionView.html">PortEditorMdSectionView</a></li><li><a href="PortEditorSectionsView.html">PortEditorSectionsView</a></li><li><a href="PortEditorSectionView.html">PortEditorSectionView</a></li><li><a href="PortEditorSettingsView.html">PortEditorSettingsView</a></li><li><a href="QualityReport.html">QualityReport</a></li><li><a href="Search.html">Search</a></li><li><a href="SolrResultList.html">SolrResultList</a></li><li><a href="SpatialFilter.html">SpatialFilter</a></li><li><a href="Stats.html">Stats</a></li><li><a href="ToggleFilter.html">ToggleFilter</a></li><li><a href="UIRouter.html">UIRouter</a></li><li><a href="UserView.html">UserView</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addKeyword">addKeyword</a></li><li><a href="global.html#addNewKeyword">addNewKeyword</a></li><li><a href="global.html#checkIncompatibility">checkIncompatibility</a></li><li><a href="global.html#clearOldDrafts">clearOldDrafts</a></li><li><a href="global.html#friendlyTimeDiff">friendlyTimeDiff</a></li><li><a href="global.html#getSizeOfIndexQueue">getSizeOfIndexQueue</a></li><li><a href="global.html#listenForActivity">listenForActivity</a></li><li><a href="global.html#listenForTimeout">listenForTimeout</a></li><li><a href="global.html#MetacatUI">MetacatUI</a></li><li><a href="global.html#movePartyDown">movePartyDown</a></li><li><a href="global.html#movePartyUp">movePartyUp</a></li><li><a href="global.html#movePersonDown">movePersonDown</a></li><li><a href="global.html#movePersonUp">movePersonUp</a></li><li><a href="global.html#renderSupport">renderSupport</a></li><li><a href="global.html#saveDraft">saveDraft</a></li><li><a href="global.html#showAlert">showAlert</a></li><li><a href="global.html#showTimeoutSignIn">showTimeoutSignIn</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Thu May 07 2020 15:41:56 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
