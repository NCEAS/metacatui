<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>MetacatUI Dev Docs: Source: src/js/views/DataCatalogView.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="/metacatui/assets/css/styles.css">
    <link type="text/css" rel="stylesheet" href="styles/style.css">
</head>

<body>

<nav id="nav">
    <a href="/">
      <div class="logo">
<svg class="cat" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="cat" class="svg-inline--fa fa-cat fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M290.59 192c-20.18 0-106.82 1.98-162.59 85.95V192c0-52.94-43.06-96-96-96-17.67 0-32 14.33-32 32s14.33 32 32 32c17.64 0 32 14.36 32 32v256c0 35.3 28.7 64 64 64h176c8.84 0 16-7.16 16-16v-16c0-17.67-14.33-32-32-32h-32l128-96v144c0 8.84 7.16 16 16 16h32c8.84 0 16-7.16 16-16V289.86c-10.29 2.67-20.89 4.54-32 4.54-61.81 0-113.52-44.05-125.41-102.4zM448 96h-64l-64-64v134.4c0 53.02 42.98 96 96 96s96-42.98 96-96V32l-64 64zm-72 80c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16zm80 0c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16z"></path></svg>

<svg width="459px" height="53px" viewBox="0 0 459 53" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="metacatui" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M16.492,52 C17.212,52 17.812,51.748 18.292,51.244 C18.772,50.74 19.012,50.128 19.012,49.408 L19.012,49.408 L18.94,22.912 L30.82,37.816 C31.204,38.344 31.72,38.764 32.368,39.076 C33.016,39.388 33.7,39.544 34.42,39.544 C35.908,39.544 37.132,38.896 38.092,37.6 L38.092,37.6 L49.684,22.912 L49.684,49.408 C49.684,50.128 49.96,50.74 50.512,51.244 C51.064,51.748 51.7,52 52.42,52 L52.42,52 L62.068,52 C62.788,52 63.388,51.748 63.868,51.244 C64.348,50.74 64.588,50.128 64.588,49.408 L64.588,49.408 L64.588,4.12 C64.588,3.448 64.336,2.86 63.832,2.356 C63.328,1.852 62.74,1.6 62.068,1.6 L62.068,1.6 L52.348,1.6 C51.388,1.6 50.56,1.648 49.864,1.744 C49.168,1.84 48.532,2.152 47.956,2.68 L47.956,2.68 L33.916,17.296 L20.524,2.608 C20.332,2.368 19.972,2.14 19.444,1.924 C18.916,1.708 18.412,1.6 17.932,1.6 L17.932,1.6 L6.772,1.6 C6.052,1.6 5.44,1.852 4.936,2.356 C4.432,2.86 4.18,3.448 4.18,4.12 L4.18,4.12 L4.18,49.408 C4.18,50.08 4.432,50.68 4.936,51.208 C5.44,51.736 6.052,52 6.772,52 L6.772,52 L16.492,52 Z M110.74,52 C111.556,52 112.264,51.676 112.864,51.028 C113.464,50.38 113.764,49.624 113.764,48.76 L113.764,48.76 L113.764,42.568 C113.764,41.608 113.464,40.828 112.864,40.228 C112.264,39.628 111.556,39.328 110.74,39.328 L110.74,39.328 L89.428,39.328 L89.428,32.92 L109.732,32.92 C110.5,32.92 111.184,32.596 111.784,31.948 C112.384,31.3 112.684,30.568 112.684,29.752 L112.684,29.752 L112.684,23.488 C112.684,22.576 112.384,21.82 111.784,21.22 C111.184,20.62 110.5,20.32 109.732,20.32 L109.732,20.32 L89.428,20.32 L89.428,14.488 L110.74,14.488 C111.508,14.488 112.204,14.164 112.828,13.516 C113.452,12.868 113.764,12.136 113.764,11.32 L113.764,11.32 L113.764,5.056 C113.764,4.144 113.464,3.388 112.864,2.788 C112.264,2.188 111.556,1.888 110.74,1.888 L110.74,1.888 L76.756,1.888 C75.94,1.888 75.232,2.188 74.632,2.788 C74.032,3.388 73.732,4.144 73.732,5.056 L73.732,5.056 L73.732,48.76 C73.732,49.624 74.032,50.38 74.632,51.028 C75.232,51.676 75.94,52 76.756,52 L76.756,52 L110.74,52 Z M147.604,52 C148.42,52 149.104,51.688 149.656,51.064 C150.208,50.44 150.484,49.672 150.484,48.76 L150.484,48.76 L150.484,16.216 L161.86,16.216 C162.676,16.216 163.396,15.904 164.02,15.28 C164.644,14.656 164.956,13.936 164.956,13.12 L164.956,13.12 L164.956,4.768 C164.956,4 164.644,3.316 164.02,2.716 C163.396,2.116 162.676,1.816 161.86,1.816 L161.86,1.816 L124.132,1.816 C123.22,1.816 122.464,2.104 121.864,2.68 C121.264,3.256 120.964,3.952 120.964,4.768 L120.964,4.768 L120.964,13.12 C120.964,13.936 121.264,14.656 121.864,15.28 C122.464,15.904 123.22,16.216 124.132,16.216 L124.132,16.216 L135.652,16.216 L135.148,48.832 C135.148,49.744 135.424,50.5 135.976,51.1 C136.528,51.7 137.212,52 138.028,52 L138.028,52 L147.604,52 Z M175.828,52 C176.836,52 177.676,51.82 178.348,51.46 C179.02,51.1 179.452,50.584 179.644,49.912 L179.644,49.912 L181.876,42.712 L197.932,42.712 L200.164,49.912 C200.356,50.584 200.8,51.1 201.496,51.46 C202.192,51.82 203.044,52 204.052,52 L204.052,52 L213.916,52 C215.836,51.712 216.796,50.704 216.796,48.976 C216.796,48.304 216.676,47.596 216.436,46.852 C216.196,46.108 216.052,45.616 216.004,45.376 L216.004,45.376 L199.876,4.84 C199.588,3.976 199.036,3.232 198.22,2.608 C197.404,1.984 196.372,1.648 195.124,1.6 L195.124,1.6 L184.756,1.6 C183.604,1.648 182.608,1.948 181.768,2.5 C180.928,3.052 180.292,3.832 179.86,4.84 L179.86,4.84 L163.876,45.376 C163.828,45.472 163.672,45.916 163.408,46.708 C163.144,47.5 163.012,48.304 163.012,49.12 C163.012,50.752 163.948,51.712 165.82,52 L165.82,52 L175.828,52 Z M195.34,30.544 L184.036,30.544 L189.652,13.624 L195.34,30.544 Z M245.38,53.08 C250.612,53.08 255.652,51.544 260.5,48.472 C261.22,47.944 261.58,47.296 261.58,46.528 C261.58,45.808 261.292,45.16 260.716,44.584 L260.716,44.584 L252.796,36.808 C252.364,36.376 251.836,36.16 251.212,36.16 C250.78,36.16 250.372,36.256 249.988,36.448 C248.356,37.12 246.796,37.456 245.308,37.456 C243.244,37.456 241.348,36.952 239.62,35.944 C237.892,34.936 236.512,33.58 235.48,31.876 C234.448,30.172 233.932,28.336 233.932,26.368 C233.932,24.352 234.436,22.504 235.444,20.824 C236.452,19.144 237.832,17.812 239.584,16.828 C241.336,15.844 243.244,15.352 245.308,15.352 C246.892,15.352 248.332,15.64 249.628,16.216 C250.012,16.408 250.444,16.504 250.924,16.504 C251.548,16.504 252.1,16.264 252.58,15.784 L252.58,15.784 L259.636,8.008 C260.164,7.384 260.428,6.76 260.428,6.136 C260.428,5.224 259.996,4.528 259.132,4.048 C254.86,1.552 250.276,0.304 245.38,0.304 C240.532,0.304 236.032,1.492 231.88,3.868 C227.728,6.244 224.44,9.448 222.016,13.48 C219.592,17.512 218.38,21.904 218.38,26.656 C218.38,31.408 219.592,35.812 222.016,39.868 C224.44,43.924 227.728,47.14 231.88,49.516 C236.032,51.892 240.532,53.08 245.38,53.08 Z M279.796,52 C280.804,52 281.644,51.82 282.316,51.46 C282.988,51.1 283.42,50.584 283.612,49.912 L283.612,49.912 L285.844,42.712 L301.9,42.712 L304.132,49.912 C304.324,50.584 304.768,51.1 305.464,51.46 C306.16,51.82 307.012,52 308.02,52 L308.02,52 L317.884,52 C319.804,51.712 320.764,50.704 320.764,48.976 C320.764,48.304 320.644,47.596 320.404,46.852 C320.164,46.108 320.02,45.616 319.972,45.376 L319.972,45.376 L303.844,4.84 C303.556,3.976 303.004,3.232 302.188,2.608 C301.372,1.984 300.34,1.648 299.092,1.6 L299.092,1.6 L288.724,1.6 C287.572,1.648 286.576,1.948 285.736,2.5 C284.896,3.052 284.26,3.832 283.828,4.84 L283.828,4.84 L267.844,45.376 C267.796,45.472 267.64,45.916 267.376,46.708 C267.112,47.5 266.98,48.304 266.98,49.12 C266.98,50.752 267.916,51.712 269.788,52 L269.788,52 L279.796,52 Z M299.308,30.544 L288.004,30.544 L293.62,13.624 L299.308,30.544 Z M352.588,52 C353.404,52 354.088,51.688 354.64,51.064 C355.192,50.44 355.468,49.672 355.468,48.76 L355.468,48.76 L355.468,16.216 L366.844,16.216 C367.66,16.216 368.38,15.904 369.004,15.28 C369.628,14.656 369.94,13.936 369.94,13.12 L369.94,13.12 L369.94,4.768 C369.94,4 369.628,3.316 369.004,2.716 C368.38,2.116 367.66,1.816 366.844,1.816 L366.844,1.816 L329.116,1.816 C328.204,1.816 327.448,2.104 326.848,2.68 C326.248,3.256 325.948,3.952 325.948,4.768 L325.948,4.768 L325.948,13.12 C325.948,13.936 326.248,14.656 326.848,15.28 C327.448,15.904 328.204,16.216 329.116,16.216 L329.116,16.216 L340.636,16.216 L340.132,48.832 C340.132,49.744 340.408,50.5 340.96,51.1 C341.512,51.7 342.196,52 343.012,52 L343.012,52 L352.588,52 Z M402.052,52.792 C408.1,52.792 412.912,51.628 416.488,49.3 C420.064,46.972 422.536,44.068 423.904,40.588 C425.272,37.108 425.932,33.424 425.884,29.536 C425.884,29.5309474 425.883967,29.5237673 425.8839,29.5144598 L425.883102,29.4330859 C425.879911,29.1480111 425.868211,28.3183158 425.848,26.944 C425.8294,25.6792 425.818008,22.91524 425.813823,18.65212 L425.813103,17.80828 C425.812997,17.66452 425.8129,17.5192 425.81281,17.37232 L425.812,3.904 C425.86,3.184 425.632,2.62 425.128,2.212 C424.624,1.804 423.916,1.6 423.004,1.6 L423.004,1.6 L413.428,1.6 C412.612,1.6 411.904,1.828 411.304,2.284 C410.704,2.74 410.404,3.28 410.404,3.904 L410.404,3.904 L410.26,27.808 C410.26,34.144 407.476,37.312 401.908,37.312 C399.076,37.312 396.832,36.412 395.176,34.612 C393.52,32.812 392.668,30.352 392.62,27.232 L392.62,27.232 L392.332,3.76 C392.332,3.088 392.068,2.56 391.54,2.176 C391.012,1.792 390.268,1.6 389.308,1.6 L389.308,1.6 L379.876,1.6 C378.244,1.6 377.428,2.32 377.428,3.76 L377.428,3.76 L377.5,28.816 C377.5,33.04 378.376,36.964 380.128,40.588 C381.88,44.212 384.592,47.152 388.264,49.408 C391.936,51.664 396.532,52.792 402.052,52.792 Z M449.284,52.144 C450.148,52.144 450.88,51.844 451.48,51.244 C452.08,50.644 452.38,49.84 452.38,48.832 L452.38,48.832 L452.38,4.912 C452.38,4 452.08,3.22 451.48,2.572 C450.88,1.924 450.148,1.6 449.284,1.6 L449.284,1.6 L439.42,1.6 C438.46,1.6 437.692,1.924 437.116,2.572 C436.54,3.22 436.252,4 436.252,4.912 L436.252,4.912 L436.252,48.832 C436.252,49.84 436.54,50.644 437.116,51.244 C437.692,51.844 438.46,52.144 439.42,52.144 L439.42,52.144 L449.284,52.144 Z" id="metacatui" fill="#FCBF49" fill-rule="nonzero"></path>
    </g>
</svg>
</logo>

    </a>
    <h3>Namespaces</h3><ul><li><a href="AppConfig.html">AppConfig</a></li><li><a href="IconUtilities.html">IconUtilities</a></li><li><a href="MapConfig.html">MapConfig</a></li><li><a href="MetacatUI.html">MetacatUI</a></li><li><a href="SearchParams.html">SearchParams</a></li><li><a href="Utilities.html">Utilities</a></li></ul><h3>Classes</h3><ul><li class='category-heading' data-category='Collections'>Collections</li><li><a href="AccessPolicy.html">AccessPolicy</a></li><li><a href="Citations.html">Citations</a></li><li><a href="DataPackage.html">DataPackage</a></li><li><a href="Filters.html">Filters</a></li><li><a href="ObjectFormats.html">ObjectFormats</a></li><li><a href="ProjectList.html">ProjectList</a></li><li><a href="QualityReport.html">QualityReport</a></li><li><a href="SolrResults.html">SolrResults</a></li><li><a href="Units.html">Units</a></li><li><a href="UserGroup.html">UserGroup</a></li><li class='category-heading' data-category='Collections/Bookkeeper'>Collections/Bookkeeper</li><li><a href="Quotas.html">Quotas</a></li><li><a href="Usages.html">Usages</a></li><li class='category-heading' data-category='Collections/Geohashes'>Collections/Geohashes</li><li><a href="Geohashes.html">Geohashes</a></li><li class='category-heading' data-category='Collections/Maps'>Collections/Maps</li><li><a href="AssetCategories.html">AssetCategories</a></li><li><a href="AssetColors.html">AssetColors</a></li><li><a href="Features.html">Features</a></li><li><a href="GeoPoints.html">GeoPoints</a></li><li><a href="MapAssets.html">MapAssets</a></li><li><a href="VectorFilters.html">VectorFilters</a></li><li><a href="ZoomPresets.html">ZoomPresets</a></li><li class='category-heading' data-category='Collections/Metadata/EML'>Collections/Metadata/EML</li><li><a href="EMLAnnotations.html">EMLAnnotations</a></li><li><a href="EMLMissingValueCodes.html">EMLMissingValueCodes</a></li><li class='category-heading' data-category='Collections/Ontologies'>Collections/Ontologies</li><li><a href="BioontologyResults.html">BioontologyResults</a></li><li class='category-heading' data-category='Collections/QueryFields'>Collections/QueryFields</li><li><a href="QueryFields.html">QueryFields</a></li><li class='category-heading' data-category='Collections/SearchSelect'>Collections/SearchSelect</li><li><a href="SearchSelectOptions.html">SearchSelectOptions</a></li><li class='category-heading' data-category='Models'>Models</li><li><a href="AccessRule.html">AccessRule</a></li><li><a href="Accordion.html">Accordion</a></li><li><a href="AppModel.html">AppModel</a></li><li><a href="CitationModel.html">CitationModel</a></li><li><a href="CollectionModel.html">CollectionModel</a></li><li><a href="DataONEObject.html">DataONEObject</a></li><li><a href="LookupModel.html">LookupModel</a></li><li><a href="Map.html">Map</a></li><li><a href="Metrics.html">Metrics</a></li><li><a href="QualityCheck.html">QualityCheck</a></li><li><a href="Search.html">Search</a></li><li><a href="SolrResult.html">SolrResult</a></li><li><a href="Stats.html">Stats</a></li><li class='category-heading' data-category='Models/Accordion'>Models/Accordion</li><li><a href="AccordionItem.html">AccordionItem</a></li><li class='category-heading' data-category='Models/Analytics'>Models/Analytics</li><li><a href="Analytics.html">Analytics</a></li><li><a href="GoogleAnalytics.html">GoogleAnalytics</a></li><li class='category-heading' data-category='Models/Bookkeeper'>Models/Bookkeeper</li><li><a href="Quota.html">Quota</a></li><li><a href="Subscription.html">Subscription</a></li><li><a href="Usage.html">Usage</a></li><li class='category-heading' data-category='Models/Connectors'>Models/Connectors</li><li><a href="BioontologyAccordionSearchSelect.html">BioontologyAccordionSearchSelect</a></li><li><a href="FiltersMapConnector.html">FiltersMapConnector</a></li><li><a href="FiltersSearchConnector.html">FiltersSearchConnector</a></li><li><a href="GeoPointsCesiumConnector.html">GeoPointsCesiumConnector</a></li><li><a href="GeoPointsCesiumPointsConnector.html">GeoPointsCesiumPointsConnector</a></li><li><a href="GeoPointsCesiumPolygonConnector.html">GeoPointsCesiumPolygonConnector</a></li><li><a href="MapSearchConnector.html">MapSearchConnector</a></li><li><a href="MapSearchFiltersConnector.html">MapSearchFiltersConnector</a></li><li class='category-heading' data-category='Models/Filters'>Models/Filters</li><li><a href="BooleanFilter.html">BooleanFilter</a></li><li><a href="ChoiceFilter.html">ChoiceFilter</a></li><li><a href="DateFilter.html">DateFilter</a></li><li><a href="Filter.html">Filter</a></li><li><a href="FilterGroup.html">FilterGroup</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="SpatialFilter.html">SpatialFilter</a></li><li><a href="ToggleFilter.html">ToggleFilter</a></li><li class='category-heading' data-category='Models/Formats'>Models/Formats</li><li><a href="ObjectFormat.html">ObjectFormat</a></li><li class='category-heading' data-category='Models/Geocoder'>Models/Geocoder</li><li><a href="GeocodedLocation.html">GeocodedLocation</a></li><li><a href="GeocoderSearch.html">GeocoderSearch</a></li><li><a href="GoogleMapsAutocompleter.html">GoogleMapsAutocompleter</a></li><li><a href="GoogleMapsGeocoder.html">GoogleMapsGeocoder</a></li><li><a href="Prediction.html">Prediction</a></li><li class='category-heading' data-category='Models/Geohashes'>Models/Geohashes</li><li><a href="Geohash.html">Geohash</a></li><li class='category-heading' data-category='Models/Maps'>Models/Maps</li><li><a href="AssetCategory.html">AssetCategory</a></li><li><a href="AssetColor.html">AssetColor</a></li><li><a href="AssetColorPalette.html">AssetColorPalette</a></li><li><a href="ExpansionPanelsModel.html">ExpansionPanelsModel</a></li><li><a href="Feature.html">Feature</a></li><li><a href="GeoBoundingBox.html">GeoBoundingBox</a></li><li><a href="GeoPoint.html">GeoPoint</a></li><li><a href="GeoScale.html">GeoScale</a></li><li><a href="GeoUtilities.html">GeoUtilities</a></li><li><a href="MapInteraction.html">MapInteraction</a></li><li><a href="MapModel.html">MapModel</a></li><li><a href="VectorFilter.html">VectorFilter</a></li><li><a href="ViewfinderModel.html">ViewfinderModel</a></li><li><a href="ZoomPresetModel.html">ZoomPresetModel</a></li><li class='category-heading' data-category='Models/Maps/Assets'>Models/Maps/Assets</li><li><a href="Cesium3DTileset.html">Cesium3DTileset</a></li><li><a href="CesiumGeohash.html">CesiumGeohash</a></li><li><a href="CesiumImagery.html">CesiumImagery</a></li><li><a href="CesiumTerrain.html">CesiumTerrain</a></li><li><a href="CesiumVectorData.html">CesiumVectorData</a></li><li><a href="MapAsset.html">MapAsset</a></li><li class='category-heading' data-category='Models/Metadata'>Models/Metadata</li><li><a href="ScienceMetadata.html">ScienceMetadata</a></li><li class='category-heading' data-category='Models/Metadata/EML'>Models/Metadata/EML</li><li><a href="EMLMethodStep.html">EMLMethodStep</a></li><li><a href="EMLSpecializedText.html">EMLSpecializedText</a></li><li><a href="EMLTaxonCoverage.html">EMLTaxonCoverage</a></li><li class='category-heading' data-category='Models/Metadata/EML211'>Models/Metadata/EML211</li><li><a href="EML211.html">EML211</a></li><li><a href="EMLAnnotation.html">EMLAnnotation</a></li><li><a href="EMLAttribute.html">EMLAttribute</a></li><li><a href="EMLDataTable.html">EMLDataTable</a></li><li><a href="EMLDistribution.html">EMLDistribution</a></li><li><a href="EMLEntity.html">EMLEntity</a></li><li><a href="EMLGeoCoverage.html">EMLGeoCoverage</a></li><li><a href="EMLMeasurementScale.html">EMLMeasurementScale</a></li><li><a href="EMLMethods.html">EMLMethods</a></li><li><a href="EMLMissingValueCode.html">EMLMissingValueCode</a></li><li><a href="EMLNonNumericDomain.html">EMLNonNumericDomain</a></li><li><a href="EMLNumericDomain.html">EMLNumericDomain</a></li><li><a href="EMLOtherEntity.html">EMLOtherEntity</a></li><li><a href="EMLParty.html">EMLParty</a></li><li><a href="EMLTemporalCoverage.html">EMLTemporalCoverage</a></li><li><a href="EMLText211.html">EMLText211</a></li><li><a href="EMLUnit.html">EMLUnit</a></li><li class='category-heading' data-category='Models/Metadata/EML220'>Models/Metadata/EML220</li><li><a href="EMLText.html">EMLText</a></li><li class='category-heading' data-category='Models/Ontologies'>Models/Ontologies</li><li><a href="BioOntology.html">BioOntology</a></li><li><a href="Bioontology_.html">Bioontology</a></li><li><a href="BioontologyBatch.html">BioontologyBatch</a></li><li><a href="BioontologyClass.html">BioontologyClass</a></li><li class='category-heading' data-category='Models/Portals'>Models/Portals</li><li><a href="PortalImage.html">PortalImage</a></li><li><a href="PortalModel.html">PortalModel</a></li><li><a href="PortalSectionModel.html">PortalSectionModel</a></li><li class='category-heading' data-category='Models/Projects'>Models/Projects</li><li><a href="Project.html">Project</a></li><li class='category-heading' data-category='Models/QueryFields'>Models/QueryFields</li><li><a href="QueryField.html">QueryField</a></li><li class='category-heading' data-category='Models/SearchSelect'>Models/SearchSelect</li><li><a href="AccountSearchSelect.html">AccountSearchSelect</a></li><li><a href="QueryFieldSearchSelect.html">QueryFieldSearchSelect</a></li><li><a href="SearchSelect.html">SearchSelect</a></li><li><a href="SelectOptionModel.html">SelectOptionModel</a></li><li><a href="SolrAutocomplete.html">SolrAutocomplete</a></li><li class='category-heading' data-category='Router'>Router</li><li><a href="UIRouter.html">UIRouter</a></li><li class='category-heading' data-category='Views'>Views</li><li><a href="AccessPolicyView.html">AccessPolicyView</a></li><li><a href="AccessRuleView.html">AccessRuleView</a></li><li><a href="AnnotationView.html">AnnotationView</a></li><li><a href="AppView.html">AppView</a></li><li><a href="CatalogSearchView.html">CatalogSearchView</a></li><li><a href="CitationHeaderView.html">CitationHeaderView</a></li><li><a href="CitationListView.html">CitationListView</a></li><li><a href="CitationModalView.html">CitationModalView</a></li><li><a href="CitationView.html">CitationView</a></li><li><a href="ColorPaletteView.html">ColorPaletteView</a></li><li><a href="DataCatalogView.html">DataCatalogView</a></li><li><a href="DataCatalogViewWithFilters.html">DataCatalogViewWithFilters</a></li><li><a href="DataItemView.html">DataItemView</a></li><li><a href="DataPackageView.html">DataPackageView</a></li><li><a href="DraftsView.html">DraftsView</a></li><li><a href="EditCollectionView.html">EditCollectionView</a></li><li><a href="EditorView.html">EditorView</a></li><li><a href="FooterView.html">FooterView</a></li><li><a href="GroupListView.html">GroupListView</a></li><li><a href="ImageUploaderView.html">ImageUploaderView</a></li><li><a href="MarkdownEditorView.html">MarkdownEditorView</a></li><li><a href="MarkdownView.html">MarkdownView</a></li><li><a href="MdqRunView.html">MdqRunView</a></li><li><a href="MetadataView.html">MetadataView</a></li><li><a href="MetricModalView.html">MetricModalView</a></li><li><a href="MetricView.html">MetricView</a></li><li><a href="MetricsChartView.html">MetricsChartView</a></li><li><a href="NavbarView.html">NavbarView</a></li><li><a href="RegisterCitationView.html">RegisterCitationView</a></li><li><a href="SearchResultView.html">SearchResultView</a></li><li><a href="SignInView.html">SignInView</a></li><li><a href="TOCView.html">TOCView</a></li><li><a href="TableEditorView.html">TableEditorView</a></li><li><a href="UserGroupView.html">UserGroupView</a></li><li><a href="UserView.html">UserView</a></li><li class='category-heading' data-category='Views/Accordion'>Views/Accordion</li><li><a href="AccordionItemView.html">AccordionItemView</a></li><li><a href="AccordionView.html">AccordionView</a></li><li class='category-heading' data-category='Views/Filters'>Views/Filters</li><li><a href="BooleanFilterView.html">BooleanFilterView</a></li><li><a href="ChoiceFilterView.html">ChoiceFilterView</a></li><li><a href="DateFilterView.html">DateFilterView</a></li><li><a href="FilterEditorView.html">FilterEditorView</a></li><li><a href="FilterGroupView.html">FilterGroupView</a></li><li><a href="FilterGroupsView.html">FilterGroupsView</a></li><li><a href="FilterView.html">FilterView</a></li><li><a href="NumericFilterView.html">NumericFilterView</a></li><li><a href="SemanticFilterView.html">SemanticFilterView</a></li><li><a href="ToggleFilterView.html">ToggleFilterView</a></li><li class='category-heading' data-category='Views/Maps'>Views/Maps</li><li><a href="CesiumWidgetView.html">CesiumWidgetView</a></li><li><a href="DrawTool.html">DrawTool</a></li><li><a href="FeatureInfoView.html">FeatureInfoView</a></li><li><a href="LayerCategoryListView.html">LayerCategoryListView</a></li><li><a href="LayerDetailView.html">LayerDetailView</a></li><li><a href="LayerDetailsView.html">LayerDetailsView</a></li><li><a href="LayerInfoView.html">LayerInfoView</a></li><li><a href="LayerItemView.html">LayerItemView</a></li><li><a href="LayerListView.html">LayerListView</a></li><li><a href="LayerNavigationView.html">LayerNavigationView</a></li><li><a href="LayerOpacityView.html">LayerOpacityView</a></li><li><a href="LayersPanelView.html">LayersPanelView</a></li><li><a href="LegendView.html">LegendView</a></li><li><a href="MapHelpPanel.html">MapHelpPanel</a></li><li><a href="MapView.html">MapView</a></li><li><a href="MapWidgetContainerView.html">MapWidgetContainerView</a></li><li><a href="PredictionView.html">PredictionView</a></li><li><a href="PredictionsListView.html">PredictionsListView</a></li><li><a href="ScaleBarView.html">ScaleBarView</a></li><li><a href="SearchInputView.html">SearchInputView</a></li><li><a href="SearchView.html">SearchView</a></li><li><a href="ShareUrlView.html">ShareUrlView</a></li><li><a href="ToolbarView.html">ToolbarView</a></li><li><a href="ViewfinderView.html">ViewfinderView</a></li><li class='category-heading' data-category='Views/Maps/Legend'>Views/Maps/Legend</li><li><a href="CategoricalSwatchView.html">CategoricalSwatchView</a></li><li><a href="ContinuousSwatchView.html">ContinuousSwatchView</a></li><li><a href="LayerLegendView.html">LayerLegendView</a></li><li><a href="LegendContainerView.html">LegendContainerView</a></li><li class='category-heading' data-category='Views/Maps/Viewfinder'>Views/Maps/Viewfinder</li><li><a href="ExpansionPanelView.html">ExpansionPanelView</a></li><li><a href="ZoomPresetView.html">ZoomPresetView</a></li><li><a href="ZoomPresetsListView.html">ZoomPresetsListView</a></li><li class='category-heading' data-category='Views/Metadata'>Views/Metadata</li><li><a href="EML211EditorView.html">EML211EditorView</a></li><li><a href="EMLAttributeView.html">EMLAttributeView</a></li><li><a href="EMLEntityView.html">EMLEntityView</a></li><li><a href="EMLMeasurementScaleView.html">EMLMeasurementScaleView</a></li><li><a href="EMLMeasurementTypeView.html">EMLMeasurementTypeView</a></li><li><a href="EMLMethodsView.html">EMLMethodsView</a></li><li><a href="EMLMissingValueCodeView.html">EMLMissingValueCodeView</a></li><li><a href="EMLMissingValueCodesView.html">EMLMissingValueCodesView</a></li><li><a href="EMLOtherEntityView.html">EMLOtherEntityView</a></li><li><a href="EMLPartyView.html">EMLPartyView</a></li><li><a href="EMLTempCoverageView.html">EMLTempCoverageView</a></li><li><a href="EMLView.html">EMLView</a></li><li><a href="EMlGeoCoverageView_.html">EMlGeoCoverageView</a></li><li><a href="ScienceMetadataView.html">ScienceMetadataView</a></li><li class='category-heading' data-category='Views/Ontologies'>Views/Ontologies</li><li><a href="BioontologyBrowser.html">BioontologyBrowser</a></li><li class='category-heading' data-category='Views/Portals'>Views/Portals</li><li><a href="PortalDataView.html">PortalDataView</a></li><li><a href="PortalHeaderView.html">PortalHeaderView</a></li><li><a href="PortalListView.html">PortalListView</a></li><li><a href="PortalLogosView.html">PortalLogosView</a></li><li><a href="PortalMembersView.html">PortalMembersView</a></li><li><a href="PortalSectionView.html">PortalSectionView</a></li><li><a href="PortalUsagesView.html">PortalUsagesView</a></li><li><a href="PortalView.html">PortalView</a></li><li><a href="PortalVisualizationsView.html">PortalVisualizationsView</a></li><li><a href="PortalsSearchView.html">PortalsSearchView</a></li><li class='category-heading' data-category='Views/Portals/Editor'>Views/Portals/Editor</li><li><a href="PortEditorDataView.html">PortEditorDataView</a></li><li><a href="PortEditorImageView.html">PortEditorImageView</a></li><li><a href="PortEditorLogosView.html">PortEditorLogosView</a></li><li><a href="PortEditorMdSectionView.html">PortEditorMdSectionView</a></li><li><a href="PortEditorSectionView.html">PortEditorSectionView</a></li><li><a href="PortEditorSectionsView.html">PortEditorSectionsView</a></li><li><a href="PortEditorSettingsView.html">PortEditorSettingsView</a></li><li><a href="PortalEditorView.html">PortalEditorView</a></li><li class='category-heading' data-category='Views/Projects'>Views/Projects</li><li><a href="ProjectView.html">ProjectView</a></li><li class='category-heading' data-category='Views/QueryBuilder'>Views/QueryBuilder</li><li><a href="QueryBuilderView.html">QueryBuilderView</a></li><li><a href="QueryRuleView.html">QueryRuleView</a></li><li class='category-heading' data-category='Views/Search'>Views/Search</li><li><a href="SearchResultsPagerView.html">SearchResultsPagerView</a></li><li><a href="SearchResultsView.html">SearchResultsView</a></li><li><a href="SorterView.html">SorterView</a></li><li class='category-heading' data-category='Views/SearchSelect'>Views/SearchSelect</li><li><a href="AccountSelectView.html">AccountSelectView</a></li><li><a href="AnnotationFilter.html">AnnotationFilter</a></li><li><a href="BioontologySelectView.html">BioontologySelectView</a></li><li><a href="NodeSelect.html">NodeSelect</a></li><li><a href="ObjectFormatSelect.html">ObjectFormatSelect</a></li><li><a href="QueryFieldSelectView.html">QueryFieldSelectView</a></li><li><a href="SearchSelectView.html">SearchSelectView</a></li><li><a href="SeparatorView.html">SeparatorView</a></li><li class='category-heading' data-category='Deprecated'>Deprecated</li><li><a href="AnnotatorView.html">AnnotatorView</a></li><li><a href="ExternalView.html">ExternalView</a></li><li><a href="LogsSearch.html">LogsSearch</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addClassesFromResponse">addClassesFromResponse</a></li><li><a href="global.html#addFields">addFields</a></li><li><a href="global.html#addSelected">addSelected</a></li><li><a href="global.html#appConfigPath">appConfigPath</a></li><li><a href="global.html#buildChildrenUrl">buildChildrenUrl</a></li><li><a href="global.html#buildSearchUrl">buildSearchUrl</a></li><li><a href="global.html#canChangeSeparator">canChangeSeparator</a></li><li><a href="global.html#changeSubmenuOnSearch">changeSubmenuOnSearch</a></li><li><a href="global.html#couldBeLatLong">couldBeLatLong</a></li><li><a href="global.html#createBatchPayload">createBatchPayload</a></li><li><a href="global.html#createHeaders">createHeaders</a></li><li><a href="global.html#defaults">defaults</a></li><li><a href="global.html#encodeIfPresent">encodeIfPresent</a></li><li><a href="global.html#excludeFields">excludeFields</a></li><li><a href="global.html#fetchClasses">fetchClasses</a></li><li><a href="global.html#fetchClassesFromOntology">fetchClassesFromOntology</a></li><li><a href="global.html#fetchFromOntologies">fetchFromOntologies</a></li><li><a href="global.html#fetchQueryFields">fetchQueryFields</a></li><li><a href="global.html#fieldToOption">fieldToOption</a></li><li><a href="global.html#filterClassesToFetch">filterClassesToFetch</a></li><li><a href="global.html#finalizeFetch">finalizeFetch</a></li><li><a href="global.html#formatResult">formatResult</a></li><li><a href="global.html#formatResults">formatResults</a></li><li><a href="global.html#getAccountDetails">getAccountDetails</a></li><li><a href="global.html#getCachedClasses">getCachedClasses</a></li><li><a href="global.html#getCategoryNames">getCategoryNames</a></li><li><a href="global.html#getChildren">getChildren</a></li><li><a href="global.html#getClasses">getClasses</a></li><li><a href="global.html#getIncludeParam">getIncludeParam</a></li><li><a href="global.html#getNextPage">getNextPage</a></li><li><a href="global.html#getNextSeparator">getNextSeparator</a></li><li><a href="global.html#getOptionByLabelOrValue">getOptionByLabelOrValue</a></li><li><a href="global.html#getOptionsByCategory">getOptionsByCategory</a></li><li><a href="global.html#getQueryFieldOptions">getQueryFieldOptions</a></li><li><a href="global.html#getSelectedModels">getSelectedModels</a></li><li><a href="global.html#hasInvalidSelections">hasInvalidSelections</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#initializeFetch">initializeFetch</a></li><li><a href="global.html#isValidValue">isValidValue</a></li><li><a href="global.html#model">model</a></li><li><a href="global.html#moveClassesToNotFound">moveClassesToNotFound</a></li><li><a href="global.html#optionsAsJSON">optionsAsJSON</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#recordError">recordError</a></li><li><a href="global.html#removeSelected">removeSelected</a></li><li><a href="global.html#renameCategory">renameCategory</a></li><li><a href="global.html#resetPageInfo">resetPageInfo</a></li><li><a href="global.html#responseAsync">responseAsync</a></li><li><a href="global.html#separatorRequired">separatorRequired</a></li><li><a href="global.html#setAddedFieldDetails">setAddedFieldDetails</a></li><li><a href="global.html#setNextSeparator">setNextSeparator</a></li><li><a href="global.html#setOptionsForPreselected">setOptionsForPreselected</a></li><li><a href="global.html#setSelected">setSelected</a></li><li><a href="global.html#sortByProp">sortByProp</a></li><li><a href="global.html#sortFields">sortFields</a></li><li><a href="global.html#taxonomicClassification">taxonomicClassification</a></li><li><a href="global.html#toAccordionItem">toAccordionItem</a></li><li><a href="global.html#toJSON">toJSON</a></li><li><a href="global.html#toSearchSelectOption">toSearchSelectOption</a></li><li><a href="global.html#updateOptions">updateOptions</a></li><li><a href="global.html#url">url</a></li><li><a href="global.html#waitForFetchComplete">waitForFetchComplete</a></li></ul>
</nav>

<div id="main">

    <h1 class="page-title">Source: src/js/views/DataCatalogView.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>define([
  "jquery",
  "underscore",
  "backbone",
  "collections/SolrResults",
  "models/Search",
  "models/MetricsModel",
  "common/Utilities",
  "views/SearchResultView",
  "views/searchSelect/BioontologySelectView",
  "text!templates/search.html",
  "text!templates/statCounts.html",
  "text!templates/pager.html",
  "text!templates/mainContent.html",
  "text!templates/currentFilter.html",
  "text!templates/loading.html",
  "gmaps",
  "nGeohash",
], (
  $,
  _,
  Backbone,
  SearchResults,
  SearchModel,
  MetricsModel,
  Utilities,
  SearchResultView,
  BioontologySelectView,
  CatalogTemplate,
  CountTemplate,
  PagerTemplate,
  MainContentTemplate,
  CurrentFilterTemplate,
  LoadingTemplate,
  gmaps,
  nGeohash,
) => {
  "use strict";

  /**
   * @class DataCatalogView
   * @classcategory Views
   * @augments Backbone.View
   * @class
   * @deprecated
   * @description This view is deprecated and will eventually be removed in a future version (likely 3.0.0)
   */
  const DataCatalogView = Backbone.View.extend(
    /** @lends DataCatalogView.prototype */ {
      el: "#Content",

      isSubView: false,
      filters: true, // Turn on/off the filters in this view

      /**
       * If true, the view height will be adjusted to fit the height of the window
       * If false, the view height will be fixed via CSS
       * @type {boolean}
       */
      fixedHeight: false,

      // The default global models for searching
      searchModel: null,
      searchResults: null,
      statsModel: null,
      mapModel: null,

      /**
       * The templates for this view
       * @type {Underscore.template}
       */
      template: _.template(CatalogTemplate),
      statsTemplate: _.template(CountTemplate),
      pagerTemplate: _.template(PagerTemplate),
      mainContentTemplate: _.template(MainContentTemplate),
      currentFilterTemplate: _.template(CurrentFilterTemplate),
      loadingTemplate: _.template(LoadingTemplate),
      metricStatTemplate: _.template(
        "&lt;span class='metric-icon'> &lt;i class='icon" +
          " &lt;%=metricIcon%>'>&lt;/i> &lt;/span>" +
          "&lt;span class='metric-value'> &lt;i class='icon metric-icon'>" +
          "&lt;/i> &lt;/span>",
      ),

      // Search mode
      mode: "map",

      // Map settings and storage
      map: null,
      ready: false,
      allowSearch: true,
      hasZoomed: false,
      hasDragged: false,
      markers: {},
      tiles: [],
      tileCounts: [],

      /**
       * The general error message to show as a title in the error box when there
       * is an error fetching results from solr
       * @type {string}
       * @default "Something went wrong while getting the list of datasets"
       * @since 2.15.0
       */
      solrErrorTitle: "Something went wrong while getting the list of datasets",

      /**
       * The user-friendly text to show when a solr request gives a status 500
       * error. If none is provided, then the error message that is returned from
       * solr will be displayed.
       * @type {string}
       * @since 2.15.0
       */
      solrError500Message: null,

      // Contains the geohashes for all the markers on the map (if turned on in the Map model)
      markerGeohashes: [],
      // Contains all the info windows for all the markers on the map (if turned on in the Map model)
      markerInfoWindows: [],
      // Contains all the info windows for each document in the search result list - to display on hover
      tileInfoWindows: [],
      // Contains all the currently visible markers on the map
      resultMarkers: [],
      // The geohash value for each tile drawn on the map
      tileGeohashes: [],
      mapFilterToggle: ".toggle-map-filter",

      // Delegated events for creating new items, and clearing completed ones.
      events: {
        "click #results_prev": "prevpage",
        "click #results_next": "nextpage",
        "click #results_prev_bottom": "prevpage",
        "click #results_next_bottom": "nextpage",
        "click .pagerLink": "navigateToPage",
        "click .filter.btn": "updateTextFilters",
        "keypress input[type='text'].filter": "triggerOnEnter",
        "focus input[type='text'].filter": "getAutocompletes",
        "change #sortOrder": "triggerSearch",
        "change #min_year": "updateYearRange",
        "change #max_year": "updateYearRange",
        "click #publish_year": "updateYearRange",
        "click #data_year": "updateYearRange",
        "click .remove-filter": "removeFilter",
        "click input[type='checkbox'].filter": "updateBooleanFilters",
        "click #clear-all": "resetFilters",
        "click .remove-addtl-criteria": "removeAdditionalCriteria",
        "click .collapse-me": "collapse",
        "click .filter-contain .expand-collapse-control":
          "toggleFilterCollapse",
        "click #toggle-map": "toggleMapMode",
        "click .toggle-map": "toggleMapMode",
        "click .toggle-list": "toggleList",
        "click .toggle-map-filter": "toggleMapFilter",
        "mouseover .open-marker": "showResultOnMap",
        "mouseout .open-marker": "hideResultOnMap",
        "mouseover .prevent-popover-runoff": "preventPopoverRunoff",
      },

      initialize(options) {
        const view = this;

        // Get all the options and apply them to this view
        if (options) {
          const optionKeys = Object.keys(options);
          _.each(optionKeys, (key, i) => {
            view[key] = options[key];
          });
        }
      },

      // Render the main view and/or re-render subviews. Don't call .html() here
      // so we don't lose state, rather use .setElement(). Delegate rendering
      // and event handling to sub views
      render() {
        // Use the global models if there are no other models specified at time of render
        if (
          MetacatUI.appModel.get("searchHistory").length > 0 &amp;&amp;
          (!this.searchModel || Object.keys(this.searchModel).length == 0)
        ) {
          const lastSearchModels = _.last(
            MetacatUI.appModel.get("searchHistory"),
          );

          if (lastSearchModels) {
            if (lastSearchModels.search) {
              this.searchModel = lastSearchModels.search.clone();
            }

            if (lastSearchModels.map) {
              this.mapModel = lastSearchModels.map.clone();
            }
          }
        } else if (
          typeof MetacatUI.appSearchModel !== "undefined" &amp;&amp;
          (!this.searchModel || Object.keys(this.searchModel).length == 0)
        ) {
          this.searchModel = MetacatUI.appSearchModel;
          this.mapModel = MetacatUI.mapModel;
          this.statsModel = MetacatUI.statsModel;
        }

        if (!this.mapModel &amp;&amp; gmaps) {
          this.mapModel = MetacatUI.mapModel;
        }

        if (
          (typeof this.searchResults === "undefined" ||
            !this.searchResults ||
            Object.keys(this.searchResults).length == 0) &amp;&amp;
          MetacatUI.appSearchResults &amp;&amp;
          Object.keys(MetacatUI.appSearchResults).length > 0
        ) {
          this.searchResults = MetacatUI.appSearchResults;

          if (!this.statsModel) {
            this.statsModel = MetacatUI.statsModel;
          }

          if (!this.mapModel) {
            this.mapModel = MetacatUI.mapModel;
          }
        }

        // Get the search mode - either "map" or "list"
        if (typeof this.mode === "undefined" || !this.mode) {
          this.mode = MetacatUI.appModel.get("searchMode");
          if (typeof this.mode === "undefined" || !this.mode) {
            this.mode = "map";
          }
          MetacatUI.appModel.set("searchMode", this.mode);
        }
        if ($(window).outerWidth() &lt;= 600) {
          this.mode = "list";
          MetacatUI.appModel.set("searchMode", "list");
          gmaps = null;
        }

        if (!this.isSubView) {
          MetacatUI.appModel.set("headerType", "default");
          $("body").addClass("DataCatalog");
        } else {
          this.$el.addClass("DataCatalog");
        }

        // Populate the search template with some model attributes
        const loadingHTML = this.loadingTemplate({
          msg: "Retrieving member nodes...",
        });

        const templateVars = {
          gmaps,
          mode: MetacatUI.appModel.get("searchMode"),
          useMapBounds: this.searchModel.get("useGeohash"),
          username: MetacatUI.appUserModel.get("username"),
          isMySearch:
            _.indexOf(
              this.searchModel.get("username"),
              MetacatUI.appUserModel.get("username"),
            ) > -1,
          loading: loadingHTML,
          searchModelRef: this.searchModel,
          searchResultsRef: this.searchResults,
          dataSourceTitle:
            MetacatUI.theme == "dataone" ? "Member Node" : "Data source",
        };
        const cel = this.template(
          _.extend(this.searchModel.toJSON(), templateVars),
        );

        this.$el.html(cel);

        // Hide the filters that are disabled in the AppModel settings
        _.each(
          this.$(".filter-contain[data-category]"),
          (filterEl) => {
            if (
              !_.contains(
                MetacatUI.appModel.get("defaultSearchFilters"),
                $(filterEl).attr("data-category"),
              )
            ) {
              $(filterEl).hide();
            }
          },
          this,
        );

        // Store some references to key views that we use repeatedly
        this.$resultsview = this.$("#results-view");
        this.$results = this.$("#results");

        // Update stats
        this.updateStats();

        // Render the Google Map
        this.renderMap();

        // Initialize the tooltips
        const tooltips = $(".tooltip-this");

        // Find the tooltips that are on filter labels - add a slight delay to those
        const groupedTooltips = _.groupBy(
          tooltips,
          (t) =>
            ($(t).prop("tagName") == "LABEL" ||
              $(t).parent().prop("tagName") == "LABEL") &amp;&amp;
            $(t).parents(".filter-container").length > 0,
        );
        const forFilterLabel = true;
        const forOtherElements = false;

        $(groupedTooltips[forFilterLabel]).tooltip({
          delay: {
            show: "800",
          },
        });
        $(groupedTooltips[forOtherElements]).tooltip();

        // Initialize all popover elements
        $(".popover-this").popover();

        // Initialize the resizeable content div
        $("#content").resizable({
          handles: "n,s,e,w",
        });

        // Collapse the filters
        this.toggleFilterCollapse();

        // Iterate through each search model text attribute and show UI filter for each
        const categories = [
          "all",
          "attribute",
          "creator",
          "id",
          "taxon",
          "spatial",
          "additionalCriteria",
          "annotation",
          "isPrivate",
        ];
        let thisTerm = null;

        for (let i = 0; i &lt; categories.length; i++) {
          thisTerm = this.searchModel.get(categories[i]);

          if (thisTerm === undefined || thisTerm === null) break;

          for (let x = 0; x &lt; thisTerm.length; x++) {
            this.showFilter(categories[i], thisTerm[x]);
          }
        }

        // List the Member Node filters
        const view = this;
        _.each(
          _.contains(
            MetacatUI.appModel.get("defaultSearchFilters"),
            "dataSource",
          ),
          (source, i) => {
            view.showFilter("dataSource", source);
          },
        );

        // Add the custom query under the "Anything" filter
        if (this.searchModel.get("customQuery")) {
          this.showFilter("all", this.searchModel.get("customQuery"));
        }

        // Register listeners; this is done here in render because the HTML
        // needs to be bound before the listenTo call can be made
        this.stopListening(this.searchResults);
        this.stopListening(this.searchModel);
        this.stopListening(MetacatUI.appModel);
        this.listenTo(this.searchResults, "reset", this.cacheSearch);
        this.listenTo(this.searchResults, "add", this.addOne);
        this.listenTo(this.searchResults, "reset", this.addAll);
        this.listenTo(this.searchResults, "reset", this.checkForProv);
        this.listenTo(this.searchResults, "error", this.showError);

        // List data sources
        this.listDataSources();
        this.listenTo(
          MetacatUI.nodeModel,
          "change:members",
          this.listDataSources,
        );

        // listen to the MetacatUI.appModel for the search trigger
        this.listenTo(MetacatUI.appModel, "search", this.getResults);

        this.listenTo(
          MetacatUI.appUserModel,
          "change:loggedIn",
          this.triggerSearch,
        );

        // and go to a certain page if we have it
        this.getResults();

        // Set a custom height on any elements that have the .auto-height class
        if ($(".auto-height").length > 0 &amp;&amp; !this.fixedHeight) {
          // Readjust the height whenever the window is resized
          $(window).resize(this.setAutoHeight);
          $(".auto-height-member").resize(this.setAutoHeight);
        }

        this.addAnnotationFilter();

        return this;
      },

      /**
       * addAnnotationFilter - Add the annotation filter to the view
       */
      addAnnotationFilter() {
        const view = this;
        if (!MetacatUI.appModel.get("bioportalAPIKey")) return;
        const containerSelector =
          "[data-category='annotation'] .expand-collapse-control + .filter-input-contain";
        const container = this.$el.find(containerSelector);
        if (!container) return;
        const annotationFilter = new BioontologySelectView({
          inputLabel: "",
          compact: true,
        }).render();
        container.append(annotationFilter.el);
        const bioModel = annotationFilter.model;
        this.stopListening(bioModel, "change:selected");
        this.listenTo(bioModel, "change:selected", (model, selected) => {
          const value = selected?.[0] || "";
          const option = model.get("options").getOptionByLabelOrValue(value);
          const filterLabel = option?.get("label") || "";
          const mockEvent = { target: annotationFilter.el };
          const item = { value, filterLabel };
          view.updateTextFilters(mockEvent, item);
        });
      },

      // Linked Data Object for appending the jsonld into the browser DOM
      getLinkedData() {
        // Find the MN info from the CN Node list
        const members = MetacatUI.nodeModel.get("members");
        for (let i = 0; i &lt; members.length; i++) {
          if (
            members[i].identifier ==
            MetacatUI.nodeModel.get("currentMemberNode")
          ) {
            var nodeModelObject = members[i];
          }
        }

        // JSON Linked Data Object
        const elJSON = {
          "@context": {
            "@vocab": "http://schema.org/",
          },
          "@type": "DataCatalog",
        };
        if (nodeModelObject) {
          // "keywords": "",
          // "provider": "",
          const conditionalData = {
            description: nodeModelObject.description,
            identifier: nodeModelObject.identifier,
            image: nodeModelObject.logo,
            name: nodeModelObject.name,
            url: nodeModelObject.url,
          };
          $.extend(elJSON, conditionalData);
        }

        // Check if the jsonld already exists from the previous data view
        // If not create a new script tag and append otherwise replace the text for the script
        if (!document.getElementById("jsonld")) {
          const el = document.createElement("script");
          el.type = "application/ld+json";
          el.id = "jsonld";
          el.text = JSON.stringify(elJSON);
          document.querySelector("head").appendChild(el);
        } else {
          const script = document.getElementById("jsonld");
          script.text = JSON.stringify(elJSON);
        }
      },

      /*
       * Sets the height on elements in the main content area to fill up the entire area minus header and footer
       */
      setAutoHeight() {
        // If we are in list mode, don't determine the height of any elements because we are not "full screen"
        if (
          MetacatUI.appModel.get("searchMode") == "list" ||
          this.fixedHeight
        ) {
          MetacatUI.appView.$(".auto-height").height("auto");
          return;
        }

        // Get the heights of the header, navbar, and footer
        var otherHeight = 0;
        $(".auto-height-member").each((i, el) => {
          if ($(el).css("display") != "none") {
            otherHeight += $(el).outerHeight(true);
          }
        });

        // Get the remaining height left based on the window size
        let remainingHeight = $(window).outerHeight(true) - otherHeight;
        if (remainingHeight &lt; 0)
          remainingHeight = $(window).outerHeight(true) || 300;
        else if (remainingHeight &lt;= 120)
          remainingHeight =
            $(window).outerHeight(true) - remainingHeight || 300;

        // Adjust all elements with the .auto-height class
        $(".auto-height").height(remainingHeight);

        if (
          $("#map-container.auto-height").length > 0 &amp;&amp;
          $("#map-canvas").length > 0
        ) {
          var otherHeight = 0;
          $("#map-container.auto-height")
            .children()
            .each((i, el) => {
              if ($(el).attr("id") != "map-canvas") {
                otherHeight += $(el).outerHeight(true);
              }
            });
          const newMapHeight = remainingHeight - otherHeight;
          if (newMapHeight > 100) {
            $("#map-canvas").height(remainingHeight - otherHeight);
          }
        }

        // Trigger a resize for the map so that all of the map background images are loaded
        if (gmaps &amp;&amp; this.mapModel &amp;&amp; this.mapModel.get("map")) {
          google.maps.event.trigger(this.mapModel.get("map"), "resize");
        }
      },

      /*
       * ==================================================================================================
       *                                         PERFORMING SEARCH
       * ==================================================================================================
       */
      triggerSearch() {
        // Set the sort order
        const sortOrder = $("#sortOrder").val();
        if (sortOrder) {
          this.searchModel.set("sortOrder", sortOrder);
        }

        // Trigger a search to load the results
        MetacatUI.appModel.trigger("search");

        if (!this.isSubView) {
          // make sure the browser knows where we are
          const route = Backbone.history.fragment;
          if (route.indexOf("data") &lt; 0) {
            MetacatUI.uiRouter.navigate("data", {
              trigger: false,
              replace: true,
            });
          } else {
            MetacatUI.uiRouter.navigate(route);
          }
        }

        // ...but don't want to follow links
        return false;
      },

      triggerOnEnter(e) {
        if (e.keyCode != 13) return;

        // Update the filters
        this.updateTextFilters(e);
      },

      /**
       * getResults gets all the current search filters from the searchModel, creates a Solr query, and runs that query.
       * @param {number} page - The page of search results to get results for
       */
      getResults(page) {
        // Set the sort order based on user choice
        const sortOrder = this.searchModel.get("sortOrder");
        if (sortOrder) {
          this.searchResults.setSort(sortOrder);
        }

        // Specify which fields to retrieve
        let fields = "";
        fields += "id,";
        fields += "seriesId,";
        fields += "title,";
        fields += "origin,";
        fields += "pubDate,";
        fields += "dateUploaded,";
        fields += "abstract,";
        fields += "resourceMap,";
        fields += "beginDate,";
        fields += "endDate,";
        fields += "read_count_i,";
        fields += "geohash_9,";
        fields += "datasource,";
        fields += "isPublic,";
        fields += "documents,";
        fields += "sem_annotation,";
        // Add spatial fields if the map is present
        if (gmaps) {
          fields += "northBoundCoord,";
          fields += "southBoundCoord,";
          fields += "eastBoundCoord,";
          fields += "westBoundCoord";
        }
        // Strip the last trailing comma if needed
        if (fields[fields.length - 1] === ",") {
          fields = fields.substr(0, fields.length - 1);
        }
        this.searchResults.setfields(fields);

        // Get the query
        const query = this.searchModel.getQuery();

        // Specify which facets to retrieve
        if (gmaps &amp;&amp; this.map) {
          // If we have Google Maps enabled
          const geohashLevel = `geohash_${this.mapModel.determineGeohashLevel(this.map.zoom)}`;
          this.searchResults.facet.push(geohashLevel);
        }

        // Run the query
        this.searchResults.setQuery(query);

        // Get the page number
        if (this.isSubView) {
          var page = 0;
        } else {
          var page = MetacatUI.appModel.get("page");
          if (page == null) {
            page = 0;
          }
        }
        this.searchResults.start = page * this.searchResults.rows;

        // Show or hide the reset filters button
        this.toggleClearButton();

        // go to the page
        this.showPage(page);

        // don't want to follow links
        return false;
      },

      /*
       * After the search results have been returned,
       * check if any of them are derived data or have derivations
       */
      checkForProv() {
        let maps = [];
        let hasSources = [];
        let hasDerivations = [];
        const mainSearchResults = this.searchResults;

        // Get a list of all the resource map IDs from the SolrResults collection
        maps = this.searchResults.pluck("resourceMap");
        maps = _.compact(_.flatten(maps));

        // Create a new Search model with a search that finds all members of these packages/resource maps
        const provSearchModel = new SearchModel({
          formatType: [
            {
              value: "DATA",
              label: "data",
              description: null,
            },
          ],
          exclude: [],
          resourceMap: maps,
        });

        // Create a new Solr Results model to store the results of this supplemental query
        const provSearchResults = new SearchResults(null, {
          query: provSearchModel.getQuery(),
          searchLogs: false,
          usePOST: true,
          rows: 150,
          fields: `${provSearchModel.getProvFlList()},id,resourceMap`,
        });

        // Trigger a search on that Solr Results model
        this.listenTo(provSearchResults, "reset", (results) => {
          if (results.models.length == 0) return;

          // See if any of the results have a value for a prov field
          results.forEach((result) => {
            if (!result.getSources().length || !result.getDerivations()) return;
            _.each(result.get("resourceMap"), (rMapID) => {
              if (_.contains(maps, rMapID)) {
                const match = mainSearchResults.filter((mainSearchResult) =>
                  _.contains(mainSearchResult.get("resourceMap"), rMapID),
                );
                if (match &amp;&amp; match.length &amp;&amp; result.getSources().length > 0)
                  hasSources.push(match[0].get("id"));
                if (match &amp;&amp; match.length &amp;&amp; result.getDerivations().length > 0)
                  hasDerivations.push(match[0].get("id"));
              }
            });
          });

          // Filter out the duplicates
          hasSources = _.uniq(hasSources);
          hasDerivations = _.uniq(hasDerivations);

          // If they do, find their corresponding result row here and add
          // the prov icon (or just change the class to active)
          _.each(hasSources, (metadataID) => {
            const metadataDoc = mainSearchResults.findWhere({
              id: metadataID,
            });
            if (metadataDoc) {
              metadataDoc.set("prov_hasSources", true);
            }
          });
          _.each(hasDerivations, (metadataID) => {
            const metadataDoc = mainSearchResults.findWhere({
              id: metadataID,
            });
            if (metadataDoc) {
              metadataDoc.set("prov_hasDerivations", true);
            }
          });
        });
        provSearchResults.toPage(0);
      },

      cacheSearch() {
        MetacatUI.appModel.get("searchHistory").push({
          search: this.searchModel.clone(),
          map: this.mapModel ? this.mapModel.clone() : null,
        });
        MetacatUI.appModel.trigger("change:searchHistory");
      },

      /*
       * ==================================================================================================
       *                                             FILTERS
       * ==================================================================================================
       */
      updateCheckboxFilter(e, category, value) {
        if (!this.filters) return;

        const checkbox = e.target;
        const checked = $(checkbox).prop("checked");

        if (typeof category === "undefined")
          var category = $(checkbox).attr("data-category");
        if (typeof value === "undefined") var value = $(checkbox).attr("value");

        // If the user just unchecked the box, then remove this filter
        if (!checked) {
          this.searchModel.removeFromModel(category, value);
          this.hideFilter(category, value);
        }
        // If the user just checked the box, then add this filter
        else {
          const currentValue = this.searchModel.get(category);

          // Get the description
          let desc =
            $(checkbox).attr("data-description") || $(checkbox).attr("title");
          if (typeof desc === "undefined" || !desc) desc = "";
          // Get the label
          let labl = $(checkbox).attr("data-label");
          if (typeof labl === "undefined" || !labl) labl = "";

          // Make the filter object
          const filter = {
            description: desc,
            label: labl,
            value,
          };

          // If this filter category is an array, add this value to the array
          if (Array.isArray(currentValue)) {
            currentValue.push(filter);
            this.searchModel.set(category, currentValue);
            this.searchModel.trigger(`change:${category}`);
          } else {
            // If it isn't an array, then just update the model with a simple value
            this.searchModel.set(category, filter);
          }

          // Show the filter element
          this.showFilter(category, value, true, labl);

          // Show the reset button
          this.showClearButton();
        }

        // Route to page 1
        this.updatePageNumber(0);

        // Trigger a new search
        this.triggerSearch();
      },

      updateBooleanFilters(e) {
        if (!this.filters) return;

        // Get the category
        const checkbox = e.target;
        const category = $(checkbox).attr("data-category");
        const currentValue = this.searchModel.get(category);

        // If this filter is not enabled, exit this function
        if (
          !_.contains(MetacatUI.appModel.get("defaultSearchFilters"), category)
        ) {
          return false;
        }

        // The year filter is handled in a different way
        if (category == "pubYear" || category == "dataYear") return;

        // If the checkbox has a value, then update as a string value not boolean
        let value = $(checkbox).attr("value");
        if (value) {
          this.updateCheckboxFilter(e, category, value);
          return;
        }
        value = $(checkbox).prop("checked");

        this.searchModel.set(category, value);

        // Add the filter to the UI
        if (value) {
          this.showFilter(category, "", true);
        } else {
          // Remove the filter from the UI
          value = "";
          this.hideFilter(category, value);
        }

        // Show the reset button
        this.showClearButton();

        // Route to page 1
        this.updatePageNumber(0);

        // Trigger a new search
        this.triggerSearch();

        // Track this event
        MetacatUI.analytics?.trackEvent("search", `filter, ${category}`, value);
      },

      // Update the UI year slider and input values
      // Also update the model
      updateYearRange(e) {
        if (!this.filters) return;

        const viewRef = this;
        const userAction = !(typeof e === "undefined");
        const model = this.searchModel;
        const pubYearChecked = $("#publish_year").prop("checked");
        const dataYearChecked = $("#data_year").prop("checked");

        // If the year range slider has not been created yet
        if (!userAction &amp;&amp; !$("#year-range").hasClass("ui-slider")) {
          var defaultMin =
            typeof this.searchModel.defaults === "function"
              ? this.searchModel.defaults().yearMin
              : 1800;
          var defaultMax =
            typeof this.searchModel.defaults === "function"
              ? this.searchModel.defaults().yearMax
              : new Date().getUTCFullYear();

          // jQueryUI slider
          $("#year-range").slider({
            range: true,
            disabled: false,
            min: defaultMin, // sets the minimum on the UI slider on initialization
            max: defaultMax, // sets the maximum on the UI slider on initialization
            values: [
              this.searchModel.get("yearMin"),
              this.searchModel.get("yearMax"),
            ], // where the left and right slider handles are
            stop(event, ui) {
              // When the slider is changed, update the input values
              $("#min_year").val(ui.values[0]);
              $("#max_year").val(ui.values[1]);

              // Also update the search model
              model.set("yearMin", ui.values[0]);
              model.set("yearMax", ui.values[1]);

              // If neither the publish year or data coverage year are checked
              if (
                !$("#publish_year").prop("checked") &amp;&amp;
                !$("#data_year").prop("checked")
              ) {
                // We want to check the data coverage year on the user's behalf
                $("#data_year").prop("checked", "true");

                // And update the search model
                model.set("dataYear", true);
              }

              // Add the filter elements
              if ($("#publish_year").prop("checked")) {
                viewRef.showFilter(
                  $("#publish_year").attr("data-category"),
                  true,
                  false,
                  `${ui.values[0]} to ${ui.values[1]}`,
                  {
                    replace: true,
                  },
                );
              }
              if ($("#data_year").prop("checked")) {
                viewRef.showFilter(
                  $("#data_year").attr("data-category"),
                  true,
                  false,
                  `${ui.values[0]} to ${ui.values[1]}`,
                  {
                    replace: true,
                  },
                );
              }

              // Route to page 1
              viewRef.updatePageNumber(0);

              // Trigger a new search
              viewRef.triggerSearch();
            },
          });

          // Get the minimum and maximum years of this current search and use those as the min and max values in the slider
          this.statsModel.set("query", this.searchModel.getQuery());
          this.listenTo(this.statsModel, "change:firstBeginDate", function () {
            if (
              this.statsModel.get("firstBeginDate") == 0 ||
              !this.statsModel.get("firstBeginDate")
            ) {
              $("#year-range").slider({
                min: defaultMin,
              });
              return;
            }
            const year = new Date(
              this.statsModel.get("firstBeginDate"),
            ).getUTCFullYear();
            if (typeof year !== "undefined") {
              $("#min_year").val(year);
              $("#year-range").slider({
                values: [year, $("#max_year").val()],
              });

              // If the slider min is still at the default value, then update with the min value found at this search
              if ($("#year-range").slider("option", "min") == defaultMin) {
                $("#year-range").slider({
                  min: year,
                });
              }

              // Add the filter elements if this is set
              if (viewRef.searchModel.get("pubYear")) {
                viewRef.showFilter(
                  "pubYear",
                  true,
                  false,
                  `${$("#min_year").val()} to ${$("#max_year").val()}`,
                  {
                    replace: true,
                  },
                );
              }
              if (viewRef.searchModel.get("dataYear")) {
                viewRef.showFilter(
                  "dataYear",
                  true,
                  false,
                  `${$("#min_year").val()} to ${$("#max_year").val()}`,
                  {
                    replace: true,
                  },
                );
              }
            }
          });
          // Only when the first begin date is retrieved, set the slider min and max values
          this.listenTo(this.statsModel, "change:lastEndDate", function () {
            if (
              this.statsModel.get("lastEndDate") == 0 ||
              !this.statsModel.get("lastEndDate")
            ) {
              $("#year-range").slider({
                max: defaultMax,
              });
              return;
            }
            const year = new Date(
              this.statsModel.get("lastEndDate"),
            ).getUTCFullYear();
            if (typeof year !== "undefined") {
              $("#max_year").val(year);
              $("#year-range").slider({
                values: [$("#min_year").val(), year],
              });

              // If the slider max is still at the default value, then update with the max value found at this search
              if ($("#year-range").slider("option", "max") == defaultMax) {
                $("#year-range").slider({
                  max: year,
                });
              }

              // Add the filter elements if this is set
              if (viewRef.searchModel.get("pubYear")) {
                viewRef.showFilter(
                  "pubYear",
                  true,
                  false,
                  `${$("#min_year").val()} to ${$("#max_year").val()}`,
                  {
                    replace: true,
                  },
                );
              }
              if (viewRef.searchModel.get("dataYear")) {
                viewRef.showFilter(
                  "dataYear",
                  true,
                  false,
                  `${$("#min_year").val()} to ${$("#max_year").val()}`,
                  {
                    replace: true,
                  },
                );
              }
            }
          });
          this.statsModel.getFirstBeginDate();
          this.statsModel.getLastEndDate();
        }
        // If the year slider has been created and the user initiated a new search using other filters
        else if (
          !userAction &amp;&amp;
          !this.searchModel.get("dataYear") &amp;&amp;
          !this.searchModel.get("pubYear")
        ) {
          // Reset the min and max year based on this search
          this.statsModel.set("query", this.searchModel.getQuery());
          this.statsModel.getFirstBeginDate();
          this.statsModel.getLastEndDate();
        }
        // If either of the year type selectors is what brought us here, then determine whether the user
        // is completely removing both (reset both year filters) or just one (remove just that one filter)
        else if (userAction) {
          // When both year types were unchecked, assume user wants to reset the year filter
          if (
            ($(e.target).attr("id") == "data_year" ||
              $(e.target).attr("id") == "publish_year") &amp;&amp;
            !pubYearChecked &amp;&amp;
            !dataYearChecked
          ) {
            // Reset the search model
            this.searchModel.set("yearMin", defaultMin);
            this.searchModel.set("yearMax", defaultMax);
            this.searchModel.set("dataYear", false);
            this.searchModel.set("pubYear", false);

            // Reset the min and max year based on this search
            this.statsModel.set("query", this.searchModel.getQuery());
            this.statsModel.getFirstBeginDate();
            this.statsModel.getLastEndDate();

            // Slide the handles back to the defaults
            $("#year-range").slider("values", [defaultMin, defaultMax]);

            // Hide the filters
            this.hideFilter("dataYear");
            this.hideFilter("pubYear");
          }
          // If either of the year inputs have changed or if just one of the year types were unchecked
          else {
            const minVal = $("#min_year").val();
            const maxVal = $("#max_year").val();

            // Update the search model to match what is in the text inputs
            this.searchModel.set("yearMin", minVal);
            this.searchModel.set("yearMax", maxVal);
            this.searchModel.set("dataYear", dataYearChecked);
            this.searchModel.set("pubYear", pubYearChecked);

            // If neither the publish year or data coverage year are checked
            if (!pubYearChecked &amp;&amp; !dataYearChecked) {
              // We want to check the data coverage year on the user's behalf
              $("#data_year").prop("checked", "true");

              // And update the search model
              model.set("dataYear", true);

              // Add the filter elements
              this.showFilter(
                $("#data_year").attr("data-category"),
                true,
                true,
                `${minVal} to ${maxVal}`,
                {
                  replace: true,
                },
              );

              // Track this event
              MetacatUI.analytics?.trackEvent(
                "search",
                "filter, Data Year",
                `${minVal} to ${maxVal}`,
              );
            } else {
              // Add the filter elements
              if (pubYearChecked) {
                this.showFilter(
                  $("#publish_year").attr("data-category"),
                  true,
                  true,
                  `${minVal} to ${maxVal}`,
                  {
                    replace: true,
                  },
                );

                // Track this event
                MetacatUI.analytics?.trackEvent(
                  "search",
                  "filter, Publication Year",
                  `${minVal} to ${maxVal}`,
                );
              } else {
                this.hideFilter($("#publish_year").attr("data-category"), true);
              }

              if (dataYearChecked) {
                this.showFilter(
                  $("#data_year").attr("data-category"),
                  true,
                  true,
                  `${minVal} to ${maxVal}`,
                  {
                    replace: true,
                  },
                );

                // Track this event
                MetacatUI.analytics?.trackEvent(
                  "search",
                  "filter, Data Year",
                  `${minVal} to ${maxVal}`,
                );
              } else {
                this.hideFilter($("#data_year").attr("data-category"), true);
              }
            }
          }

          // Route to page 1
          this.updatePageNumber(0);

          // Trigger a new search
          this.triggerSearch();
        }
      },

      updateTextFilters(e, item) {
        if (!this.filters) return;

        // Get the search/filter category
        let category = $(e.target).attr("data-category");

        // Try the parent elements if not found
        if (!category) {
          const parents = $(e.target)
            .parents()
            .each(function () {
              category = $(this).attr("data-category");
              if (category) {
                return false;
              }
            });
        }

        if (!category) {
          return false;
        }

        // Get the input element
        const input = this.$el.find(`#${category}_input`);

        // Get the value of the associated input
        const term = !item || !item.value ? input.val() : item.value;
        const label = !item || !item.filterLabel ? null : item.filterLabel;
        const filterDesc = !item || !item.desc ? null : item.desc;

        // Check that something was actually entered
        if (term == "" || term == " ") {
          return false;
        }

        // Close the autocomplete box
        if (e.type == "hoverautocompleteselect") {
          $(input).hoverAutocomplete("close");
        } else if ($(input).data("ui-autocomplete") != undefined) {
          // If the autocomplete has been initialized, then close it
          $(input).autocomplete("close");
        }

        // Get the current searchModel array for this category
        const filtersArray = _.clone(this.searchModel.get(category));

        if (typeof filtersArray === "undefined") {
          console.error(
            `The filter category '${category}' does not exist in the Search model. Not sending this search term.`,
          );
          return false;
        }

        // Check if this entry is a duplicate
        const duplicate = (function () {
          for (let i = 0; i &lt; filtersArray.length; i++) {
            if (filtersArray[i].value === term) {
              return true;
            }
          }
        })();

        if (duplicate) {
          // Display a quick message
          if ($(`#duplicate-${category}-alert`).length &lt;= 0) {
            $(`#current-${category}-filters`).prepend(
              "&lt;div class='alert alert-block' id='duplicate-' + category + '-alert'>" +
                "You are already using that filter" +
                "&lt;/div>",
            );

            $(`#duplicate-${category}-alert`)
              .delay(2000)
              .fadeOut(500, function () {
                this.remove();
              });
          }

          return false;
        }

        // Add the new entry to the array of current filters
        const filter = {
          value: term,
          filterLabel: label,
          label,
          description: filterDesc,
        };
        filtersArray.push(filter);

        // Replace the current array with the new one in the search model
        this.searchModel.set(category, filtersArray);

        // Show the UI filter
        this.showFilter(category, filter, false, label);

        // Clear the input
        input.val("");

        // Route to page 1
        this.updatePageNumber(0);

        // Trigger a new search
        this.triggerSearch();

        // Track this event
        MetacatUI.analytics?.trackEvent("search", `filter, ${category}`, term);
      },

      // Removes a specific filter term from the searchModel
      removeFilter(e) {
        // Get the parent element that stores the filter term
        const filterNode = $(e.target).parent();

        // Find this filter's category and value
        const category =
          filterNode.attr("data-category") ||
          filterNode.parent().attr("data-category");
        const value = $(filterNode).attr("data-term");

        // Remove this filter from the searchModel
        this.searchModel.removeFromModel(category, value);

        // Hide the filter from the UI
        this.hideFilter(category, value);

        // If there is an associated checkbox with this filter, uncheck it
        let assocCheckbox;
        const checkboxes = this.$(
          `input[type='checkbox'][data-category='${category}']`,
        );

        // If there are more than one checkboxes in this category, match by value
        if (checkboxes.length > 1) {
          assocCheckbox = _.find(
            checkboxes,
            (checkbox) => $(checkbox).val() == value,
          );
        }
        // If there is only one checkbox in this category, default to it
        else if (checkboxes.length == 1) {
          assocCheckbox = checkboxes[0];
        }

        // If there is an associated checkbox, uncheck it
        if (assocCheckbox) {
          // Uncheck it
          $(assocCheckbox).prop("checked", false);
        }

        // Route to page 1
        this.updatePageNumber(0);

        // Trigger a new search
        this.triggerSearch();
      },

      // Clear all the currently applied filters
      resetFilters() {
        const viewRef = this;

        this.allowSearch = true;

        // Hide all the filters in the UI
        $.each(this.$(".current-filter"), function () {
          viewRef.hideEl(this);
        });

        // Hide the clear button
        this.hideClearButton();

        // Then reset the model
        this.searchModel.clear();

        // Reset the map model
        if (this.mapModel) {
          this.mapModel.clear();
        }

        // Reset the year slider handles
        $("#year-range").slider("values", [
          this.searchModel.get("yearMin"),
          this.searchModel.get("yearMax"),
        ]);
        // and the year inputs
        $("#min_year").val(this.searchModel.get("yearMin"));
        $("#max_year").val(this.searchModel.get("yearMax"));

        // Reset the checkboxes
        $("#includes_data").prop("checked", this.searchModel.get("documents"));
        $("#data_year").prop("checked", this.searchModel.get("dataYear"));
        $("#publish_year").prop("checked", this.searchModel.get("pubYear"));
        $("#is_private_data").prop(
          "checked",
          this.searchModel.get("isPrivate"),
        );
        this.listDataSources();

        // Zoom out the Google Map
        this.resetMap();
        this.renderMap();

        // Route to page 1
        this.updatePageNumber(0);

        // Trigger a new search
        this.triggerSearch();
      },

      hideEl(element) {
        // Fade out and remove the element
        $(element).fadeOut("slow", () => {
          $(element).remove();
        });
      },

      // Removes a specified filter node from the DOM
      hideFilter(category, value) {
        if (!this.filters) return;

        if (typeof value === "undefined") {
          var filterNode = this.$(
            `.current-filters[data-category='${category}']`,
          ).children(".current-filter");
        } else {
          var filterNode = this.$(
            `.current-filters[data-category='${category}']`,
          ).children(`[data-term='${value}']`);
        }

        // Try finding it a different way
        if (!filterNode || !filterNode.length) {
          filterNode = this.$(`.current-filter[data-category='${category}']`);
        }

        // Remove the filter node from the DOM
        this.hideEl(filterNode);
      },

      // Adds a specified filter node to the DOM
      showFilter(category, term, checkForDuplicates, label, options) {
        if (!this.filters) return;

        const viewRef = this;

        if (typeof term === "undefined") return false;

        // Get the element to add the UI filter node to
        // The pattern is #current-&lt;category>-filters
        const filterContainer = this.$el.find(`#current-${category}-filters`);

        // Allow the option to only display this exact filter category and term once to the DOM
        // Helpful when adding a filter that is not stored in the search model (for display only)
        if (checkForDuplicates) {
          let duplicate = false;

          // Get the current terms from the DOM and check against the new term
          filterContainer.children().each(function () {
            if ($(this).attr("data-term") == term) {
              duplicate = true;
            }
          });

          // If there is a duplicate, exit without adding it
          if (duplicate) {
            return;
          }
        }

        let value = null;
        let desc = null;

        // See if this filter is an object and extract the filter attributes
        if (typeof term === "object") {
          if (typeof term.description !== "undefined") {
            desc = term.description;
          }
          if (typeof term.filterLabel !== "undefined") {
            label = term.filterLabel;
          } else if (typeof term.label !== "undefined" &amp;&amp; term.label) {
            label = term.label;
          } else {
            label = null;
          }
          if (typeof term.value !== "undefined") {
            value = term.value;
          }
        } else {
          value = term;

          // Find the filter label
          if (typeof label === "undefined" || !label) {
            // Use the filter value for the label, sans any leading # character
            if (value.indexOf("#") > 0) {
              label = value.substring(value.indexOf("#"));
            }
          }

          desc = label;
        }

        let categoryLabel = this.searchModel.fieldLabels[category];
        if (
          typeof categoryLabel === "undefined" &amp;&amp;
          category == "additionalCriteria"
        )
          categoryLabel = "";
        if (typeof categoryLabel === "undefined") categoryLabel = category;

        // Add a filter node to the DOM
        const filterEl = viewRef.currentFilterTemplate({
          category: Utilities.encodeHTML(categoryLabel),
          value: Utilities.encodeHTML(value),
          label: Utilities.encodeHTML(label),
          description: Utilities.encodeHTML(desc),
        });

        // Add the filter to the page - either replace or tack on
        if (options &amp;&amp; options.replace) {
          const currentFilter = filterContainer.find(".current-filter");
          if (currentFilter.length > 0) {
            currentFilter.replaceWith(filterEl);
          } else {
            filterContainer.prepend(filterEl);
          }
        } else {
          filterContainer.prepend(filterEl);
        }

        // Tooltips and Popovers
        $(filterEl).tooltip({
          delay: {
            show: 800,
          },
        });
      },

      /*
       * Get the member node list from the model and list the members in the filter list
       */
      listDataSources() {
        if (!this.filters) return;

        if (MetacatUI.nodeModel.get("members").length &lt; 1) return;

        // Get the member nodes
        const members = _.sortBy(MetacatUI.nodeModel.get("members"), (m) => {
          if (m.name) {
            return m.name.toLowerCase();
          }
          return "";
        });
        const filteredMembers = _.reject(
          members,
          (m) => m.status != "operational",
        );

        // Get the current search filters for data source
        const currentFilters = this.searchModel.get("dataSource");

        // Create an HTML list
        const listMax = 4;
        const numHidden = filteredMembers.length - listMax;
        const list = $(document.createElement("ul")).addClass("checkbox-list");

        // Add a checkbox and label for each member node in the node model
        _.each(filteredMembers, (member, i) => {
          const listItem = document.createElement("li");
          const input = document.createElement("input");
          const label = document.createElement("label");

          // If this member node is already a data source filter, then the checkbox is checked
          const checked = !!_.findWhere(currentFilters, {
            value: member.identifier,
          });

          // Create a textual label for this data source
          $(label)
            .addClass("ellipsis")
            .attr("for", member.identifier)
            .html(member.name);

          // Create a checkbox for this data source
          $(input)
            .addClass("filter")
            .attr("type", "checkbox")
            .attr("data-category", "dataSource")
            .attr("id", member.identifier)
            .attr("name", "dataSource")
            .attr("value", member.identifier)
            .attr("data-label", member.name)
            .attr("data-description", member.description);

          // Add tooltips to the label element
          $(label).tooltip({
            placement: "top",
            delay: {
              show: 900,
            },
            trigger: "hover",
            viewport: "#sidebar",
            title: member.description,
          });

          // If this data source is already selected as a filter (from the search model), then check the checkbox
          if (checked) $(input).prop("checked", "checked");

          // Collapse some of the checkboxes and labels after a certain amount
          if (i > listMax - 1) {
            $(listItem).addClass("hidden");
          }

          // Insert a "More" link after a certain amount to enable users to expand the list
          if (i == listMax) {
            const moreLink = document.createElement("a");
            $(moreLink)
              .html(`Show ${numHidden} more`)
              .addClass("more-link pointer toggle-list")
              .append(
                $(document.createElement("i")).addClass("icon icon-expand-alt"),
              );
            $(list).append(moreLink);
          }

          // Add this checkbox and laebl to the list
          $(listItem).append(input).append(label);
          $(list).append(listItem);
        });

        if (numHidden > 0) {
          const lessLink = document.createElement("a");
          $(lessLink)
            .html("Collapse member nodes")
            .addClass("less-link toggle-list pointer hidden")
            .append(
              $(document.createElement("i")).addClass("icon icon-collapse-alt"),
            );

          $(list).append(lessLink);
        }

        // Add the list of checkboxes to the placeholder
        const container = $(".member-nodes-placeholder");
        $(container).html(list);
        $(".tooltip-this").tooltip();
      },

      resetDataSourceList() {
        if (!this.filters) return;

        // Reset the Member Nodes checkboxes
        const mnFilterContainer = $("#member-nodes-container");
        const defaultMNs = this.searchModel.get("dataSource");

        // Make sure the member node filter exists
        if (!mnFilterContainer || mnFilterContainer.length == 0) return false;
        if (typeof defaultMNs === "undefined" || !defaultMNs) return false;

        // Reset each member node checkbox
        const boxes = $(mnFilterContainer)
          .find(".filter")
          .prop("checked", false);

        // Check the member node checkboxes that are defaults in the search model
        _.each(defaultMNs, (member, i) => {
          let value = null;

          // Allow for string search model filter values and object filter values
          if (typeof member !== "object" &amp;&amp; member) value = member;
          else if (typeof member.value === "undefined" || !member.value)
            value = "";
          else value = member.value;

          $(mnFilterContainer)
            .find(`checkbox[value='${value}']`)
            .prop("checked", true);
        });

        return true;
      },

      toggleList(e) {
        if (!this.filters) return;

        const link = e.target;
        const controls = $(link).parents("ul").find(".toggle-list");
        const list = $(link).parents("ul");
        const isHidden = !list.find(".more-link").is(".hidden");

        // Hide/Show the list
        if (isHidden) {
          list.children("li").slideDown();
        } else {
          list.children("li.hidden").slideUp();
        }

        // Hide/Show the control links
        controls.toggleClass("hidden");
      },

      // add additional criteria to the search model based on link click
      additionalCriteria(e) {
        // Get the clicked node
        const targetNode = $(e.target);

        // If this additional criteria is already applied, remove it
        if (targetNode.hasClass("active")) {
          this.removeAdditionalCriteria(e);
          return false;
        }

        // Get the filter criteria
        const term = targetNode.attr("data-term");

        // Find this element's category in the data-category attribute
        const category = targetNode.attr("data-category");

        // style the selection
        $(".keyword-search-link").removeClass("active");
        $(".keyword-search-link").parent().removeClass("active");
        targetNode.addClass("active");
        targetNode.parent().addClass("active");

        // Add this criteria to the search model
        this.searchModel.set(category, [term]);

        // Trigger the search
        this.triggerSearch();

        // prevent default action of click
        return false;
      },

      removeAdditionalCriteria(e) {
        // Get the clicked node
        const targetNode = $(e.target);

        // Reference to model
        const model = this.searchModel;

        // remove the styling
        $(".keyword-search-link").removeClass("active");
        $(".keyword-search-link").parent().removeClass("active");

        // Get the term
        const term = targetNode.attr("data-term");

        // Get the current search model additional criteria
        const current = this.searchModel.get("additionalCriteria");
        // If this term is in the current search model (should be)...
        if (_.contains(current, term)) {
          // then remove it
          const newTerms = _.without(current, term);
          model.set("additionalCriteria", newTerms);
        }

        // Route to page 1
        this.updatePageNumber(0);

        // Trigger a new search
        this.triggerSearch();
      },

      // Get the facet counts
      getAutocompletes(e) {
        if (!e) return;

        // Get the text input to determine the filter type
        const input = $(e.target);
        const category = input.attr("data-category");

        if (!this.filters || !category) return;

        const viewRef = this;

        // Create the facet query by using our current search query
        const facetQuery = `q=${
          this.searchResults.currentquery
        }&amp;rows=0${this.searchModel.getFacetQuery(category)}&amp;wt=json&amp;`;

        // If we've cached these filter results, then use the cache instead of sending a new request
        if (!MetacatUI.appSearchModel.autocompleteCache)
          MetacatUI.appSearchModel.autocompleteCache = {};
        else if (MetacatUI.appSearchModel.autocompleteCache[facetQuery]) {
          this.setupAutocomplete(
            input,
            MetacatUI.appSearchModel.autocompleteCache[facetQuery],
          );
          return;
        }

        // Get the facet counts for the autocomplete
        const requestSettings = {
          url: MetacatUI.appModel.get("queryServiceUrl") + facetQuery,
          type: "GET",
          dataType: "json",
          success(data, textStatus, xhr) {
            let suggestions = [];
            const facetLimit = 999;

            // Get all the facet counts
            _.each(category.split(","), (c) => {
              if (typeof c === "string") c = [c];
              _.each(c, (thisCategory) => {
                // Get the field name(s)
                let fieldNames =
                  MetacatUI.appSearchModel.facetNameMap[thisCategory];
                if (typeof fieldNames === "string") fieldNames = [fieldNames];

                // Get the facet counts
                _.each(fieldNames, (fieldName) => {
                  suggestions.push(data.facet_counts.facet_fields[fieldName]);
                });
              });
            });
            suggestions = _.flatten(suggestions);

            // Format the suggestions
            const rankedSuggestions = new Array();
            for (
              let i = 0;
              i &lt; Math.min(suggestions.length - 1, facetLimit);
              i += 2
            ) {
              // The label is the item value
              let label = suggestions[i];

              // For all categories except the 'all' category, display the facet count
              if (category != "all") {
                label += ` (${suggestions[i + 1]})`;
              }

              // Push the autocomplete item to the array
              rankedSuggestions.push({
                value: suggestions[i],
                label,
              });
            }

            // Save these facets in the app so we don't have to send another query
            MetacatUI.appSearchModel.autocompleteCache[facetQuery] =
              rankedSuggestions;

            // Now setup the actual autocomplete menu
            viewRef.setupAutocomplete(input, rankedSuggestions);
          },
        };
        $.ajax(
          _.extend(
            requestSettings,
            MetacatUI.appUserModel.createAjaxSettings(),
          ),
        );
      },

      setupAutocomplete(input, rankedSuggestions) {
        const viewRef = this;

        // Override the _renderItem() function which renders a single autocomplete item.
        // We want to use the 'title' HTML attribute on each item.
        // This method must create a new &lt;li> element, append it to the menu, and return it.
        $.widget("custom.autocomplete", $.ui.autocomplete, {
          _renderItem(ul, item) {
            return $(document.createElement("li"))
              .attr("title", item.label)
              .append(item.label)
              .appendTo(ul);
          },
        });
        input.autocomplete({
          source(request, response) {
            const term = $.ui.autocomplete.escapeRegex(request.term);
            const startsWithMatcher = new RegExp(`^${term}`, "i");
            const startsWith = $.grep(rankedSuggestions, (value) =>
              startsWithMatcher.test(value.label || value.value || value),
            );
            const containsMatcher = new RegExp(term, "i");
            const contains = $.grep(
              rankedSuggestions,
              (value) =>
                $.inArray(value, startsWith) &lt; 0 &amp;&amp;
                containsMatcher.test(value.label || value.value || value),
            );

            response(startsWith.concat(contains));
          },
          select(event, ui) {
            // set the text field
            input.val(ui.item.value);
            // add to the filter immediately
            viewRef.updateTextFilters(event, ui.item);
            // prevent default action
            return false;
          },
          position: {
            my: "left top",
            at: "left bottom",
            collision: "flipfit",
          },
        });
      },

      hideClearButton() {
        if (!this.filters) return;

        // Hide the current filters panel
        this.$(".current-filters-container").slideUp();

        // Hide the reset button
        $("#clear-all").addClass("hidden");
        this.setAutoHeight();
      },

      showClearButton() {
        if (!this.filters) return;

        // Show the current filters panel
        if (
          _.difference(
            this.searchModel.getCurrentFilters(),
            this.searchModel.spatialFilters,
          ).length > 0
        ) {
          this.$(".current-filters-container").slideDown();
        }

        // Show the reset button
        $("#clear-all").removeClass("hidden");
        this.setAutoHeight();
      },

      /*
       * ==================================================================================================
       *                                             NAVIGATING THE UI
       * ==================================================================================================
       */
      // Update all the statistics throughout the page
      updateStats() {
        if (this.searchResults.header != null) {
          this.$statcounts = this.$("#statcounts");
          this.$statcounts.html(
            this.statsTemplate({
              start: this.searchResults.header.get("start") + 1,
              end:
                this.searchResults.header.get("start") +
                this.searchResults.length,
              numFound: this.searchResults.header.get("numFound"),
            }),
          );
        }

        // piggy back here
        this.updatePager();
      },

      updatePager() {
        if (this.searchResults.header != null) {
          const pageCount = Math.ceil(
            this.searchResults.header.get("numFound") /
              this.searchResults.header.get("rows"),
          );

          // If no results were found, display a message instead of the list and clear the pagination.
          if (pageCount == 0) {
            this.$results.html(
              "&lt;p id='no-results-found'>No results found.&lt;/p>",
            );

            this.$("#resultspager").html("");
            this.$(".resultspager").html("");
          }
          // Do not display the pagination if there is only one page
          else if (pageCount == 1) {
            this.$("#resultspager").html("");
            this.$(".resultspager").html("");
          } else {
            const pages = new Array(pageCount);

            // mark current page correctly, avoid NaN
            let currentPage = -1;
            try {
              currentPage = Math.floor(
                (this.searchResults.header.get("start") /
                  this.searchResults.header.get("numFound")) *
                  pageCount,
              );
            } catch (ex) {
              console.log(`Exception when calculating pages:${ex.message}`);
            }

            // Populate the pagination element in the UI
            this.$(".resultspager").html(
              this.pagerTemplate({
                pages,
                currentPage,
              }),
            );
            this.$("#resultspager").html(
              this.pagerTemplate({
                pages,
                currentPage,
              }),
            );
          }
        }
      },

      updatePageNumber(page) {
        MetacatUI.appModel.set("page", page);

        if (!this.isSubView) {
          let route = Backbone.history.fragment;
          const subroutePos = route.indexOf("/page/");
          const newPage = parseInt(page) + 1;

          // replace the last number with the new one
          if (page > 0 &amp;&amp; subroutePos > -1) {
            route = route.replace(/\d+$/, newPage);
          } else if (page > 0) {
            route += `/page/${newPage}`;
          } else if (subroutePos >= 0) {
            route = route.substring(0, subroutePos);
          }

          MetacatUI.uiRouter.navigate(route);
        }
      },

      // Next page of results
      nextpage() {
        this.loading();
        this.searchResults.nextpage();
        this.$resultsview.show();
        this.updateStats();

        let page = MetacatUI.appModel.get("page");
        page++;
        this.updatePageNumber(page);
      },

      // Previous page of results
      prevpage() {
        this.loading();
        this.searchResults.prevpage();
        this.$resultsview.show();
        this.updateStats();

        let page = MetacatUI.appModel.get("page");
        page--;
        this.updatePageNumber(page);
      },

      navigateToPage(event) {
        const page = $(event.target).attr("page");
        this.showPage(page);
      },

      showPage(page) {
        this.loading();
        this.searchResults.toPage(page);
        this.$resultsview.show();
        this.updateStats();
        this.updatePageNumber(page);
        this.updateYearRange();
      },

      /*
       * ==================================================================================================
       *                                             THE MAP
       * ==================================================================================================
       */
      renderMap() {
        // If gmaps isn't enabled or loaded with an error, use list mode
        if (!gmaps || this.mode == "list") {
          this.ready = true;
          this.mode = "list";
          return;
        }

        if (this.isSubView) {
          this.$el.addClass("mapMode");
        } else {
          $("body").addClass("mapMode");
        }

        // Get the map options and create the map
        gmaps.visualRefresh = true;
        const mapOptions = this.mapModel.get("mapOptions");
        const defaultZoom = mapOptions.zoom;
        $("#map-container").append("&lt;div id='map-canvas'>&lt;/div>");
        this.map = new gmaps.Map($("#map-canvas")[0], mapOptions);
        this.mapModel.set("map", this.map);
        this.hasZoomed = false;
        this.hasDragged = false;

        // Hide the map filter toggle element
        this.$(this.mapFilterToggle).hide();

        // Store references
        const mapRef = this.map;
        const viewRef = this;

        google.maps.event.addListener(mapRef, "zoom_changed", () => {
          // If the map is zoomed in further than the default zoom level,
          // than we want to mark the map as zoomed in
          if (viewRef.map.getZoom() > defaultZoom) {
            viewRef.hasZoomed = true;
          }
          // If we are at the default zoom level or higher, than do not mark the map
          // as zoomed in
          else {
            viewRef.hasZoomed = false;
          }
        });

        google.maps.event.addListener(mapRef, "dragend", () => {
          viewRef.hasDragged = true;
        });

        google.maps.event.addListener(mapRef, "idle", () => {
          // Remove all markers from the map
          for (let i = 0; i &lt; viewRef.resultMarkers.length; i++) {
            viewRef.resultMarkers[i].setMap(null);
          }
          viewRef.resultMarkers = new Array();

          // Check if the user has interacted with the map just now, and if so, we
          // want to alter the geohash filter (changing the geohash values or resetting it completely)
          const alterGeohashFilter =
            viewRef.allowSearch || viewRef.hasZoomed || viewRef.hasDragged;
          if (!alterGeohashFilter) {
            return;
          }

          // Determine if the map needs to be recentered. The map only needs to be
          // recentered if it is not at the default lat,long center point AND it
          // is not zoomed in or dragged to a new center point
          const setGeohashFilter =
            viewRef.hasZoomed &amp;&amp; viewRef.isMapFilterEnabled();

          // If we are using the geohash filter defined by this map, then
          // apply the filter and trigger a new search
          if (setGeohashFilter) {
            viewRef.$(viewRef.mapFilterToggle).show();

            // Get the Google map bounding box
            const boundingBox = mapRef.getBounds();

            // Set the search model spatial filters
            // Encode the Google Map bounding box into geohash
            const north = boundingBox.getNorthEast().lat();
            const west = boundingBox.getSouthWest().lng();
            const south = boundingBox.getSouthWest().lat();
            const east = boundingBox.getNorthEast().lng();

            viewRef.searchModel.set("north", north);
            viewRef.searchModel.set("west", west);
            viewRef.searchModel.set("south", south);
            viewRef.searchModel.set("east", east);

            // Save the center position and zoom level of the map
            viewRef.mapModel.get("mapOptions").center = mapRef.getCenter();
            viewRef.mapModel.get("mapOptions").zoom = mapRef.getZoom();

            // Determine the precision of geohashes to search for
            const zoom = mapRef.getZoom();

            const precision = viewRef.mapModel.getSearchPrecision(zoom);

            // Get all the geohash tiles contained in the map bounds
            const geohashBBoxes = nGeohash.bboxes(
              south,
              west,
              north,
              east,
              precision,
            );

            // Save our geohash search settings
            viewRef.searchModel.set("geohashes", geohashBBoxes);
            viewRef.searchModel.set("geohashLevel", precision);

            // Start back at page 0
            MetacatUI.appModel.set("page", 0);

            // Mark the view as ready to start a search
            viewRef.ready = true;

            // Trigger a new search
            viewRef.triggerSearch();

            viewRef.allowSearch = false;
          } else {
            // Reset the map filter
            viewRef.resetMap();

            // Start back at page 0
            MetacatUI.appModel.set("page", 0);

            // Mark the view as ready to start a search
            viewRef.ready = true;

            // Trigger a new search
            viewRef.triggerSearch();

            viewRef.allowSearch = false;
          }
        });
      },

      // Resets the model and view settings related to the map
      resetMap() {
        if (!gmaps) {
          return;
        }

        // First reset the model
        // The categories pertaining to the map
        const categories = ["east", "west", "north", "south"];

        // Loop through each and remove the filters from the model
        for (let i = 0; i &lt; categories.length; i++) {
          this.searchModel.set(categories[i], null);
        }

        // Reset the map settings
        this.searchModel.resetGeohash();
        this.mapModel.set("mapOptions", this.mapModel.defaults().mapOptions);

        this.allowSearch = false;
      },

      isMapFilterEnabled() {
        const toggleInput = this.$(`input${this.mapFilterToggle}`);
        if (typeof toggleInput === "undefined" || !toggleInput) return;

        return $(toggleInput).prop("checked");
      },

      toggleMapFilter(e, a) {
        const toggleInput = this.$(`input${this.mapFilterToggle}`);
        if (typeof toggleInput === "undefined" || !toggleInput) return;

        let isOn = $(toggleInput).prop("checked");

        // If the user clicked on the label, then change the checkbox for them
        if (e.target.tagName != "INPUT") {
          isOn = !isOn;
          toggleInput.prop("checked", isOn);
        }

        google.maps.event.trigger(this.mapModel.get("map"), "idle");

        // Track this event
        MetacatUI.analytics?.trackEvent("map", isOn ? "on" : "off");
      },

      /**
       * Show the marker, infoWindow, and bounding coordinates polygon on
             the map when the user hovers on the marker icon in the result list
       * @param {Event} e
       */
      showResultOnMap(e) {
        // Exit if maps are not in use
        if (this.mode != "map" || !gmaps) {
          return false;
        }

        // Get the attributes about this dataset
        let resultRow = e.target;
        let id = $(resultRow).attr("data-id");
        // The mouseover event might be triggered by a nested element, so loop through the parents to find the id
        if (typeof id === "undefined") {
          $(resultRow)
            .parents()
            .each(function () {
              if (typeof $(this).attr("data-id") !== "undefined") {
                id = $(this).attr("data-id");
                resultRow = this;
              }
            });
        }

        // Find the tile for this data set and highlight it on the map
        const resultGeohashes = this.searchResults
          .findWhere({
            id,
          })
          .get("geohash_9");
        for (let i = 0; i &lt; resultGeohashes.length; i++) {
          var thisGeohash = resultGeohashes[i];
          const latLong = nGeohash.decode(thisGeohash);
          const position = new google.maps.LatLng(
            latLong.latitude,
            latLong.longitude,
          );
          const containingTileGeohash = _.find(
            this.tileGeohashes,
            (g) => thisGeohash.indexOf(g) == 0,
          );
          const containingTile = _.findWhere(this.tiles, {
            geohash: containingTileGeohash,
          });

          // If this is a geohash for a georegion outside the map, do not highlight a tile or display a marker
          if (typeof containingTile === "undefined") continue;

          this.highlightTile(containingTile);

          // Set up the options for each marker
          const markerOptions = {
            position,
            icon: this.mapModel.get("markerImage"),
            zIndex: 99999,
            map: this.map,
          };

          // Create the marker and add to the map
          const marker = new google.maps.Marker(markerOptions);

          this.resultMarkers.push(marker);
        }
      },

      /**
       * Hide the marker, infoWindow, and bounding coordinates polygon on
             the map when the user stops hovering on the marker icon in the result list
       * @param {Event} e - The event that brought us to this function
       */
      hideResultOnMap(e) {
        // Exit if maps are not in use
        if (this.mode != "map" || !gmaps) {
          return false;
        }

        // Get the attributes about this dataset
        let resultRow = e.target;
        let id = $(resultRow).attr("data-id");
        // The mouseover event might be triggered by a nested element, so loop through the parents to find the id
        if (typeof id === "undefined") {
          $(e.target)
            .parents()
            .each(function () {
              if (typeof $(this).attr("data-id") !== "undefined") {
                id = $(this).attr("data-id");
                resultRow = this;
              }
            });
        }

        // Get the map tile for this result and un-highlight it
        const resultGeohashes = this.searchResults
          .findWhere({
            id,
          })
          .get("geohash_9");
        for (let i = 0; i &lt; resultGeohashes.length; i++) {
          var thisGeohash = resultGeohashes[i];
          const containingTileGeohash = _.find(
            this.tileGeohashes,
            (g) => thisGeohash.indexOf(g) == 0,
          );
          const containingTile = _.findWhere(this.tiles, {
            geohash: containingTileGeohash,
          });

          // If this is a geohash for a georegion outside the map, do not unhighlight a tile
          if (typeof containingTile === "undefined") continue;

          // Unhighlight the tile
          this.unhighlightTile(containingTile);
        }

        // Remove all markers from the map
        _.each(this.resultMarkers, (marker) => {
          marker.setMap(null);
        });
        this.resultMarkers = new Array();
      },

      /**
       * Create a tile for each geohash facet. A separate tile label is added to the map with the count of the facet.
       */
      drawTiles() {
        // Exit if maps are not in use
        if (this.mode != "map" || !gmaps) {
          return false;
        }

        TextOverlay.prototype = new google.maps.OverlayView();

        /**
         *
         * @param options
         */
        function TextOverlay(options) {
          // Now initialize all properties.
          this.bounds_ = options.bounds;
          this.map_ = options.map;
          this.text = options.text;
          this.color = options.color;

          const { length } = options.text.toString();
          if (length == 1) this.width = 8;
          else if (length == 2) this.width = 17;
          else if (length == 3) this.width = 25;
          else if (length == 4) this.width = 32;
          else if (length == 5) this.width = 40;

          // We define a property to hold the image's div. We'll
          // actually create this div upon receipt of the onAdd()
          // method so we'll leave it null for now.
          this.div_ = null;

          // Explicitly call setMap on this overlay
          this.setMap(options.map);
        }

        TextOverlay.prototype.onAdd = function () {
          // Create the DIV and set some basic attributes.
          const div = document.createElement("div");
          div.style.color = this.color;
          div.style.fontSize = "15px";
          div.style.position = "absolute";
          div.style.zIndex = "999";
          div.style.fontWeight = "bold";

          // Create an IMG element and attach it to the DIV.
          div.innerHTML = this.text;

          // Set the overlay's div_ property to this DIV
          this.div_ = div;

          // We add an overlay to a map via one of the map's panes.
          // We'll add this overlay to the overlayLayer pane.
          const panes = this.getPanes();
          panes.overlayLayer.appendChild(div);
        };

        TextOverlay.prototype.draw = function () {
          // Size and position the overlay. We use a southwest and northeast
          // position of the overlay to peg it to the correct position and size.
          // We need to retrieve the projection from this overlay to do this.
          const overlayProjection = this.getProjection();

          // Retrieve the southwest and northeast coordinates of this overlay
          // in latlngs and convert them to pixels coordinates.
          // We'll use these coordinates to resize the DIV.
          const sw = overlayProjection.fromLatLngToDivPixel(
            this.bounds_.getSouthWest(),
          );
          const ne = overlayProjection.fromLatLngToDivPixel(
            this.bounds_.getNorthEast(),
          );
          // Resize the image's DIV to fit the indicated dimensions.
          const div = this.div_;
          const { width } = this;
          const height = 20;

          div.style.left = `${sw.x - width / 2}px`;
          div.style.top = `${ne.y - height / 2}px`;
          div.style.width = `${width}px`;
          div.style.height = `${height}px`;
          div.style.width = `${width}px`;
          div.style.height = `${height}px`;
        };

        TextOverlay.prototype.onRemove = function () {
          this.div_.parentNode.removeChild(this.div_);
          this.div_ = null;
        };

        // Determine the geohash level we will use to draw tiles
        const currentZoom = this.map.getZoom();
        const geohashLevelNum =
          this.mapModel.determineGeohashLevel(currentZoom);
        const geohashLevel = `geohash_${geohashLevelNum}`;
        const geohashes = this.searchResults.facetCounts[geohashLevel];

        // Save the current geohash level in the map model
        this.mapModel.set("tileGeohashLevel", geohashLevelNum);

        // Get all the geohashes contained in the map
        const mapBBoxes = _.flatten(
          _.values(this.searchModel.get("geohashGroups")),
        );

        // Geohashes may be returned that are part of datasets with multiple geographic areas. Some of these may be outside this map.
        // So we will want to filter out geohashes that are not contained in this map.
        if (mapBBoxes.length == 0) {
          var filteredTileGeohashes = geohashes;
        } else if (geohashes) {
          var filteredTileGeohashes = [];
          for (var i = 0; i &lt; geohashes.length - 1; i += 2) {
            // Get the geohash for this tile
            var tileGeohash = geohashes[i];
            let isInsideMap = false;
            let index = 0;
            let searchString = tileGeohash;

            // Find if any of the bounding boxes/geohashes inside our map contain this tile geohash
            while (!isInsideMap &amp;&amp; searchString.length > 0) {
              searchString = tileGeohash.substring(
                0,
                tileGeohash.length - index,
              );
              if (_.contains(mapBBoxes, searchString)) isInsideMap = true;
              index++;
            }

            if (isInsideMap) {
              filteredTileGeohashes.push(tileGeohash);
              filteredTileGeohashes.push(geohashes[i + 1]);
            }
          }
        }

        // If there are no tiles on the page, the map may have failed to render, so exit.
        if (
          typeof filteredTileGeohashes === "undefined" ||
          !filteredTileGeohashes.length
        ) {
          return;
        }

        // Make a copy of the array that is geohash counts only
        const countsOnly = [];
        for (var i = 1; i &lt; filteredTileGeohashes.length; i += 2) {
          countsOnly.push(filteredTileGeohashes[i]);
        }

        // Create a range of lightness to make different colors on the tiles
        const lightnessMin = this.mapModel.get("tileLightnessMin");
        const lightnessMax = this.mapModel.get("tileLightnessMax");
        const lightnessRange = lightnessMax - lightnessMin;

        // Get some stats on our tile counts so we can normalize them to create a color scale
        const findMedian = function (nums) {
          if (nums.length % 2 == 0) {
            return (nums[nums.length / 2 - 1] + nums[nums.length / 2]) / 2;
          }
          return nums[nums.length / 2 - 0.5];
        };
        const sortedCounts = countsOnly.sort((a, b) => a - b);
        const maxCount = sortedCounts[sortedCounts.length - 1];
        const minCount = sortedCounts[0];

        const viewRef = this;

        // Now draw a tile for each geohash facet
        for (var i = 0; i &lt; filteredTileGeohashes.length - 1; i += 2) {
          // Convert this geohash to lat,long values
          var tileGeohash = filteredTileGeohashes[i];
          const decodedGeohash = nGeohash.decode(tileGeohash);
          const latLngCenter = new google.maps.LatLng(
            decodedGeohash.latitude,
            decodedGeohash.longitude,
          );
          const geohashBox = nGeohash.decode_bbox(tileGeohash);
          const swLatLng = new google.maps.LatLng(geohashBox[0], geohashBox[1]);
          const neLatLng = new google.maps.LatLng(geohashBox[2], geohashBox[3]);
          const bounds = new google.maps.LatLngBounds(swLatLng, neLatLng);
          const tileCount = filteredTileGeohashes[i + 1];
          const drawMarkers = this.mapModel.get("drawMarkers");
          var marker;
          var count;
          var color;

          // Normalize the range of tiles counts and convert them to a lightness domain of 20-70% lightness.
          if (maxCount - minCount == 0) {
            var lightness = lightnessRange;
          } else {
            var lightness =
              ((tileCount - minCount) / (maxCount - minCount)) *
                lightnessRange +
              lightnessMin;
          }

          var color = `hsl(${this.mapModel.get("tileHue")},${lightness}%,50%)`;

          // Add the count to the tile
          const countLocation = new google.maps.LatLngBounds(
            latLngCenter,
            latLngCenter,
          );

          // Draw the tile label with the dataset count
          count = new TextOverlay({
            bounds: countLocation,
            map: this.map,
            text: tileCount,
            color: this.mapModel.get("tileLabelColor"),
          });

          // Set up the default tile options
          const tileOptions = {
            fillColor: color,
            strokeColor: color,
            map: this.map,
            visible: true,
            bounds,
          };

          // Merge these options with any tile options set in the map model
          const modelTileOptions = this.mapModel.get("tileOptions");
          for (const attr in modelTileOptions) {
            tileOptions[attr] = modelTileOptions[attr];
          }

          // Draw this tile
          const tile = this.drawTile(tileOptions, tileGeohash, count);

          // Save the geohashes for tiles in the view for later
          this.tileGeohashes.push(tileGeohash);
        }

        // Create an info window for each marker that is on the map, to display when it is clicked on
        if (this.markerGeohashes.length > 0) this.addMarkers();

        // If the map is zoomed all the way in, draw info windows for each tile that will be displayed when they are clicked on
        if (this.mapModel.isMaxZoom(this.map)) this.addTileInfoWindows();
      },

      /**
       * With the options and label object given, add a single tile to the map and set its event listeners
       * @param {object} options
       * @param {string} geohash
       * @param {string} label
       */
      drawTile(options, geohash, label) {
        // Exit if maps are not in use
        if (this.mode != "map" || !gmaps) {
          return false;
        }

        // Add the tile for these datasets to the map
        const tile = new google.maps.Rectangle(options);

        const viewRef = this;

        // Save our tiles in the view
        const tileObject = {
          text: label,
          shape: tile,
          geohash,
          options,
        };
        this.tiles.push(tileObject);

        // Change styles when the tile is hovered on
        google.maps.event.addListener(tile, "mouseover", (event) => {
          viewRef.highlightTile(tileObject);
        });

        // Change the styles back after the tile is hovered on
        google.maps.event.addListener(tile, "mouseout", (event) => {
          viewRef.unhighlightTile(tileObject);
        });

        // If we are at the max zoom, we will display an info window. If not, we will zoom in.
        if (!this.mapModel.isMaxZoom(viewRef.map)) {
          /**
           * Set up some helper functions for zooming in on the map
           * @param myMap
           * @param bounds
           */
          const myFitBounds = function (myMap, bounds) {
            myMap.fitBounds(bounds); // calling fitBounds() here to center the map for the bounds

            const overlayHelper = new google.maps.OverlayView();
            overlayHelper.draw = function () {
              if (!this.ready) {
                const extraZoom = getExtraZoom(
                  this.getProjection(),
                  bounds,
                  myMap.getBounds(),
                );
                if (extraZoom > 0) {
                  myMap.setZoom(myMap.getZoom() + extraZoom);
                }
                this.ready = true;
                google.maps.event.trigger(this, "ready");
              }
            };
            overlayHelper.setMap(myMap);
          };
          var getExtraZoom = function (
            projection,
            expectedBounds,
            actualBounds,
          ) {
            // in: LatLngBounds bounds -> out: height and width as a Point
            const getSizeInPixels = function (bounds) {
              const sw = projection.fromLatLngToContainerPixel(
                bounds.getSouthWest(),
              );
              const ne = projection.fromLatLngToContainerPixel(
                bounds.getNorthEast(),
              );
              return new google.maps.Point(
                Math.abs(sw.y - ne.y),
                Math.abs(sw.x - ne.x),
              );
            };

            const expectedSize = getSizeInPixels(expectedBounds);
            const actualSize = getSizeInPixels(actualBounds);

            if (
              Math.floor(expectedSize.x) == 0 ||
              Math.floor(expectedSize.y) == 0
            ) {
              return 0;
            }

            const qx = actualSize.x / expectedSize.x;
            const qy = actualSize.y / expectedSize.y;
            const min = Math.min(qx, qy);

            if (min &lt; 1) {
              return 0;
            }

            return Math.floor(Math.log(min) / Math.LN2 /* = log2(min) */);
          };

          // Zoom in when the tile is clicked on
          gmaps.event.addListener(tile, "click", (clickEvent) => {
            // Change the center
            viewRef.map.panTo(clickEvent.latLng);

            // Get this tile's bounds
            const tileBounds = tile.getBounds();
            // Get the current map bounds
            const mapBounds = viewRef.map.getBounds();

            // Change the zoom
            // viewRef.map.fitBounds(tileBounds);
            myFitBounds(viewRef.map, tileBounds);

            // Track this event
            MetacatUI.analytics?.trackEvent(
              "map",
              "clickTile",
              `geohash : ${tileObject.geohash}`,
            );
          });
        }

        return tile;
      },

      highlightTile(tile) {
        // Change the tile style on hover
        tile.shape.setOptions(this.mapModel.get("tileOnHover"));

        // Change the label color on hover
        const div = tile.text.div_;
        if (div) {
          div.style.color = this.mapModel.get("tileLabelColorOnHover");
          tile.text.div_ = div;
          $(div).css("color", this.mapModel.get("tileLabelColorOnHover"));
        }
      },

      unhighlightTile(tile) {
        // Change back the tile to it's original styling
        tile.shape.setOptions(tile.options);

        // Change back the label color
        const div = tile.text.div_;
        div.style.color = this.mapModel.get("tileLabelColor");
        tile.text.div_ = div;
        $(div).css("color", this.mapModel.get("tileLabelColor"));
      },

      /**
       * Get the details on each marker
       * And create an infowindow for that marker
       */
      addMarkers() {
        // Exit if maps are not in use
        if (this.mode != "map" || !gmaps) {
          return false;
        }

        // Clone the Search model
        const searchModelClone = this.searchModel.clone();
        const geohashLevel = this.mapModel.get("tileGeohashLevel");
        const viewRef = this;
        const { markers } = this;

        // Change the geohash filter to match our tiles
        searchModelClone.set("geohashLevel", geohashLevel);
        searchModelClone.set("geohashes", this.markerGeohashes);

        // Now run a query to get a list of documents that are represented by our markers
        const query =
          `q=${searchModelClone.getQuery()}&amp;fl=id,title,geohash_9,abstract,geohash_${geohashLevel}&amp;rows=1000` +
          `&amp;wt=json`;

        const requestSettings = {
          url: MetacatUI.appModel.get("queryServiceUrl") + query,
          success(data, textStatus, xhr) {
            const { docs } = data.response;
            let uniqueGeohashes = viewRef.markerGeohashes;

            // Create a marker and infoWindow for each document
            _.each(docs, (doc, key, list) => {
              let marker;
              const drawMarkersAt = [];

              // Find the tile place that this document belongs to
              // For each geohash value at the current geohash level for this document,
              _.each(doc.geohash_9, (geohash, key, list) => {
                // Loop through each unique tile location to find its match
                for (let i = 0; i &lt;= uniqueGeohashes.length; i++) {
                  if (uniqueGeohashes[i] == geohash.substr(0, geohashLevel)) {
                    drawMarkersAt.push(geohash);
                    uniqueGeohashes = _.without(uniqueGeohashes, geohash);
                  }
                }
              });

              _.each(drawMarkersAt, function (markerGeohash, key, list) {
                const decodedGeohash = nGeohash.decode(markerGeohash);
                const latLng = new google.maps.LatLng(
                  decodedGeohash.latitude,
                  decodedGeohash.longitude,
                );

                // Set up the options for each marker
                const markerOptions = {
                  position: latLng,
                  icon: this.mapModel.get("markerImage"),
                  zIndex: 99999,
                  map: viewRef.map,
                };

                // Create the marker and add to the map
                const marker = new google.maps.Marker(markerOptions);
              });
            });
          },
        };
        $.ajax(
          _.extend(
            requestSettings,
            MetacatUI.appUserModel.createAjaxSettings(),
          ),
        );
      },

      /**
       * Get the details on each tile - a list of ids and titles for each dataset contained in that tile
       * And create an infowindow for that tile
       */
      addTileInfoWindows() {
        // Exit if maps are not in use
        if (this.mode != "map" || !gmaps) {
          return false;
        }

        // Clone the Search model
        const searchModelClone = this.searchModel.clone();
        const geohashLevel = this.mapModel.get("tileGeohashLevel");
        const geohashName = `geohash_${geohashLevel}`;
        const viewRef = this;
        const infoWindows = [];

        // Change the geohash filter to match our tiles
        searchModelClone.set("geohashLevel", geohashLevel);
        searchModelClone.set("geohashes", this.tileGeohashes);

        // Now run a query to get a list of documents that are represented by our tiles
        const query =
          `q=${searchModelClone.getQuery()}&amp;fl=id,title,geohash_9,${geohashName}&amp;rows=1000` +
          `&amp;wt=json`;

        const requestSettings = {
          url: MetacatUI.appModel.get("queryServiceUrl") + query,
          success(data, textStatus, xhr) {
            // Make an infoWindow for each doc
            const { docs } = data.response;

            // For each tile, loop through the docs to find which ones to include in its infoWindow
            _.each(viewRef.tiles, (tile, key, list) => {
              let infoWindowContent = "";

              _.each(docs, (doc, key, list) => {
                const docGeohashes = doc[geohashName];

                if (docGeohashes) {
                  // Is this document in this tile?
                  for (let i = 0; i &lt; docGeohashes.length; i++) {
                    if (docGeohashes[i] == tile.geohash) {
                      // Add this doc to the infoWindow content
                      infoWindowContent += `&lt;a href='${
                        MetacatUI.root
                      }/view/${encodeURIComponent(doc.id)}'>${doc.title}&lt;/a> (${
                        doc.id
                      }) &lt;br/>`;
                      break;
                    }
                  }
                }
              });

              // The center of the tile
              const decodedGeohash = nGeohash.decode(tile.geohash);
              const tileCenter = new google.maps.LatLng(
                decodedGeohash.latitude,
                decodedGeohash.longitude,
              );

              // The infowindow
              const infoWindow = new gmaps.InfoWindow({
                content:
                  `&lt;div class='gmaps-infowindow'>` +
                  `&lt;h4> Datasets located here &lt;/h4>` +
                  `&lt;p>${infoWindowContent}&lt;/p>` +
                  `&lt;/div>`,
                isOpen: false,
                disableAutoPan: false,
                maxWidth: 250,
                position: tileCenter,
              });

              viewRef.tileInfoWindows.push(infoWindow);

              // Zoom in when the tile is clicked on
              gmaps.event.addListener(
                tile.shape,
                "click",
                function (clickEvent) {
                  // --- We are at max zoom, display an infowindow ----//
                  if (this.mapModel.isMaxZoom(viewRef.map)) {
                    // Find the infowindow that belongs to this tile in the view
                    infoWindow.open(viewRef.map);
                    infoWindow.isOpen = true;

                    // Close all other infowindows
                    viewRef.closeInfoWindows(infoWindow);
                  }

                  // ------ We are not at max zoom, so zoom into this tile ----//
                  else {
                    // Change the center
                    viewRef.map.panTo(clickEvent.latLng);

                    // Get this tile's bounds
                    const bounds = tile.shape.getBounds();

                    // Change the zoom
                    viewRef.map.fitBounds(bounds);
                  }
                },
              );

              // Close the infowindow upon any click on the map
              gmaps.event.addListener(viewRef.map, "click", () => {
                infoWindow.close();
                infoWindow.isOpen = false;
              });

              infoWindows[tile.geohash] = infoWindow;
            });

            viewRef.infoWindows = infoWindows;
          },
        };
        $.ajax(
          _.extend(
            requestSettings,
            MetacatUI.appUserModel.createAjaxSettings(),
          ),
        );
      },

      /**
       * Iterate over each infowindow that we have stored in the view and close it.
       * Pass an infoWindow object to this function to keep that infoWindow open/skip it
       * @param {infoWindow} - An infoWindow to keep open
       * @param except
       */
      closeInfoWindows(except) {
        const infoWindowLists = [this.markerInfoWindows, this.tileInfoWindows];

        _.each(infoWindowLists, (infoWindows, key, list) => {
          // Iterate over all the marker infowindows and close all of them except for this one
          for (let i = 0; i &lt; infoWindows.length; i++) {
            if (infoWindows[i].isOpen &amp;&amp; infoWindows[i] != except) {
              // Close this info window and stop looking, since only one of each kind should be open anyway
              infoWindows[i].close();
              infoWindows[i].isOpen = false;
              i = infoWindows.length;
            }
          }
        });
      },

      /**
       * Remove all the tiles and text from the map
       */
      removeTiles() {
        // Exit if maps are not in use
        if (this.mode != "map" || !gmaps) {
          return false;
        }

        // Remove the tile from the map
        _.each(this.tiles, (tile, key, list) => {
          if (tile.shape) tile.shape.setMap(null);
          if (tile.text) tile.text.setMap(null);
        });

        // Reset the tile storage in the view
        this.tiles = [];
        this.tileGeohashes = [];
        this.tileInfoWindows = [];
      },

      /**
       * Iterate over all the markers in the view and remove them from the map and view
       */
      removeMarkers() {
        // Exit if maps are not in use
        if (this.mode != "map" || !gmaps) {
          return false;
        }

        // Remove the marker from the map
        _.each(this.markers, (marker, key, list) => {
          marker.marker.setMap(null);
        });

        // Reset the marker storage in the view
        this.markers = [];
        this.markerGeohashes = [];
        this.markerInfoWindows = [];
      },

      /*
       * ==================================================================================================
       *                                             ADDING RESULTS
       * ==================================================================================================
       */

      /**
       * Add all items in the **SearchResults** collection
       * This loads the first 25, then waits for the map to be
       * fully loaded and then loads the remaining items.
       * Without this delay, the app waits until all records are processed
       */
      addAll() {
        // After the map is done loading, then load the rest of the results into the list
        if (this.ready) this.renderAll();
        else {
          const viewRef = this;
          var intervalID = setInterval(() => {
            if (viewRef.ready) {
              clearInterval(intervalID);
              viewRef.renderAll();
            }
          }, 500);
        }

        // After all the results are loaded, query for our facet counts in the background
        // this.getAutocompletes();
      },

      renderAll() {
        // do this first to indicate coming results
        this.updateStats();

        // Remove all the existing tiles on the map
        this.removeTiles();
        this.removeMarkers();

        // Remove the loading class and styling
        this.$results.removeClass("loading");

        // If there are no results, display so
        const numFound = this.searchResults.length;
        if (numFound == 0) {
          // Add a No Results Found message
          this.$results.html("&lt;p id='no-results-found'>No results found.&lt;/p>");

          // Remove the loading styles from the map
          if (gmaps &amp;&amp; this.mapModel) {
            $("#map-container").removeClass("loading");
          }

          if (MetacatUI.theme == "arctic") {
            // When we get new results, check if the user is searching for their own datasets and display a message
            if (
              MetacatUI.appView.dataCatalogView &amp;&amp;
              MetacatUI.appView.dataCatalogView.searchModel.getQuery() ==
                MetacatUI.appUserModel.get("searchModel").getQuery() &amp;&amp;
              !MetacatUI.appSearchResults.length
            ) {
              $("#no-results-found").after(
                `&lt;h3>Where are my data sets?&lt;/h3>&lt;p>If you are a previous ACADIS Gateway user, ` +
                  `you will need to take additional steps to access your data sets in the new NSF Arctic Data Center.` +
                  `&lt;a href='mailto:support@arcticdata.io'>Send us a message at support@arcticdata.io&lt;/a> with your old ACADIS ` +
                  `Gateway username and your ORCID identifier (${MetacatUI.appUserModel.get(
                    "username",
                  )}), we will help.&lt;/p>`,
              );
            }
          }
          return;
        }

        // Clear the results list before we start adding new rows
        this.$results.html("");

        // --First map all the results--
        if (gmaps &amp;&amp; this.mapModel) {
          // Draw all the tiles on the map to represent the datasets
          this.drawTiles();

          // Remove the loading styles from the map
          $("#map-container").removeClass("loading");
        }

        const pid_list = new Array();

        // --- Add all the results to the list ---
        for (i = 0; i &lt; this.searchResults.length; i++) {
          pid_list.push(this.searchResults.models[i].get("id"));
        }

        if (MetacatUI.appModel.get("displayDatasetMetrics")) {
          const metricsModel = new MetricsModel({
            pid_list,
            type: "catalog",
          });
          metricsModel.fetch();
          this.metricsModel = metricsModel;
        }

        // --- Add all the results to the list ---
        for (i = 0; i &lt; this.searchResults.length; i++) {
          const element = this.searchResults.models[i];
          if (typeof element !== "undefined")
            this.addOne(element, this.metricsModel);
        }

        // Initialize any tooltips within the result item
        $(".tooltip-this").tooltip();
        $(".popover-this").popover();

        // Set the autoheight
        this.setAutoHeight();
      },

      /**
       * Add a single SolrResult item to the list by creating a view for it and appending its element to the DOM.
       * @param result
       */
      addOne(result) {
        // Get the view and package service URL's
        this.$view_service = MetacatUI.appModel.get("viewServiceUrl");
        this.$package_service = MetacatUI.appModel.get("packageServiceUrl");
        result.set({
          view_service: this.$view_service,
          package_service: this.$package_service,
        });

        const view = new SearchResultView({
          model: result,
          metricsModel: this.metricsModel,
        });

        // Add this item to the list
        this.$results.append(view.render().el);

        // map it
        if (
          gmaps &amp;&amp;
          this.mapModel &amp;&amp;
          typeof result.get("geohash_9") !== "undefined" &amp;&amp;
          result.get("geohash_9") != null
        ) {
          const title = result.get("title");

          for (let i = 0; i &lt; result.get("geohash_9").length; i++) {
            const centerGeohash = result.get("geohash_9")[i];
            const decodedGeohash = nGeohash.decode(centerGeohash);
            const position = new google.maps.LatLng(
              decodedGeohash.latitude,
              decodedGeohash.longitude,
            );
            const marker = new gmaps.Marker({
              position,
              icon: this.mapModel.get("markerImage"),
              zIndex: 99999,
            });
          }
        }
      },

      /**
       * When the SearchResults collection has an error getting the results,
       * show an error message instead of search results
       * @param {SolrResult} model
       * @param {XMLHttpRequest.response} response
       */
      showError(model, response) {
        let errorMessage = "";
        let statusCode = response.status;

        if (!statusCode) {
          statusCode = parseInt(response.statusText);
        }

        if (statusCode == 500 &amp;&amp; this.solrError500Message) {
          errorMessage = this.solrError500Message;
        } else {
          try {
            errorMessage = $(response.responseText).text();
          } catch (e) {
            try {
              errorMessage = JSON.parse(response.responseText).error.msg;
            } catch (e) {
              errorMessage = "";
            }
          } finally {
            if (typeof errorMessage === "string" &amp;&amp; errorMessage.length) {
              errorMessage = `&lt;p>Error details: ${errorMessage}&lt;/p>`;
            }
          }
        }

        MetacatUI.appView.showAlert(
          `&lt;h4>&lt;i class='icon icon-frown'>&lt;/i>${this.solrErrorTitle}.&lt;/h4>${errorMessage}`,
          "alert-error",
          this.$results,
        );

        this.$results.find(".loading").remove();
      },

      /*
       * ==================================================================================================
       *                                             STYLING THE UI
       * ==================================================================================================
       */
      toggleMapMode(e) {
        if (typeof e === "object") {
          e.preventDefault();
        }

        if (gmaps) {
          $(".mapMode").toggleClass("mapMode");
        }

        if (this.mode == "map") {
          MetacatUI.appModel.set("searchMode", "list");
          this.mode = "list";
          this.$("#map-canvas").detach();
          this.setAutoHeight();
          this.getResults();
        } else if (this.mode == "list") {
          MetacatUI.appModel.set("searchMode", "map");
          this.mode = "map";
          this.renderMap();
          this.setAutoHeight();
          this.getResults();
        }
      },

      // Communicate that the page is loading
      loading() {
        $("#map-container").addClass("loading");
        this.$results.addClass("loading");

        this.$results.html(
          this.loadingTemplate({
            msg: "Searching for data...",
          }),
        );
      },

      // Toggles the collapseable filters sidebar and result list in the default theme
      collapse(e) {
        const id = $(e.target).attr("data-collapse");

        $(`#${id}`).toggleClass("collapsed");
      },

      toggleFilterCollapse(e) {
        let container = this.$(".filter-contain.collapsable");
        if (typeof e !== "undefined") {
          container = $(e.target).parents(".filter-contain.collapsable");
        }

        // If we can't find a container, then don't do anything
        if (container.length &lt; 1) return;

        const isAnnoContainer =
          $(container).attr("data-category") === "annotation";

        // Expand
        if ($(container).is(".collapsed")) {
          // Toggle the visibility of the collapse/expand icons
          $(container).find(".expand").hide();
          $(container).find(".collapse").show();

          // Cache the height of this element so we can reset it on collapse
          $(container).attr("data-height", $(container).css("height"));

          // Increase the height of the container to expand it
          $(container).css("max-height", "3000px");

          // For annotation container, allow overflow for the dropdown
          if (isAnnoContainer) {
            $(container).css("overflow", "visible");
          }
        }
        // Collapse
        else {
          // Toggle the visibility of the collapse/expand icons
          $(container).find(".collapse").hide();
          $(container).find(".expand").show();

          // Decrease the height of the container to collapse it
          if ($(container).attr("data-height")) {
            $(container).css("max-height", $(container).attr("data-height"));
          } else {
            $(container).css("max-height", "1.5em");
          }
          if (isAnnoContainer) {
            $(container).css("overflow", "hidden");
          }
        }

        $(container).toggleClass("collapsed");
      },
      /*
       * Either hides or shows the "clear all filters" button
       */
      toggleClearButton() {
        if (this.searchModel.filterCount() > 0) {
          this.showClearButton();
        } else {
          this.hideClearButton();
        }
      },

      // Move the popover element up the page a bit if it runs off the bottom of the page
      preventPopoverRunoff(e) {
        // In map view only (because all elements are fixed and you can't scroll)
        if (this.mode == "map") {
          var viewportHeight = $("#map-container").outerHeight();
        } else {
          return false;
        }

        if ($(".popover").length > 0) {
          const offset = $(".popover").offset();
          const popoverHeight = $(".popover").outerHeight();
          const topPosition = offset.top;

          // If pixels are cut off the top of the page, readjust its vertical position
          if (topPosition &lt; 0) {
            $(".popover").offset({
              top: 10,
            });
          } else {
            // Else, let's check if it is cut off at the bottom
            const totalHeight = topPosition + popoverHeight;

            const pixelsHidden = totalHeight - viewportHeight;

            const newTopPosition = topPosition - pixelsHidden - 40;

            // If pixels are cut off the bottom of the page, readjust its vertical position
            if (pixelsHidden > 0) {
              $(".popover").offset({
                top: newTopPosition,
              });
            }
          }
        }
      },

      onClose() {
        this.stopListening();

        $(".DataCatalog").removeClass("DataCatalog");
        $(".mapMode").removeClass("mapMode");

        if (gmaps) {
          // unset map mode
          $("body").removeClass("mapMode");
          $("#map-canvas").remove();
        }

        // remove everything so we don't get a flicker
        this.$el.html("");
      },
    },
  );
  return DataCatalogView;
});
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
