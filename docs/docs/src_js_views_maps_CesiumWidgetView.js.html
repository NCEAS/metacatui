<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>MetacatUI Dev Docs: Source: src/js/views/maps/CesiumWidgetView.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="/metacatui/assets/css/styles.css">
    <link type="text/css" rel="stylesheet" href="styles/style.css">
</head>

<body>

<nav id="nav">
    <a href="/">
      <div class="logo">
<svg class="cat" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="cat" class="svg-inline--fa fa-cat fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M290.59 192c-20.18 0-106.82 1.98-162.59 85.95V192c0-52.94-43.06-96-96-96-17.67 0-32 14.33-32 32s14.33 32 32 32c17.64 0 32 14.36 32 32v256c0 35.3 28.7 64 64 64h176c8.84 0 16-7.16 16-16v-16c0-17.67-14.33-32-32-32h-32l128-96v144c0 8.84 7.16 16 16 16h32c8.84 0 16-7.16 16-16V289.86c-10.29 2.67-20.89 4.54-32 4.54-61.81 0-113.52-44.05-125.41-102.4zM448 96h-64l-64-64v134.4c0 53.02 42.98 96 96 96s96-42.98 96-96V32l-64 64zm-72 80c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16zm80 0c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16z"></path></svg>

<svg width="459px" height="53px" viewBox="0 0 459 53" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="metacatui" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M16.492,52 C17.212,52 17.812,51.748 18.292,51.244 C18.772,50.74 19.012,50.128 19.012,49.408 L19.012,49.408 L18.94,22.912 L30.82,37.816 C31.204,38.344 31.72,38.764 32.368,39.076 C33.016,39.388 33.7,39.544 34.42,39.544 C35.908,39.544 37.132,38.896 38.092,37.6 L38.092,37.6 L49.684,22.912 L49.684,49.408 C49.684,50.128 49.96,50.74 50.512,51.244 C51.064,51.748 51.7,52 52.42,52 L52.42,52 L62.068,52 C62.788,52 63.388,51.748 63.868,51.244 C64.348,50.74 64.588,50.128 64.588,49.408 L64.588,49.408 L64.588,4.12 C64.588,3.448 64.336,2.86 63.832,2.356 C63.328,1.852 62.74,1.6 62.068,1.6 L62.068,1.6 L52.348,1.6 C51.388,1.6 50.56,1.648 49.864,1.744 C49.168,1.84 48.532,2.152 47.956,2.68 L47.956,2.68 L33.916,17.296 L20.524,2.608 C20.332,2.368 19.972,2.14 19.444,1.924 C18.916,1.708 18.412,1.6 17.932,1.6 L17.932,1.6 L6.772,1.6 C6.052,1.6 5.44,1.852 4.936,2.356 C4.432,2.86 4.18,3.448 4.18,4.12 L4.18,4.12 L4.18,49.408 C4.18,50.08 4.432,50.68 4.936,51.208 C5.44,51.736 6.052,52 6.772,52 L6.772,52 L16.492,52 Z M110.74,52 C111.556,52 112.264,51.676 112.864,51.028 C113.464,50.38 113.764,49.624 113.764,48.76 L113.764,48.76 L113.764,42.568 C113.764,41.608 113.464,40.828 112.864,40.228 C112.264,39.628 111.556,39.328 110.74,39.328 L110.74,39.328 L89.428,39.328 L89.428,32.92 L109.732,32.92 C110.5,32.92 111.184,32.596 111.784,31.948 C112.384,31.3 112.684,30.568 112.684,29.752 L112.684,29.752 L112.684,23.488 C112.684,22.576 112.384,21.82 111.784,21.22 C111.184,20.62 110.5,20.32 109.732,20.32 L109.732,20.32 L89.428,20.32 L89.428,14.488 L110.74,14.488 C111.508,14.488 112.204,14.164 112.828,13.516 C113.452,12.868 113.764,12.136 113.764,11.32 L113.764,11.32 L113.764,5.056 C113.764,4.144 113.464,3.388 112.864,2.788 C112.264,2.188 111.556,1.888 110.74,1.888 L110.74,1.888 L76.756,1.888 C75.94,1.888 75.232,2.188 74.632,2.788 C74.032,3.388 73.732,4.144 73.732,5.056 L73.732,5.056 L73.732,48.76 C73.732,49.624 74.032,50.38 74.632,51.028 C75.232,51.676 75.94,52 76.756,52 L76.756,52 L110.74,52 Z M147.604,52 C148.42,52 149.104,51.688 149.656,51.064 C150.208,50.44 150.484,49.672 150.484,48.76 L150.484,48.76 L150.484,16.216 L161.86,16.216 C162.676,16.216 163.396,15.904 164.02,15.28 C164.644,14.656 164.956,13.936 164.956,13.12 L164.956,13.12 L164.956,4.768 C164.956,4 164.644,3.316 164.02,2.716 C163.396,2.116 162.676,1.816 161.86,1.816 L161.86,1.816 L124.132,1.816 C123.22,1.816 122.464,2.104 121.864,2.68 C121.264,3.256 120.964,3.952 120.964,4.768 L120.964,4.768 L120.964,13.12 C120.964,13.936 121.264,14.656 121.864,15.28 C122.464,15.904 123.22,16.216 124.132,16.216 L124.132,16.216 L135.652,16.216 L135.148,48.832 C135.148,49.744 135.424,50.5 135.976,51.1 C136.528,51.7 137.212,52 138.028,52 L138.028,52 L147.604,52 Z M175.828,52 C176.836,52 177.676,51.82 178.348,51.46 C179.02,51.1 179.452,50.584 179.644,49.912 L179.644,49.912 L181.876,42.712 L197.932,42.712 L200.164,49.912 C200.356,50.584 200.8,51.1 201.496,51.46 C202.192,51.82 203.044,52 204.052,52 L204.052,52 L213.916,52 C215.836,51.712 216.796,50.704 216.796,48.976 C216.796,48.304 216.676,47.596 216.436,46.852 C216.196,46.108 216.052,45.616 216.004,45.376 L216.004,45.376 L199.876,4.84 C199.588,3.976 199.036,3.232 198.22,2.608 C197.404,1.984 196.372,1.648 195.124,1.6 L195.124,1.6 L184.756,1.6 C183.604,1.648 182.608,1.948 181.768,2.5 C180.928,3.052 180.292,3.832 179.86,4.84 L179.86,4.84 L163.876,45.376 C163.828,45.472 163.672,45.916 163.408,46.708 C163.144,47.5 163.012,48.304 163.012,49.12 C163.012,50.752 163.948,51.712 165.82,52 L165.82,52 L175.828,52 Z M195.34,30.544 L184.036,30.544 L189.652,13.624 L195.34,30.544 Z M245.38,53.08 C250.612,53.08 255.652,51.544 260.5,48.472 C261.22,47.944 261.58,47.296 261.58,46.528 C261.58,45.808 261.292,45.16 260.716,44.584 L260.716,44.584 L252.796,36.808 C252.364,36.376 251.836,36.16 251.212,36.16 C250.78,36.16 250.372,36.256 249.988,36.448 C248.356,37.12 246.796,37.456 245.308,37.456 C243.244,37.456 241.348,36.952 239.62,35.944 C237.892,34.936 236.512,33.58 235.48,31.876 C234.448,30.172 233.932,28.336 233.932,26.368 C233.932,24.352 234.436,22.504 235.444,20.824 C236.452,19.144 237.832,17.812 239.584,16.828 C241.336,15.844 243.244,15.352 245.308,15.352 C246.892,15.352 248.332,15.64 249.628,16.216 C250.012,16.408 250.444,16.504 250.924,16.504 C251.548,16.504 252.1,16.264 252.58,15.784 L252.58,15.784 L259.636,8.008 C260.164,7.384 260.428,6.76 260.428,6.136 C260.428,5.224 259.996,4.528 259.132,4.048 C254.86,1.552 250.276,0.304 245.38,0.304 C240.532,0.304 236.032,1.492 231.88,3.868 C227.728,6.244 224.44,9.448 222.016,13.48 C219.592,17.512 218.38,21.904 218.38,26.656 C218.38,31.408 219.592,35.812 222.016,39.868 C224.44,43.924 227.728,47.14 231.88,49.516 C236.032,51.892 240.532,53.08 245.38,53.08 Z M279.796,52 C280.804,52 281.644,51.82 282.316,51.46 C282.988,51.1 283.42,50.584 283.612,49.912 L283.612,49.912 L285.844,42.712 L301.9,42.712 L304.132,49.912 C304.324,50.584 304.768,51.1 305.464,51.46 C306.16,51.82 307.012,52 308.02,52 L308.02,52 L317.884,52 C319.804,51.712 320.764,50.704 320.764,48.976 C320.764,48.304 320.644,47.596 320.404,46.852 C320.164,46.108 320.02,45.616 319.972,45.376 L319.972,45.376 L303.844,4.84 C303.556,3.976 303.004,3.232 302.188,2.608 C301.372,1.984 300.34,1.648 299.092,1.6 L299.092,1.6 L288.724,1.6 C287.572,1.648 286.576,1.948 285.736,2.5 C284.896,3.052 284.26,3.832 283.828,4.84 L283.828,4.84 L267.844,45.376 C267.796,45.472 267.64,45.916 267.376,46.708 C267.112,47.5 266.98,48.304 266.98,49.12 C266.98,50.752 267.916,51.712 269.788,52 L269.788,52 L279.796,52 Z M299.308,30.544 L288.004,30.544 L293.62,13.624 L299.308,30.544 Z M352.588,52 C353.404,52 354.088,51.688 354.64,51.064 C355.192,50.44 355.468,49.672 355.468,48.76 L355.468,48.76 L355.468,16.216 L366.844,16.216 C367.66,16.216 368.38,15.904 369.004,15.28 C369.628,14.656 369.94,13.936 369.94,13.12 L369.94,13.12 L369.94,4.768 C369.94,4 369.628,3.316 369.004,2.716 C368.38,2.116 367.66,1.816 366.844,1.816 L366.844,1.816 L329.116,1.816 C328.204,1.816 327.448,2.104 326.848,2.68 C326.248,3.256 325.948,3.952 325.948,4.768 L325.948,4.768 L325.948,13.12 C325.948,13.936 326.248,14.656 326.848,15.28 C327.448,15.904 328.204,16.216 329.116,16.216 L329.116,16.216 L340.636,16.216 L340.132,48.832 C340.132,49.744 340.408,50.5 340.96,51.1 C341.512,51.7 342.196,52 343.012,52 L343.012,52 L352.588,52 Z M402.052,52.792 C408.1,52.792 412.912,51.628 416.488,49.3 C420.064,46.972 422.536,44.068 423.904,40.588 C425.272,37.108 425.932,33.424 425.884,29.536 C425.884,29.5309474 425.883967,29.5237673 425.8839,29.5144598 L425.883102,29.4330859 C425.879911,29.1480111 425.868211,28.3183158 425.848,26.944 C425.8294,25.6792 425.818008,22.91524 425.813823,18.65212 L425.813103,17.80828 C425.812997,17.66452 425.8129,17.5192 425.81281,17.37232 L425.812,3.904 C425.86,3.184 425.632,2.62 425.128,2.212 C424.624,1.804 423.916,1.6 423.004,1.6 L423.004,1.6 L413.428,1.6 C412.612,1.6 411.904,1.828 411.304,2.284 C410.704,2.74 410.404,3.28 410.404,3.904 L410.404,3.904 L410.26,27.808 C410.26,34.144 407.476,37.312 401.908,37.312 C399.076,37.312 396.832,36.412 395.176,34.612 C393.52,32.812 392.668,30.352 392.62,27.232 L392.62,27.232 L392.332,3.76 C392.332,3.088 392.068,2.56 391.54,2.176 C391.012,1.792 390.268,1.6 389.308,1.6 L389.308,1.6 L379.876,1.6 C378.244,1.6 377.428,2.32 377.428,3.76 L377.428,3.76 L377.5,28.816 C377.5,33.04 378.376,36.964 380.128,40.588 C381.88,44.212 384.592,47.152 388.264,49.408 C391.936,51.664 396.532,52.792 402.052,52.792 Z M449.284,52.144 C450.148,52.144 450.88,51.844 451.48,51.244 C452.08,50.644 452.38,49.84 452.38,48.832 L452.38,48.832 L452.38,4.912 C452.38,4 452.08,3.22 451.48,2.572 C450.88,1.924 450.148,1.6 449.284,1.6 L449.284,1.6 L439.42,1.6 C438.46,1.6 437.692,1.924 437.116,2.572 C436.54,3.22 436.252,4 436.252,4.912 L436.252,4.912 L436.252,48.832 C436.252,49.84 436.54,50.644 437.116,51.244 C437.692,51.844 438.46,52.144 439.42,52.144 L439.42,52.144 L449.284,52.144 Z" id="metacatui" fill="#FCBF49" fill-rule="nonzero"></path>
    </g>
</svg>
</logo>

    </a>
    <h3>Namespaces</h3><ul><li><a href="AppConfig.html">AppConfig</a></li><li><a href="IconUtilities.html">IconUtilities</a></li><li><a href="MapConfig.html">MapConfig</a></li><li><a href="MetacatUI.html">MetacatUI</a></li><li><a href="Utilities.html">Utilities</a></li></ul><h3>Classes</h3><ul><li class='category-heading' data-category='Collections'>Collections</li><li><a href="AccessPolicy.html">AccessPolicy</a></li><li><a href="Citations.html">Citations</a></li><li><a href="DataPackage.html">DataPackage</a></li><li><a href="Filters.html">Filters</a></li><li><a href="ObjectFormats.html">ObjectFormats</a></li><li><a href="ProjectList.html">ProjectList</a></li><li><a href="QualityReport.html">QualityReport</a></li><li><a href="SolrResults.html">SolrResults</a></li><li><a href="Units.html">Units</a></li><li><a href="UserGroup.html">UserGroup</a></li><li class='category-heading' data-category='Collections/Bookkeeper'>Collections/Bookkeeper</li><li><a href="Quotas.html">Quotas</a></li><li><a href="Usages.html">Usages</a></li><li class='category-heading' data-category='Collections/Geohashes'>Collections/Geohashes</li><li><a href="Geohashes.html">Geohashes</a></li><li class='category-heading' data-category='Collections/Maps'>Collections/Maps</li><li><a href="AssetCategories.html">AssetCategories</a></li><li><a href="AssetColors.html">AssetColors</a></li><li><a href="Features.html">Features</a></li><li><a href="GeoPoints.html">GeoPoints</a></li><li><a href="MapAssets.html">MapAssets</a></li><li><a href="VectorFilters.html">VectorFilters</a></li><li class='category-heading' data-category='Collections/Metadata/EML'>Collections/Metadata/EML</li><li><a href="EMLAnnotations.html">EMLAnnotations</a></li><li><a href="EMLMissingValueCodes.html">EMLMissingValueCodes</a></li><li class='category-heading' data-category='Collections/QueryFields'>Collections/QueryFields</li><li><a href="QueryFields.html">QueryFields</a></li><li class='category-heading' data-category='Models'>Models</li><li><a href="AccessRule.html">AccessRule</a></li><li><a href="AppModel.html">AppModel</a></li><li><a href="CitationModel.html">CitationModel</a></li><li><a href="CollectionModel.html">CollectionModel</a></li><li><a href="DataONEObject.html">DataONEObject</a></li><li><a href="LookupModel.html">LookupModel</a></li><li><a href="Map.html">Map</a></li><li><a href="Metrics.html">Metrics</a></li><li><a href="QualityCheck.html">QualityCheck</a></li><li><a href="Search.html">Search</a></li><li><a href="SolrResult.html">SolrResult</a></li><li><a href="Stats.html">Stats</a></li><li class='category-heading' data-category='Models/Analytics'>Models/Analytics</li><li><a href="Analytics.html">Analytics</a></li><li><a href="GoogleAnalytics.html">GoogleAnalytics</a></li><li class='category-heading' data-category='Models/Bookkeeper'>Models/Bookkeeper</li><li><a href="Quota.html">Quota</a></li><li><a href="Subscription.html">Subscription</a></li><li><a href="Usage.html">Usage</a></li><li class='category-heading' data-category='Models/Connectors'>Models/Connectors</li><li><a href="FiltersMapConnector.html">FiltersMapConnector</a></li><li><a href="FiltersSearchConnector.html">FiltersSearchConnector</a></li><li><a href="GeoPointsCesiumConnector.html">GeoPointsCesiumConnector</a></li><li><a href="GeoPointsCesiumPointsConnector.html">GeoPointsCesiumPointsConnector</a></li><li><a href="GeoPointsCesiumPolygonConnector.html">GeoPointsCesiumPolygonConnector</a></li><li><a href="MapSearchConnector.html">MapSearchConnector</a></li><li><a href="MapSearchFiltersConnector.html">MapSearchFiltersConnector</a></li><li class='category-heading' data-category='Models/Filters'>Models/Filters</li><li><a href="BooleanFilter.html">BooleanFilter</a></li><li><a href="ChoiceFilter.html">ChoiceFilter</a></li><li><a href="DateFilter.html">DateFilter</a></li><li><a href="Filter.html">Filter</a></li><li><a href="FilterGroup.html">FilterGroup</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="SpatialFilter.html">SpatialFilter</a></li><li><a href="ToggleFilter.html">ToggleFilter</a></li><li class='category-heading' data-category='Models/Formats'>Models/Formats</li><li><a href="ObjectFormat.html">ObjectFormat</a></li><li class='category-heading' data-category='Models/Geocoder'>Models/Geocoder</li><li><a href="GeocodedLocation.html">GeocodedLocation</a></li><li><a href="GeocoderSearch.html">GeocoderSearch</a></li><li><a href="GoogleMapsAutocompleter.html">GoogleMapsAutocompleter</a></li><li><a href="GoogleMapsGeocoder.html">GoogleMapsGeocoder</a></li><li><a href="Prediction.html">Prediction</a></li><li class='category-heading' data-category='Models/Geohashes'>Models/Geohashes</li><li><a href="Geohash.html">Geohash</a></li><li class='category-heading' data-category='Models/Maps'>Models/Maps</li><li><a href="AssetCategory.html">AssetCategory</a></li><li><a href="AssetColor.html">AssetColor</a></li><li><a href="AssetColorPalette.html">AssetColorPalette</a></li><li><a href="Feature.html">Feature</a></li><li><a href="GeoBoundingBox.html">GeoBoundingBox</a></li><li><a href="GeoPoint.html">GeoPoint</a></li><li><a href="GeoScale.html">GeoScale</a></li><li><a href="GeoUtilities.html">GeoUtilities</a></li><li><a href="MapInteraction.html">MapInteraction</a></li><li><a href="MapModel.html">MapModel</a></li><li><a href="VectorFilter.html">VectorFilter</a></li><li><a href="ViewfinderModel.html">ViewfinderModel</a></li><li class='category-heading' data-category='Models/Maps/Assets'>Models/Maps/Assets</li><li><a href="Cesium3DTileset.html">Cesium3DTileset</a></li><li><a href="CesiumGeohash.html">CesiumGeohash</a></li><li><a href="CesiumImagery.html">CesiumImagery</a></li><li><a href="CesiumTerrain.html">CesiumTerrain</a></li><li><a href="CesiumVectorData.html">CesiumVectorData</a></li><li><a href="MapAsset.html">MapAsset</a></li><li class='category-heading' data-category='Models/Metadata'>Models/Metadata</li><li><a href="ScienceMetadata.html">ScienceMetadata</a></li><li class='category-heading' data-category='Models/Metadata/EML'>Models/Metadata/EML</li><li><a href="EMLMethodStep.html">EMLMethodStep</a></li><li><a href="EMLSpecializedText.html">EMLSpecializedText</a></li><li class='category-heading' data-category='Models/Metadata/EML211'>Models/Metadata/EML211</li><li><a href="EML211.html">EML211</a></li><li><a href="EMLAnnotation.html">EMLAnnotation</a></li><li><a href="EMLAttribute.html">EMLAttribute</a></li><li><a href="EMLDataTable.html">EMLDataTable</a></li><li><a href="EMLDistribution.html">EMLDistribution</a></li><li><a href="EMLEntity.html">EMLEntity</a></li><li><a href="EMLGeoCoverage.html">EMLGeoCoverage</a></li><li><a href="EMLMeasurementScale.html">EMLMeasurementScale</a></li><li><a href="EMLMethods.html">EMLMethods</a></li><li><a href="EMLMissingValueCode.html">EMLMissingValueCode</a></li><li><a href="EMLNonNumericDomain.html">EMLNonNumericDomain</a></li><li><a href="EMLNumericDomain.html">EMLNumericDomain</a></li><li><a href="EMLOtherEntity.html">EMLOtherEntity</a></li><li><a href="EMLParty.html">EMLParty</a></li><li><a href="EMLTemporalCoverage.html">EMLTemporalCoverage</a></li><li><a href="EMLText211.html">EMLText211</a></li><li><a href="EMLUnit.html">EMLUnit</a></li><li class='category-heading' data-category='Models/Metadata/EML220'>Models/Metadata/EML220</li><li><a href="EMLText.html">EMLText</a></li><li class='category-heading' data-category='Models/Portals'>Models/Portals</li><li><a href="PortalImage.html">PortalImage</a></li><li><a href="PortalModel.html">PortalModel</a></li><li><a href="PortalSectionModel.html">PortalSectionModel</a></li><li class='category-heading' data-category='Models/Projects'>Models/Projects</li><li><a href="Project.html">Project</a></li><li class='category-heading' data-category='Models/QueryFields'>Models/QueryFields</li><li><a href="QueryField.html">QueryField</a></li><li class='category-heading' data-category='Router'>Router</li><li><a href="UIRouter.html">UIRouter</a></li><li class='category-heading' data-category='Views'>Views</li><li><a href="AccessPolicyView.html">AccessPolicyView</a></li><li><a href="AccessRuleView.html">AccessRuleView</a></li><li><a href="AnnotationView.html">AnnotationView</a></li><li><a href="AppView.html">AppView</a></li><li><a href="CatalogSearchView.html">CatalogSearchView</a></li><li><a href="CitationHeaderView.html">CitationHeaderView</a></li><li><a href="CitationListView.html">CitationListView</a></li><li><a href="CitationModalView.html">CitationModalView</a></li><li><a href="CitationView.html">CitationView</a></li><li><a href="ColorPaletteView.html">ColorPaletteView</a></li><li><a href="DataCatalogViewWithFilters.html">DataCatalogViewWithFilters</a></li><li><a href="DataItemView.html">DataItemView</a></li><li><a href="DataPackageView.html">DataPackageView</a></li><li><a href="DraftsView.html">DraftsView</a></li><li><a href="EditCollectionView.html">EditCollectionView</a></li><li><a href="EditorView.html">EditorView</a></li><li><a href="FooterView.html">FooterView</a></li><li><a href="GroupListView.html">GroupListView</a></li><li><a href="ImageUploaderView.html">ImageUploaderView</a></li><li><a href="MarkdownEditorView.html">MarkdownEditorView</a></li><li><a href="MarkdownView.html">MarkdownView</a></li><li><a href="MdqRunView.html">MdqRunView</a></li><li><a href="MetadataView.html">MetadataView</a></li><li><a href="MetricModalView.html">MetricModalView</a></li><li><a href="MetricView.html">MetricView</a></li><li><a href="MetricsChartView.html">MetricsChartView</a></li><li><a href="NavbarView.html">NavbarView</a></li><li><a href="RegisterCitationView.html">RegisterCitationView</a></li><li><a href="SearchResultView.html">SearchResultView</a></li><li><a href="SignInView.html">SignInView</a></li><li><a href="TOCView.html">TOCView</a></li><li><a href="TableEditorView.html">TableEditorView</a></li><li><a href="UserGroupView.html">UserGroupView</a></li><li><a href="UserView.html">UserView</a></li><li class='category-heading' data-category='Views/Filters'>Views/Filters</li><li><a href="BooleanFilterView.html">BooleanFilterView</a></li><li><a href="ChoiceFilterView.html">ChoiceFilterView</a></li><li><a href="DateFilterView.html">DateFilterView</a></li><li><a href="FilterEditorView.html">FilterEditorView</a></li><li><a href="FilterGroupView.html">FilterGroupView</a></li><li><a href="FilterGroupsView.html">FilterGroupsView</a></li><li><a href="FilterView.html">FilterView</a></li><li><a href="NumericFilterView.html">NumericFilterView</a></li><li><a href="SemanticFilterView.html">SemanticFilterView</a></li><li><a href="ToggleFilterView.html">ToggleFilterView</a></li><li class='category-heading' data-category='Views/Maps'>Views/Maps</li><li><a href="CesiumWidgetView.html">CesiumWidgetView</a></li><li><a href="DrawTool.html">DrawTool</a></li><li><a href="FeatureInfoView.html">FeatureInfoView</a></li><li><a href="LayerCategoryItemView.html">LayerCategoryItemView</a></li><li><a href="LayerCategoryListView.html">LayerCategoryListView</a></li><li><a href="LayerDetailView.html">LayerDetailView</a></li><li><a href="LayerDetailsView.html">LayerDetailsView</a></li><li><a href="LayerInfoView.html">LayerInfoView</a></li><li><a href="LayerItemView.html">LayerItemView</a></li><li><a href="LayerListView.html">LayerListView</a></li><li><a href="LayerNavigationView.html">LayerNavigationView</a></li><li><a href="LayerOpacityView.html">LayerOpacityView</a></li><li><a href="LayersPanelView.html">LayersPanelView</a></li><li><a href="LegendView.html">LegendView</a></li><li><a href="MapHelpPanel.html">MapHelpPanel</a></li><li><a href="MapView.html">MapView</a></li><li><a href="PredictionView.html">PredictionView</a></li><li><a href="PredictionsListView.html">PredictionsListView</a></li><li><a href="ScaleBarView.html">ScaleBarView</a></li><li><a href="SearchInputView.html">SearchInputView</a></li><li><a href="ToolbarView.html">ToolbarView</a></li><li><a href="ViewfinderView.html">ViewfinderView</a></li><li class='category-heading' data-category='Views/Metadata'>Views/Metadata</li><li><a href="EML211EditorView.html">EML211EditorView</a></li><li><a href="EMLAttributeView.html">EMLAttributeView</a></li><li><a href="EMLEntityView.html">EMLEntityView</a></li><li><a href="EMLMeasurementScaleView.html">EMLMeasurementScaleView</a></li><li><a href="EMLMeasurementTypeView.html">EMLMeasurementTypeView</a></li><li><a href="EMLMethodsView.html">EMLMethodsView</a></li><li><a href="EMLMissingValueCodeView.html">EMLMissingValueCodeView</a></li><li><a href="EMLMissingValueCodesView.html">EMLMissingValueCodesView</a></li><li><a href="EMLOtherEntityView.html">EMLOtherEntityView</a></li><li><a href="EMLPartyView.html">EMLPartyView</a></li><li><a href="EMLTempCoverageView.html">EMLTempCoverageView</a></li><li><a href="EMLView.html">EMLView</a></li><li><a href="EMlGeoCoverageView_.html">EMlGeoCoverageView</a></li><li><a href="ScienceMetadataView.html">ScienceMetadataView</a></li><li class='category-heading' data-category='Views/Portals'>Views/Portals</li><li><a href="PortalDataView.html">PortalDataView</a></li><li><a href="PortalHeaderView.html">PortalHeaderView</a></li><li><a href="PortalListView.html">PortalListView</a></li><li><a href="PortalLogosView.html">PortalLogosView</a></li><li><a href="PortalMembersView.html">PortalMembersView</a></li><li><a href="PortalSectionView.html">PortalSectionView</a></li><li><a href="PortalUsagesView.html">PortalUsagesView</a></li><li><a href="PortalView.html">PortalView</a></li><li><a href="PortalVisualizationsView.html">PortalVisualizationsView</a></li><li><a href="PortalsSearchView.html">PortalsSearchView</a></li><li class='category-heading' data-category='Views/Portals/Editor'>Views/Portals/Editor</li><li><a href="PortEditorDataView.html">PortEditorDataView</a></li><li><a href="PortEditorImageView.html">PortEditorImageView</a></li><li><a href="PortEditorLogosView.html">PortEditorLogosView</a></li><li><a href="PortEditorMdSectionView.html">PortEditorMdSectionView</a></li><li><a href="PortEditorSectionView.html">PortEditorSectionView</a></li><li><a href="PortEditorSectionsView.html">PortEditorSectionsView</a></li><li><a href="PortEditorSettingsView.html">PortEditorSettingsView</a></li><li><a href="PortalEditorView.html">PortalEditorView</a></li><li class='category-heading' data-category='Views/Projects'>Views/Projects</li><li><a href="ProjectView.html">ProjectView</a></li><li class='category-heading' data-category='Views/QueryBuilder'>Views/QueryBuilder</li><li><a href="QueryBuilderView.html">QueryBuilderView</a></li><li><a href="QueryRuleView.html">QueryRuleView</a></li><li class='category-heading' data-category='Views/Search'>Views/Search</li><li><a href="SearchResultsPagerView.html">SearchResultsPagerView</a></li><li><a href="SearchResultsView.html">SearchResultsView</a></li><li><a href="SorterView.html">SorterView</a></li><li class='category-heading' data-category='Views/SearchSelect'>Views/SearchSelect</li><li><a href="AccountSelectView.html">AccountSelectView</a></li><li><a href="AnnotationFilter.html">AnnotationFilter</a></li><li><a href="NodeSelect.html">NodeSelect</a></li><li><a href="ObjectFormatSelect.html">ObjectFormatSelect</a></li><li><a href="QueryFieldSelectView.html">QueryFieldSelectView</a></li><li><a href="SearchableSelectView.html">SearchableSelectView</a></li><li class='category-heading' data-category='Deprecated'>Deprecated</li><li><a href="AnnotatorView.html">AnnotatorView</a></li><li><a href="ExternalView.html">ExternalView</a></li><li><a href="LogsSearch.html">LogsSearch</a></li></ul><h3>Global</h3><ul><li><a href="global.html#appConfigPath">appConfigPath</a></li><li><a href="global.html#autocompleteSearch">autocompleteSearch</a></li><li><a href="global.html#blur">blur</a></li><li><a href="global.html#className">className</a></li><li><a href="global.html#classNames">classNames</a></li><li><a href="global.html#classificationsAreEqual">classificationsAreEqual</a></li><li><a href="global.html#clear">clear</a></li><li><a href="global.html#clearError">clearError</a></li><li><a href="global.html#couldBeLatLong">couldBeLatLong</a></li><li><a href="global.html#decrementFocusIndex">decrementFocusIndex</a></li><li><a href="global.html#defaults">defaults</a></li><li><a href="global.html#distLocations">distLocations</a></li><li><a href="global.html#events">events</a></li><li><a href="global.html#focus">focus</a></li><li><a href="global.html#focusInput">focusInput</a></li><li><a href="global.html#getCancelButtonContainer">getCancelButtonContainer</a></li><li><a href="global.html#getError">getError</a></li><li><a href="global.html#getInput">getInput</a></li><li><a href="global.html#getInputField">getInputField</a></li><li><a href="global.html#getInputValue">getInputValue</a></li><li><a href="global.html#getList">getList</a></li><li><a href="global.html#getSearchButton">getSearchButton</a></li><li><a href="global.html#getSearchInput">getSearchInput</a></li><li><a href="global.html#goToLocation">goToLocation</a></li><li><a href="global.html#hasValuesForDistributionLocation">hasValuesForDistributionLocation</a></li><li><a href="global.html#hideCancelAndDimSearch">hideCancelAndDimSearch</a></li><li><a href="global.html#hidePredictionsList">hidePredictionsList</a></li><li><a href="global.html#incrementFocusIndex">incrementFocusIndex</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#isDuplicate">isDuplicate</a></li><li><a href="global.html#keydown">keydown</a></li><li><a href="global.html#keyup">keyup</a></li><li><a href="global.html#offlineNodes">offlineNodes</a></li><li><a href="global.html#onBlur">onBlur</a></li><li><a href="global.html#onCancel">onCancel</a></li><li><a href="global.html#onFocus">onFocus</a></li><li><a href="global.html#onKeydown">onKeydown</a></li><li><a href="global.html#onKeyup">onKeyup</a></li><li><a href="global.html#onSearch">onSearch</a></li><li><a href="global.html#onlineNodes">onlineNodes</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#removeDuplicateClassifications">removeDuplicateClassifications</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#renderPredictionsList">renderPredictionsList</a></li><li><a href="global.html#renderSearchInput">renderSearchInput</a></li><li><a href="global.html#resetFocusIndex">resetFocusIndex</a></li><li><a href="global.html#search">search</a></li><li><a href="global.html#select">select</a></li><li><a href="global.html#selectPrediction">selectPrediction</a></li><li><a href="global.html#serialize">serialize</a></li><li><a href="global.html#setError">setError</a></li><li><a href="global.html#setInputValue">setInputValue</a></li><li><a href="global.html#setQuery">setQuery</a></li><li><a href="global.html#setupListeners">setupListeners</a></li><li><a href="global.html#showCancelAndSearch">showCancelAndSearch</a></li><li><a href="global.html#showPredictionsList">showPredictionsList</a></li><li><a href="global.html#tagName">tagName</a></li><li><a href="global.html#taxonomicClassification">taxonomicClassification</a></li><li><a href="global.html#templateVars">templateVars</a></li><li><a href="global.html#type">type</a></li><li><a href="global.html#urlFunctionTypes">urlFunctionTypes</a></li></ul>
</nav>

<div id="main">

    <h1 class="page-title">Source: src/js/views/maps/CesiumWidgetView.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

define([
  "jquery",
  "underscore",
  "backbone",
  "cesium",
  "models/maps/Map",
  "models/maps/assets/MapAsset",
  "models/maps/assets/Cesium3DTileset",
  "models/maps/Feature",
  "text!templates/maps/cesium-widget-view.html",
], function (
  $,
  _,
  Backbone,
  Cesium,
  Map,
  MapAsset,
  Cesium3DTileset,
  Feature,
  Template
) {
  /**
   * @class CesiumWidgetView
   * @classdesc An interactive 2D and/or 3D map/globe rendered using CesiumJS.
   * This view comprises the globe without any of the UI elements like the
   * scalebar, layer list, etc.
   * @classcategory Views/Maps
   * @name CesiumWidgetView
   * @extends Backbone.View
   * @screenshot views/maps/CesiumWidgetView.png
   * @since 2.18.0
   * @constructs
   * @fires MapInteraction#moved
   * @fires MapInteraction#moveEnd
   * @fires MapInteraction#moveStart
   */
  var CesiumWidgetView = Backbone.View.extend(
    /** @lends CesiumWidgetView.prototype */ {
      /**
       * The type of View this is
       * @type {string}
       */
      type: "CesiumWidgetView",

      /**
       * The HTML classes to use for this view's element. Note that the first
       * child element added to this view by cesium will have the class
       * "cesium-widget".
       * @type {string}
       */
      className: "cesium-widget-view",

      /**
       * The model that this view uses
       * @type {Map}
       */
      model: null,

      /**
       * The primary HTML template for this view
       * @type {Underscore.template}
       */
      template: _.template(Template),

      /**
       * An array of objects the match a Map Asset's type property to the
       * function in this view that adds and renders that asset on the map,
       * given the Map Asset model. Each object in the array has two properties:
       * 'types' and 'renderFunction'.
       * @type {Object[]}
       * @property {string[]} types The list of types that can be added to the
       * map given the renderFunction
       * @property {string} renderFunction The name of the function in the view
       * that will add the asset to the map and render it, when passed the
       * cesiumModel attribute from the MapAsset model
       * @property {string} removeFunction The name of the function in the view
       * that will remove the asset from the map, when passed the cesiumModel
       * attribute from the MapAsset model
       */
      mapAssetRenderFunctions: [
        {
          types: ["Cesium3DTileset"],
          renderFunction: "add3DTileset",
          removeFunction: "remove3DTileset",
        },
        {
          types: ["GeoJsonDataSource", "CzmlDataSource", "CustomDataSource"],
          renderFunction: "addVectorData",
          removeFunction: "removeVectorData",
        },
        {
          types: [
            "BingMapsImageryProvider",
            "IonImageryProvider",
            "TileMapServiceImageryProvider",
            "WebMapTileServiceImageryProvider",
            "WebMapServiceImageryProvider",
            "OpenStreetMapImageryProvider",
          ],
          renderFunction: "addImagery",
          removeFunction: "removeImagery",
        },
        {
          types: ["CesiumTerrainProvider"],
          renderFunction: "updateTerrain",
          removeFunction: null,
        },
      ],

      /**
       * The border color to use on vector features that a user clicks. See
       * {@link https://cesium.com/learn/cesiumjs/ref-doc/Color.html?classFilter=color}
       * @type {Cesium.Color}
       */
      // TODO - Make this color configurable in the Map model
      highlightBorderColor: Cesium.Color.WHITE,

      /**
       * Executed when a new CesiumWidgetView is created
       * @param {Object} [options] - A literal object with options to pass to
       * the view
       */
      initialize: function (options) {
        try {
          // Set the Cesium Ion token (required for some map features)
          Cesium.Ion.defaultAccessToken = MetacatUI.appModel.get("cesiumToken");

          // Get all the options and apply them to this view
          if (typeof options == "object") {
            for (const [key, value] of Object.entries(options)) {
              this[key] = value;
            }
          }

          if (!this.model) {
            this.model = new Map();
          }
          if (!this.model.get("interactions")) {
            this.model.setUpInteractions();
          }
          this.interactions = this.model.get("interactions");
          // The selectedFeature attribute is used to store information about
          // the vector feature, if any, that is currently in focus on the map.
          if (!this.interactions.get("selectedFeatures")) {
            this.interactions.selectFeatures();
          }
        } catch (e) {
          console.log("Failed to initialize a CesiumWidgetView. ", e);
        }
      },

      /**
       * Renders this view
       * @return {CesiumWidgetView} Returns the rendered view element
       */
      render: function () {
        try {
          // If Cesium features are disabled in the AppConfig, then exit without
          // rendering anything.
          if (!MetacatUI.appModel.get("enableCesium")) {
            return;
          }

          // Save a reference to this view
          const view = this;

          // Insert the template into the view
          view.$el.html(view.template({}));

          // Create the Cesium Widget
          view.renderWidget();

          // Configure the lighting on the globe
          view.setLighting();

          // Prepare Cesium to handle vector datasources (e.g.
          // geoJsonDataSources)
          view.setUpDataSourceDisplay();

          // Listeners for changes &amp; events to the layers &amp; map
          view.setAssetListeners();
          view.setNavigationListeners();
          // Listen to Cesium screen space events and update Interactions model
          view.setCameraListeners();
          view.setMouseListeners();
          // Listen to Interactions model and react when e.g. something is
          // clicked
          view.setInteractionListeners();

          // Render the layers
          view.addLayers();

          // Go to the home position, if one is set.
          view.flyHome(0);

          // Set the map up so that selected features may be highlighted
          view.setUpSilhouettes();

          return this;
        } catch (e) {
          console.log("Failed to render a CesiumWidgetView,", e);
          // TODO: Render a fallback map or error message
        }
      },

      /**
       * Create the Cesium Widget and save a reference to it to the view
       * @since 2.27.0
       * @returns {Cesium.CesiumWidget} The Cesium Widget
       */
      renderWidget: function () {
        const view = this;
        // Clock for timeline component &amp; updating data sources
        view.clock = new Cesium.Clock({ shouldAnimate: false });

        // Create the Cesium Widget and save a reference to it to the view
        view.widget = new Cesium.CesiumWidget(view.el, {
          clock: view.clock,
          // We will add a base imagery layer after initialization
          imageryProvider: false,
          terrain: false,
          useBrowserRecommendedResolution: false,
          // Use explicit rendering to make the widget must faster. See
          // https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance
          requestRenderMode: true,
          // Need to change the following once we support a time/clock
          // component. See
          // https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/#handling-simulation-time-changes.
          maximumRenderTimeChange: Infinity,
        });

        // Save references to parts of  widget the view will access often
        view.scene = view.widget.scene;
        view.camera = view.widget.camera;

        return view.widget;
      },

      /**
       * Create a DataSourceDisplay and DataSourceCollection for the Cesium
       * widget. This is required to display vector data (e.g. GeoJSON) on the
       * map.
       * @since 2.27.0
       * @returns {Cesium.DataSourceDisplay} The Cesium DataSourceDisplay
       */
      setUpDataSourceDisplay: function () {
        const view = this;
        view.dataSourceCollection = new Cesium.DataSourceCollection();
        view.dataSourceDisplay = new Cesium.DataSourceDisplay({
          scene: view.scene,
          dataSourceCollection: view.dataSourceCollection,
        });
        return view.dataSourceDisplay;
      },

      /**
       * Because the Cesium widget is configured to use explicit rendering (see
       * {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/}),
       * we need to tell Cesium when to render a new frame if it's not one of
       * the cases handle automatically. This function tells the Cesium scene to
       * render, but is limited by the underscore.js debounce function to only
       * happen a maximum of once every 50 ms (see
       * {@link https://underscorejs.org/#debounce}).
       */
      requestRender: _.debounce(function () {
        this.scene.requestRender();
      }, 90),

      /**
       * Functions called after each time the scene renders. If a zoom target
       * has been set by the {@link CesiumWidgetView#flyTo} function, then calls
       * the functions that calculates the bounding sphere and zooms to it
       * (which required to visual elements to be rendered first.)
       */
      postRender: function () {
        try {
          const view = this;
          if (view.zoomTarget) {
            view.completeFlight(view.zoomTarget, view.zoomOptions);
          }
        } catch (e) {
          console.log("Error calling post render functions:", e);
        }
      },

      /**
       * Run the update method and all visualizers for each data source.
       * @return {boolean} Returns true if all data sources are ready to be
       * displayed.
       * @since 2.27.0
       */
      updateAllDataSources: function () {
        const view = this;
        const dataSources = view.dataSourceDisplay.dataSources;
        if (!dataSources || !dataSources.length) {
          return;
        }
        const time = view.clock.currentTime;
        let displayReady = true;
        for (let i = 0; i &lt; dataSources.length; i++) {
          const dataSource = dataSources.get(i);
          dataSource.update(view.clock.currentTime);
          // for each visualizer, update it
          dataSource._visualizers.forEach(function (visualizer) {
            displayReady = displayReady &amp;&amp; visualizer.update(time);
          });
        }
        view.dataSourceDisplay._ready = displayReady;
        return displayReady;
      },

      /**
       * Configure the lighting on the globe.
       */
      setLighting: function () {
        const view = this;
        // Disable HDR lighting for better performance &amp; to keep imagery
        // consistently lit.
        view.scene.highDynamicRange = false;
        view.scene.globe.enableLighting = false;

        // Keep all parts of the globe lit regardless of what time the Cesium
        // clock is set to. This avoids data and imagery appearing too dark.
        view.scene.light = new Cesium.DirectionalLight({
          direction: new Cesium.Cartesian3(1, 0, 0),
        });
        view.scene.preRender.addEventListener(function (scene, time) {
          view.scene.light.direction = Cesium.Cartesian3.clone(
            scene.camera.directionWC,
            view.scene.light.direction
          );
        });
      },

      /**
       * Set up the Cesium scene and set listeners and behavior that enable
       * users to click on vector features on the map to highlight them.
       * @since 2.27.0
       */
      setUpSilhouettes: function () {
        try {
          // Save a reference to this view the Cesium scene
          var view = this;
          var scene = this.scene;

          // To add an outline to 3D tiles in Cesium, we 'silhouette' them. Set
          // up the the scene to support silhouetting.
          view.silhouettes =
            Cesium.PostProcessStageLibrary.createEdgeDetectionStage();
          view.silhouettes.uniforms.color = view.highlightBorderColor;
          view.silhouettes.uniforms.length = 0.02;
          view.silhouettes.selected = [];
          scene.postProcessStages.add(
            Cesium.PostProcessStageLibrary.createSilhouetteStage([
              view.silhouettes,
            ])
          );
        } catch (e) {
          console.log("Error initializing picking in a CesiumWidgetView", e);
        }
      },

      /**
       * Listen for changes to the assets and update the map accordingly.
       * @since 2.27.0
       */
      setAssetListeners: function () {
        const view = this;
        const model = view.model;
        const layerGroups = model.getLayerGroups();

        // Listen for addition or removal of layers TODO: Add similar listeners
        // for terrain
        _.each(layerGroups, layers => {
          if (layers) {
            view.stopListening(layers);
            view.listenTo(layers, "add", view.addAsset);
            view.listenTo(layers, "remove", view.removeAsset);

            // Each layer fires 'appearanceChanged' whenever the color, opacity,
            // etc. has been updated. Re-render the scene when this happens.
            view.listenTo(layers, "appearanceChanged", view.requestRender);
          }
        })
        // Reset asset listeners if the layers collection is replaced
        view.stopListening(model, "change:layers change:layerCategories");
        view.listenTo(model, "change:layers change:layerCategories", view.setAssetListeners);
      },

      /**
       * Remove listeners for dynamic navigation.
       * @since 2.27.0
       */
      removeNavigationListeners: function () {
        this.stopListening(this.interactions, "change:zoomTarget", this.flyTo);
        if (this.removePostRenderListener) this.removePostRenderListener();
      },

      /**
       * Set up listeners to allow for dynamic navigation. This includes zooming
       * to the extent of a layer and zooming to the home position. Note that
       * other views may trigger an event on the layer/asset model that
       * indicates that the map should navigate to a given extent.
       * @since 2.27.0
       */
      setNavigationListeners: function () {
        this.removeNavigationListeners();
        // Zoom functions executed after each scene render
        this.removePostRenderListener = this.scene.postRender.addEventListener(
          this.postRender,
          this
        );
        this.listenTo(this.interactions, "change:zoomTarget", function () {
          const target = this.interactions.get("zoomTarget");
          if (target) {
            this.flyTo(target);
          }
        });
      },

      /**
       * Remove any previously set camera listeners.
       * @since 2.27.0
       */
      removeCameraListeners: function () {
        if (!this.cameraListeners) this.cameraListeners = [];
        this.cameraListeners.forEach(function (removeListener) {
          removeListener();
        });
      },

      /**
       * Listen to cesium camera events, and translate them to events on the
       * interactions model. Also update the scale (pixels:meters) and the view
       * extent when the camera has moved.
       */
      setCameraListeners: function () {
        try {
          const view = this;
          const camera = view.camera;
          const interactions = view.interactions;

          // Remove any previously set camera listeners
          view.removeCameraListeners();
          // Amount camera must change before firing 'changed' event.
          camera.percentChanged = 0.1;

          // Functions to run for each Cesium camera event
          const cameraEvents = {
            moveEnd: [],
            moveStart: [],
            changed: ["updateScale", "updateViewExtent"],
          };
          // add a listener that triggers the same event on the interactions
          // model, and runs any functions configured above.
          Object.entries(cameraEvents).forEach(function ([label, functions]) {
            const callback = function () {
              // Rename because 'changed' is too similar to the Backbone event
              const eventName = label === "changed" ? "cameraChanged" : label;
              interactions.trigger(eventName);
              functions.forEach(function (func) {
                view[func].call(view);
              });
            };
            const remover = camera[label].addEventListener(callback, view);
            view.cameraListeners.push(remover);
          });
        } catch (e) {
          console.log("Error updating the model on camera events", e);
        }
      },

      /**
       * Remove any previously set mouse listeners.
       * @since 2.27.0
       */
      removeMouseListeners: function () {
        if (this.mouseEventHandler) this.mouseEventHandler.destroy();
      },

      /**
       * Set up listeners for mouse events on the map. This includes listening
       * for mouse clicks, mouse movement, and mouse hovering over features.
       * These listeners simply update the interactions model with mouse events.
       * @since 2.27.0
       */
      setMouseListeners: function () {
        const view = this;
        const events = Cesium.ScreenSpaceEventType;

        // Remove previous listeners if they exist.
        view.removeMouseListeners;
        // Create Cesium object that handles interactions with the map.
        const handler = (view.mouseEventHandler =
          new Cesium.ScreenSpaceEventHandler(view.scene.canvas));

        // Every time the user interacts with the map, update the interactions
        // model with the type of interaction that occurred.
        Object.entries(events).forEach(function ([label, value]) {
          handler.setInputAction(function (event) {
            view.interactions.set("previousAction", label);
            if (label == "MOUSE_MOVE") {
              const position = event.position || event.endPosition;
              view.setMousePosition(position);
              view.setHoveredFeatures(position);
            }
          }, value);
        });
      },

      /**
       * When the mouse is moved over the map, update the interactions model
       * with the current mouse position.
       * @param {Object} event - The event object from Cesium
       * @since 2.27.0
       */
      setMousePosition: function (position) {
        if (!position) return;
        const view = this;
        const pickRay = view.camera.getPickRay(position);
        const cartesian = view.scene.globe.pick(pickRay, view.scene);
        let newPosition = null;
        if (cartesian) {
          newPosition = view.getDegreesFromCartesian(cartesian);
          newPosition.mapWidgetCoords = cartesian;
        }
        view.interactions.setMousePosition(newPosition);
      },

      /**
       * Record the feature hovered over by the mouse based on position.
       * @param {Object} position - The position of the mouse on the map
       * @param {number} [delay=200] - The minimum number of milliseconds that
       * must pass between calls to this function.
       * @since 2.27.0
       */
      setHoveredFeatures: function (position, delay = 200) {
        const view = this;
        const lastCall = this.setHoveredFeaturesLastCall || 0;
        const now = new Date().getTime();
        if (now - lastCall &lt; delay) return;
        this.setHoveredFeaturesLastCall = now;
        const pickedFeature = view.scene.pick(position);
        view.interactions.setHoveredFeatures([pickedFeature]);
      },

      /**
       * React when the user interacts with the map.
       * @since 2.27.0
       */
      setInteractionListeners: function () {
        const interactions = this.interactions;
        const hoveredFeatures = interactions.get("hoveredFeatures");
        this.stopListening(hoveredFeatures, "change update");
        this.listenTo(hoveredFeatures, "change update", this.updateCursor);
      },

      /**
       * Change the cursor to a pointer when the mouse is hovering over a
       * feature.
       * @param {Object|null} hoveredFeatures - The feature that the mouse is
       * hovering over or null if the mouse is not hovering over a feature.
       */
      updateCursor: function (hoveredFeatures) {
        const view = this;
        let cursorStyle = "default";
        if (hoveredFeatures &amp;&amp; hoveredFeatures.length) {
          cursorStyle = "pointer";
        }
        view.el.style.cursor = cursorStyle;
      },

      /**
       * Highlight the features that are currently selected in the interactions
       * model.
       * @since 2.27.0
       */
      showSelectedFeatures: function () {
        // Remove highlights from previously selected 3D tiles
        view.silhouettes.selected = [];
        // Highlight the newly selected 3D tiles
        selectedFeatures
          .getFeatureObjects("Cesium3DTileFeature")
          .forEach(function (featureObject) {
            view.silhouettes.selected.push(featureObject);
          });
      },

      /**
       * Add all of the model's layers to the map. This function is called
       * during the render function.
       * @since 2.26.0
       */
      addLayers: function () {
        const view = this;

        // Add each layer from the Map model to the Cesium widget. Render using
        // the function configured in the View's mapAssetRenderFunctions
        // property. Add in reverse order for layers to appear in the correct
        // order on the map.
        const layerGroups = view.model.getLayerGroups();
        for (const layers of layerGroups) {
          if (layers &amp;&amp; layers.length) {
            const layersReverse = layers.last(layers.length).reverse();
            layersReverse.forEach(function (layer) {
              view.addAsset(layer);
            });
          }
        }

        // The Cesium Widget will support just one terrain option to start.
        // Later, we'll allow users to switch between terrains if there is more
        // than one.
        var terrains = view.model.get("terrains");
        var terrainModel = terrains ? terrains.first() : false;
        if (terrainModel) {
          view.addAsset(terrainModel);
        }
      },

      /**
       * Move the camera position and zoom to the specified target entity or
       * position on the map, using a nice animation. This function starts the
       * flying/zooming action by setting a zoomTarget and zoomOptions on the
       * view and requesting the scene to render. The actual zooming is done by
       * {@link CesiumWidgetView#completeFlight} after the scene has finished
       * rendering.
       * @param {MapAsset|Cesium.BoundingSphere|Object|Feature} target The
       * target asset, bounding sphere, or location to change the camera focus
       * to. If target is a MapAsset, then the bounding sphere from that asset
       * will be used for the target destination. If target is an Object, it may
       * contain any of the properties that are supported by the Cesium camera
       * flyTo options, see
       * {@link https://cesium.com/learn/cesiumjs/ref-doc/Camera.html#flyTo}. If
       * the target is a Feature, then it must be a Feature of a
       * CesiumVectorData layer (currently Cesium3DTileFeatures are not
       * supported). The target can otherwise be a Cesium BoundingSphere, see
       * {@link https://cesium.com/learn/cesiumjs/ref-doc/BoundingSphere.html}
       * @param {object} options - For targets that are a bounding sphere or
       * asset, options to pass to Cesium Camera.flyToBoundingSphere(). See
       * {@link https://cesium.com/learn/cesiumjs/ref-doc/Camera.html#flyToBoundingSphere}.
       */
      flyTo: function (target, options) {
        this.zoomTarget = target;
        this.zoomOptions = options;
        this.requestRender();
      },

      /**
       * This function is called by {@link CesiumWidgetView#postRender}; it
       * should only be called once the target has been fully rendered in the
       * scene. This function gets the bounding sphere, if required, and moves
       * the scene to encompass the full extent of the target.
       * @param {MapAsset|Cesium.BoundingSphere|Object|Feature|GeoPoint} target
       * The target asset, bounding sphere, or location to change the camera
       * focus to. If target is a MapAsset, then the bounding sphere from that
       * asset will be used for the target destination. If target is an Object,
       * it may contain any of the properties that are supported by the Cesium
       * camera flyTo options, see
       * {@link https://cesium.com/learn/cesiumjs/ref-doc/Camera.html#flyTo}.
       * The object may also be a position with longitude, latitude, and height.
       * If the target is a Feature, then it must be a Feature of a
       * CesiumVectorData layer (currently Cesium3DTileFeatures are not
       * supported). The target can otherwise be a Cesium BoundingSphere, see
       * {@link https://cesium.com/learn/cesiumjs/ref-doc/BoundingSphere.html}
       * @param {object} options - For targets that are a bounding sphere or
       * asset, options to pass to Cesium Camera.flyToBoundingSphere(). See
       * {@link https://cesium.com/learn/cesiumjs/ref-doc/Camera.html#flyToBoundingSphere}.
       * For other targets, options will be merged with the target object and
       * passed to Cesium Camera.flyTo(). See
       * {@link https://cesium.com/learn/cesiumjs/ref-doc/Camera.html#flyTo}
       */
      completeFlight: function (target, options) {
        try {

          // A target is required
          if (!target) return;

          const view = this;
          if (typeof options !== "object") options = {};
          view.resetZoomTarget();

          // If the target is a Bounding Sphere, use the camera's built-in
          // function
          if (target instanceof Cesium.BoundingSphere) {
            view.camera.flyToBoundingSphere(target, options);
            return;
          }

          // If the target is some type of map asset, then get a Bounding Sphere
          // for that asset and call this function again.
          if (
            target instanceof MapAsset &amp;&amp;
            typeof target.getBoundingSphere === "function"
          ) {
            // Pass the dataSourceDisplay for CesiumVectorData models
            target
              .getBoundingSphere(view.dataSourceDisplay)
              .then(function (assetBoundingSphere) {
                // Base value offset required to zoom in close enough to 3D
                // tiles for them to render.
                if (
                  target instanceof Cesium3DTileset &amp;&amp;
                  !Cesium.defined(options.offset)
                ) {
                  options.offset = new Cesium.HeadingPitchRange(
                    0.0,
                    -0.5,
                    assetBoundingSphere.radius
                  );
                }
                view.flyTo(assetBoundingSphere, options);
              });
            return;
          }

          // Note: This doesn't work yet for Cesium3DTilesetFeatures -
          // Cesium.BoundingSphereState gets stuck in "PENDING" and never
          // resolves. There's no native way of getting the bounding sphere or
          // location from a 3DTileFeature!
          if (target instanceof Feature) {
            // If the object saved in the Feature is an Entity, then this
            // function will get the bounding sphere for the entity on the next
            // run.
            // check if the layer is displayReady
            const layer = target.get("mapAsset");
            const displayReady = layer.get("displayReady");
            if (!displayReady) {
              // Must wait for layer to be rendered in via the dataSourceDisplay
              // before we can get the bounding sphere for the feature.
              view.listenToOnce(layer, "change:displayReady", function () {
                view.flyTo(target, options);
              });
              return
            }
            view.flyTo(target.get("featureObject"), options);
            return;
          }

          // If the target is a Cesium Entity, then get the bounding sphere for
          // the entity and call this function again.
          const entity = target instanceof Cesium.Entity ? target : target.id;

          if (entity instanceof Cesium.Entity) {

            view.dataSourceDisplay._ready = true
            view.getBoundingSphereFromEntity(entity).then(function (entityBoundingSphere) {
              view.flyTo(entityBoundingSphere, options);
            });
            return;
          }

          if (target.type &amp;&amp; target.type == "GeoPoint") {
            view.flyTo(target.toJSON(), options);
            return;
          }

          if (
            typeof target === "object" &amp;&amp;
            typeof target.longitude === "number" &amp;&amp;
            typeof target.latitude === "number"
          ) {
            const pointTarget = view.positionToFlightTarget(target);
            view.flyTo(pointTarget, options);
            return;
          }

          // If not a Map Asset or a BoundingSphere, then the target must be an
          // Object. Assume target are options for the Cesium camera flyTo
          // function
          if (typeof target === "object") {
            // Merge the options with the target object, if there are any
            // options
            if (options &amp;&amp; Object.keys(options).length) {
              target = Object.assign(target, options);
            }
            // Fly to the target
            view.camera.flyTo(target);
            view.resetZoomTarget();
          }
        } catch (e) {
          console.log("Failed to navigate to a target in Cesium.", e);
        }
      },

      getBoundingSphereFromEntity: function (entity) {
        const view = this
        const entityBoundingSphere = new Cesium.BoundingSphere();
        const readyState = Cesium.BoundingSphereState.DONE;
        function getBS() {
          return view.dataSourceDisplay.getBoundingSphere(
            entity,
            false,
            entityBoundingSphere
          );
        }
        // Return a promise that resolves to bounding box when it's ready.
        // Keep running getBS at intervals until it's ready.
        return new Promise(function (resolve, reject) {
          let attempts = 0;
          const maxAttempts = 100;
          const interval = setInterval(function () {
            attempts++;
            const state = getBS();
            if (state !== readyState) {
              // Search for the entity again in case it was removed and
              // re-added to the data source display.
              entity = view.getEntityById(entity.id, entity.entityCollection);
              if(!entity) {
                clearInterval(interval);
                reject("Failed to get bounding sphere for entity, entity not found.");
              }

            } else {
              clearInterval(interval);
              resolve(entityBoundingSphere);
            }
            if (attempts >= maxAttempts) {
              clearInterval(interval);
              reject("Failed to get bounding sphere for entity.");
            }
          }, 100);
        })
      },

      /**
       * Search an entity collection for an entity with a given id.
       * @param {string} id - The id of the entity to find.
       * @param {Cesium.EntityCollection} collection - The collection to search.
       * @returns {Cesium.Entity} The entity with the given id, or null if no
       * entity with that id exists in the collection.
       * @since 2.27.0
       */
      getEntityById: function (id, collection) {
        const entities = collection.values;
        for (let i = 0; i &lt; entities.length; i++) {
          const entity = entities[i];
          if (entity.id === id) {
            return entity;
          }
        }
        return null;
      },

      resetZoomTarget: function () {
        const view = this;
        view.zoomTarget = null;
        view.interactions.set("zoomTarget", null);
        view.zoomOptions = null;
      },

      /**
       * Navigate to the homePosition that's set on the Map.
       * @param {number} duration The duration of the flight in seconds.
       */
      flyHome: function (duration) {
        const home = this.model.get("homePosition");
        this.flyTo(home, { duration });
      },

      /**
       * Navigate to the homePosition that's set on the Map.
       * @param {Object} position The position to navigate to. Must have
       * longitude, latitude, and may have a height (elevation) in meters,
       * heading, pitch, and roll in degrees.
       * @param {number} duration The duration of the flight in seconds.
       */
      positionToFlightTarget: function (position, duration) {
        try {
          if (!position) {
            return null;
          }

          if (
            position &amp;&amp;
            Cesium.defined(position.longitude) &amp;&amp;
            Cesium.defined(position.latitude)
          ) {
            // Set a default height (elevation) if there isn't one set
            if (!Cesium.defined(position.height)) {
              position.height = 1000000;
            }

            const target = {};
            target.destination = Cesium.Cartesian3.fromDegrees(
              position.longitude,
              position.latitude,
              position.height
            );

            if (
              Cesium.defined(position.heading) &amp;&amp;
              Cesium.defined(position.pitch) &amp;&amp;
              Cesium.defined(position.roll)
            ) {
              target.orientation = {
                heading: Cesium.Math.toRadians(position.heading),
                pitch: Cesium.Math.toRadians(position.pitch),
                roll: Cesium.Math.toRadians(position.roll),
              };
            }
            if (Cesium.defined(duration)) {
              target.duration = duration;
            }

            return target;
          }
        } catch (e) {
          console.log("Failed to convert a position to a flight target.", e);
          return null;
        }
      },

      /**
       * Get the current positioning of the camera in the view.
       * @returns {MapConfig#CameraPosition} Returns an object with the
       * longitude, latitude, height, heading, pitch, and roll in the same
       * format that the Map model uses for the homePosition (see
       * {@link Map#defaults})
       */
      getCameraPosition: function () {
        return this.getDegreesFromCartesian(this.camera.position);
      },

      /**
       * Update the 'currentViewExtent' attribute in the Map model with the
       * bounding box of the currently visible area of the map.
       */
      updateViewExtent: function () {
        try {
          this.interactions.setViewExtent(this.getViewExtent());
        } catch (e) {
          console.log("Failed to update the Map view extent.", e);
        }
      },

      /**
       * Get the north, south, east, and west-most lat/long that define a
       * bounding box around the currently visible area of the map. Also gives
       * the height/ altitude of the camera in meters.
       * @returns {MapConfig#ViewExtent} The current view extent.
       */
      getViewExtent: function () {
        const view = this;
        const scene = view.scene;
        const camera = view.camera;
        // Get the height in meters
        const height = camera.positionCartographic.height;

        // This will be the bounding box of the visible area
        let coords = {
          north: null,
          south: null,
          east: null,
          west: null,
          height: height,
        };

        // First try getting the visible bounding box using the simple method
        if (!view.scratchRectangle) {
          // Store the rectangle that we use for the calculation (reduces
          // pressure on garbage collector system since this function is called
          // often).
          view.scratchRectangle = new Cesium.Rectangle();
        }
        var rect = camera.computeViewRectangle(
          scene.globe.ellipsoid,
          view.scratchRectangle
        );
        coords.north = Cesium.Math.toDegrees(rect.north);
        coords.east = Cesium.Math.toDegrees(rect.east);
        coords.south = Cesium.Math.toDegrees(rect.south);
        coords.west = Cesium.Math.toDegrees(rect.west);

        // Check if the resulting coordinates cover the entire globe (happens if
        // some of the sky is visible). If so, limit the bounding box to a
        // smaller extent
        if (view.coversGlobe(coords)) {
          // Find points at the top, bottom, right, and left corners of the
          // globe
          const edges = view.findEdges();

          // Get the midPoint between the top and bottom points on the globe.
          // Use this to decide if the northern or southern hemisphere is more
          // in view.
          let midPoint = view.findMidpoint(edges.top, edges.bottom);
          if (midPoint) {
            // Get the latitude of the mid point
            const midPointLat = view.getDegreesFromCartesian(midPoint).latitude;

            // Get the latitudes of all the edge points so that we can calculate
            // the southern and northern most coordinate
            const edgeLatitudes = [];
            Object.values(edges).forEach(function (point) {
              if (point) {
                edgeLatitudes.push(
                  view.getDegreesFromCartesian(point).latitude
                );
              }
            });

            if (midPointLat > 0) {
              // If the midPoint is in the northern hemisphere, limit the
              // southern part of the bounding box to the southern most edge
              // point latitude
              coords.south = Math.min(...edgeLatitudes);
            } else {
              // Vice versa for the southern hemisphere
              coords.north = Math.max(...edgeLatitudes);
            }
          }

          // If not focused directly on one of the poles, then also limit the
          // east and west sides of the bounding box
          const northPointLat = view.getDegreesFromCartesian(
            edges.top
          ).latitude;
          const southPointLat = view.getDegreesFromCartesian(
            edges.bottom
          ).latitude;

          if (northPointLat > 25 &amp;&amp; southPointLat &lt; -25) {
            if (edges.right) {
              coords.east = view.getDegreesFromCartesian(edges.right).longitude;
            }
            if (edges.left) {
              coords.west = view.getDegreesFromCartesian(edges.left).longitude;
            }
          }
        }

        return coords;
      },

      /**
       * Check if a given bounding box covers the entire globe.
       * @param {Object} coords - An object with the north, south, east, and
       * west coordinates of a bounding box
       * @param {Number} latAllowance - The number of degrees latitude to allow
       * as a buffer. If the north and south coords range from -90 to 90, minus
       * this buffer * 2, then it is considered to cover the globe.
       * @param {Number} lonAllowance - The number of degrees longitude to allow
       * as a buffer.
       * @returns {Boolean} Returns true if the bounding box covers the entire
       * globe, false otherwise.
       */
      coversGlobe: function (coords, latAllowance = 0.5, lonAllowance = 1) {
        const maxLat = 90 - latAllowance;
        const minLat = -90 + latAllowance;
        const maxLon = 180 - lonAllowance;
        const minLon = -180 + lonAllowance;

        return (
          coords.west &lt;= minLon &amp;&amp;
          coords.east >= maxLon &amp;&amp;
          coords.south &lt;= minLat &amp;&amp;
          coords.north >= maxLat
        );
      },

      /**
       * Get longitude and latitude degrees from a cartesian point.
       * @param {Cesium.Cartesian3} cartesian - The point to get degrees for
       * @returns Returns an object with the longitude and latitude in degrees,
       * as well as the height in meters
       */
      getDegreesFromCartesian: function (cartesian) {
        const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
        const degrees = {
          height: cartographic.height,
        };
        const coordinates = [
          "longitude",
          "latitude",
          "heading",
          "pitch",
          "roll",
        ];
        coordinates.forEach(function (coordinate) {
          if (Cesium.defined(cartographic[coordinate])) {
            degrees[coordinate] = Cesium.Math.toDegrees(
              cartographic[coordinate]
            );
          }
        });
        return degrees;
      },

      /**
       * Find four points that exist on the globe that are closest to the
       * top-center, bottom-center, right-middle, and left-middle points of the
       * screen. Note that these are not necessarily the northern, southern,
       * eastern, and western -most points, since the map may be oriented in any
       * direction (e.g. facing the north pole).
       *
       * @returns {Cesium.Cartesian3[]} Returns an object with the top, bottom,
       * left, and right points of the globe.
       */
      findEdges: function () {
        try {
          const view = this;
          const canvas = view.scene.canvas;
          const maxX = canvas.clientWidth;
          const maxY = canvas.clientHeight;
          const midX = (maxX / 2) | 0;
          const midY = (maxY / 2) | 0;

          // Points at the extreme edges of the cesium canvas. These may not be
          // points on the globe (i.e. they could be in the sky)
          const topCanvas = new Cesium.Cartesian2(midX, 0);
          const rightCanvas = new Cesium.Cartesian2(maxX, midY);
          const bottomCanvas = new Cesium.Cartesian2(midX, maxY);
          const leftCanvas = new Cesium.Cartesian2(0, midY);

          // Find the real world coordinate that is closest to the canvas edge
          // points
          const points = {
            top: view.findPointOnGlobe(topCanvas, bottomCanvas),
            right: view.findPointOnGlobe(rightCanvas, leftCanvas),
            bottom: view.findPointOnGlobe(bottomCanvas, topCanvas),
            left: view.findPointOnGlobe(leftCanvas, rightCanvas),
          };

          return points;
        } catch (error) {
          console.log(
            "There was an error finding the edge points in a CesiumWidgetView" +
              ". Error details: " +
              error
          );
        }
      },

      /**
       * Given two Cartesian3 points, compute the midpoint.
       * @param {Cesium.Cartesian3} p1  The first point
       * @param {Cesium.Cartesian3} p2  The second point
       * @returns {Cesium.Cartesian3 | null} The midpoint or null if p1 or p2 is
       * not defined.
       */
      findMidpoint: function (p1, p2) {
        try {
          if (!p1 || !p2) {
            return null;
          }
          // Compute vector from p1 to p2
          let p1p2 = new Cesium.Cartesian3(0.0, 0.0, 0.0);
          Cesium.Cartesian3.subtract(p2, p1, p1p2);

          // Compute vector to midpoint
          let halfp1p2 = new Cesium.Cartesian3(0.0, 0.0, 0.0);
          Cesium.Cartesian3.multiplyByScalar(p1p2, 0.5, halfp1p2);

          // Compute point half way between p1 and p2
          let p3 = new Cesium.Cartesian3(0.0, 0.0, 0.0);
          p3 = Cesium.Cartesian3.add(p1, halfp1p2, p3);

          // Force point onto surface of ellipsoid
          const midPt = Cesium.Cartographic.fromCartesian(p3);
          const p3a = Cesium.Cartesian3.fromRadians(
            midPt.longitude,
            midPt.latitude,
            0.0
          );

          return p3a;
        } catch (error) {
          console.log(
            "There was an error finding a midpoint in a CesiumWidgetView" +
              ". Error details: " +
              error
          );
        }
      },

      /**
       * Find a coordinate that exists on the surface of the globe between two
       * Cartesian points. The points do not need to be withing the bounds of
       * the globe/map (i.e. they can be points in the sky). Uses the Bresenham
       * Algorithm to traverse pixels from the first coordinate to the second,
       * until it finds a valid coordinate.
       * @param {Cesium.Cartesian2} startCoordinates The coordinates to start
       * searching, in pixels
       * @param {Cesium.Cartesian2} endCoordinates The coordinates to stop
       * searching, in pixels
       * @returns {Cesium.Cartesian3 | null} Returns the x, y, z coordinates of
       * the first real point, or null if a valid point was not found.
       *
       * @see {@link https://groups.google.com/g/cesium-dev/c/e2H7EefikAk}
       */
      findPointOnGlobe: function (startCoordinates, endCoordinates) {
        const view = this;
        const camera = view.camera;
        const ellipsoid = view.scene.globe.ellipsoid;

        if (!startCoordinates || !endCoordinates) {
          return null;
        }

        let coordinate = camera.pickEllipsoid(startCoordinates, ellipsoid);

        // Translate coordinates
        let x1 = startCoordinates.x;
        let y1 = startCoordinates.y;
        const x2 = endCoordinates.x;
        const y2 = endCoordinates.y;
        // Define differences and error check
        const dx = Math.abs(x2 - x1);
        const dy = Math.abs(y2 - y1);
        const sx = x1 &lt; x2 ? 1 : -1;
        const sy = y1 &lt; y2 ? 1 : -1;
        let err = dx - dy;

        coordinate = camera.pickEllipsoid({ x: x1, y: y1 }, ellipsoid);
        if (coordinate) {
          return coordinate;
        }

        // Main loop
        while (!(x1 == x2 &amp;&amp; y1 == y2)) {
          const e2 = err &lt;&lt; 1;
          if (e2 > -dy) {
            err -= dy;
            x1 += sx;
          }
          if (e2 &lt; dx) {
            err += dx;
            y1 += sy;
          }

          coordinate = camera.pickEllipsoid({ x: x1, y: y1 }, ellipsoid);
          if (coordinate) {
            return coordinate;
          }
        }

        return null;
      },

      /**
       * Update the map model's currentScale attribute, which is used for the
       * scale bar. Finds the distance between two pixels at the *bottom center*
       * of the screen.
       */
      updateScale: function () {
        try {
          const view = this;
          let currentScale = {
            pixels: null,
            meters: null,
          };
          const onePixelInMeters = view.pixelToMeters();
          if (onePixelInMeters || onePixelInMeters === 0) {
            currentScale = {
              pixels: 1,
              meters: onePixelInMeters,
            };
          }
          view.interactions.setScale(currentScale);
        } catch (e) {
          console.log("Error updating the scale from a CesiumWidgetView", e);
        }
      },

      /**
       * Finds the geodesic distance (in meters) between two points that are 1
       * pixel apart at the bottom, center of the Cesium canvas. Adapted from
       * TerriaJS. See
       * {@link https://github.com/TerriaJS/terriajs/blob/main/lib/ReactViews/Map/Legend/DistanceLegend.jsx}
       * @returns {number|boolean} Returns the distance on the globe, in meters,
       * that is equivalent to 1 pixel on the screen at the center bottom point
       * of the current scene. Returns false if there was a problem getting the
       * measurement.
       */
      pixelToMeters: function () {
        try {
          const view = this;
          const scene = view.scene;
          const globe = scene.globe;
          const camera = scene.camera;

          // For measuring geodesic distances (shortest route between two points
          // on the Earth's surface)
          if (!view.geodesic) {
            view.geodesic = new Cesium.EllipsoidGeodesic();
          }

          // Find two points that are 1 pixel apart at the bottom center of the
          // cesium canvas.
          const width = scene.canvas.clientWidth;
          const height = scene.canvas.clientHeight;

          const left = camera.getPickRay(
            new Cesium.Cartesian2((width / 2) | 0, height - 1)
          );
          const right = camera.getPickRay(
            new Cesium.Cartesian2((1 + width / 2) | 0, height - 1)
          );

          const leftPosition = globe.pick(left, scene);
          const rightPosition = globe.pick(right, scene);

          // A point must exist at both positions to get the distance
          if (!Cesium.defined(leftPosition) || !Cesium.defined(rightPosition)) {
            return false;
          }

          // Find the geodesic distance, in meters, between the two points that
          // are 1 pixel apart
          const leftCartographic =
            globe.ellipsoid.cartesianToCartographic(leftPosition);
          const rightCartographic =
            globe.ellipsoid.cartesianToCartographic(rightPosition);

          view.geodesic.setEndPoints(leftCartographic, rightCartographic);

          const onePixelInMeters = view.geodesic.surfaceDistance;

          return onePixelInMeters;
        } catch (error) {
          console.log(
            "Failed to get a pixel to meters measurement in a CesiumWidgetView" +
              ". Error details: " +
              error
          );
          return false;
        }
      },

      /**
       * Finds the function that is configured for the given asset model type in
       * the {@link CesiumWidgetView#mapAssetRenderFunctions} array, then
       * renders the asset in the map. If there is a problem rendering the asset
       * (e.g. it is an unsupported type that is not configured in the
       * mapAssetRenderFunctions), then sets the AssetModel's status to error.
       * @param {MapAsset} mapAsset A MapAsset layer to render in the map, such
       * as a Cesium3DTileset or a CesiumImagery model.
       */
      addAsset: function (mapAsset) {
        try {
          if (!mapAsset) {
            return;
          }
          var view = this;
          var type = mapAsset.get("type");
          // Find the render option from the options configured in the view,
          // given the asset model type
          const renderOption =
            _.find(view.mapAssetRenderFunctions, function (option) {
              return option.types.includes(type);
            }) || {};
          // Get the function for this type
          const renderFunction = view[renderOption.renderFunction];

          // If the cesium widget does not have a way to display this error,
          // update the error status in the model (this will be reflected in the
          // LayerListView)
          if (!renderFunction || typeof renderFunction !== "function") {
            mapAsset.set(
              "statusDetails",
              "This type of resource is not supported in the map widget."
            );
            mapAsset.set("status", "error");
            return;
          }

          // The asset should be visible and the cesium model should be ready
          // before starting to render the asset
          const checkAndRenderAsset = function () {
            let shouldRender =
              mapAsset.get("visible") &amp;&amp; mapAsset.get("status") === "ready";
            if (shouldRender) {
              renderFunction.call(view, mapAsset.get("cesiumModel"));
              view.stopListening(mapAsset);
            }
          };

          checkAndRenderAsset();

          if (!mapAsset.get("visible")) {
            view.listenToOnce(mapAsset, "change:visible", checkAndRenderAsset);
          }

          if (mapAsset.get("status") !== "ready") {
            view.listenTo(mapAsset, "change:status", checkAndRenderAsset);
          }
        } catch (e) {
          console.error("Error rendering an asset", e, mapAsset);
          mapAsset.set(
            "statusDetails",
            "There was a problem rendering this resource in the map widget."
          );
          mapAsset.set("status", "error");
        }
      },

      /**
       * When an asset is removed from the map model, remove it from the map.
       * @param {MapAsset} mapAsset - The MapAsset model removed from the map
       * @since 2.27.0
       */
      removeAsset: function (mapAsset) {
        if (!mapAsset) return;
        // Get the cesium model from the asset
        const cesiumModel = mapAsset.get("cesiumModel");
        if (!cesiumModel) return;
        // Find the remove function for this type of asset
        const removeFunctionName = this.mapAssetRenderFunctions.find(function (
          option
        ) {
          return option.types.includes(mapAsset.get("type"));
        })?.removeFunction;
        const removeFunction = this[removeFunctionName];
        // If there is a function for this type of asset, call it
        if (removeFunction &amp;&amp; typeof removeFunction === "function") {
          removeFunction.call(this, cesiumModel);
        } else {
          console.log(
            "No remove function found for this type of asset",
            mapAsset
          );
        }
      },

      /**
       * Renders peaks and valleys in the 3D version of the map, given a terrain
       * model. If a terrain model has already been set on the map, this will
       * replace it.
       * @param {Cesium.TerrainProvider} cesiumModel a Cesium Terrain Provider
       * model to use for the map
       */
      updateTerrain: function (cesiumModel) {
        // TODO: Add listener to the map model for when the terrain changes
        this.scene.terrainProvider = cesiumModel;
        this.requestRender();
      },

      /**
       * Renders a 3D tileset in the map.
       * @param {Cesium.Cesium3DTileset} cesiumModel The Cesium 3D tileset model
       * that contains the information about the 3D tiles to render in the map
       */
      add3DTileset: function (cesiumModel) {
        this.scene.primitives.add(cesiumModel);
      },

      /**
       * Remove a 3D tileset from the map.
       * @param {Cesium.Cesium3DTileset} cesiumModel The Cesium 3D tileset model
       * to remove from the map
       * @since 2.27.0
       */
      remove3DTileset: function (cesiumModel) {
        this.scene.primitives.remove(cesiumModel);
      },

      /**
       * Renders vector data (excluding 3D tilesets) in the Map.
       * @param {Cesium.GeoJsonDataSource} cesiumModel - The Cesium data source
       * model to render on the map
       */
      addVectorData: function (cesiumModel) {
        this.dataSourceCollection.add(cesiumModel);
      },

      /**
       * Remove vector data (excluding 3D tilesets) from the Map.
       * @param {Cesium.GeoJsonDataSource} cesiumModel - The Cesium data source
       * model to remove from the map
       * @since 2.27.0
       */
      removeVectorData: function (cesiumModel) {
        this.dataSourceCollection.remove(cesiumModel);
      },

      /**
       * Renders imagery in the Map.
       * @param {Cesium.ImageryLayer} cesiumModel The Cesium imagery model to
       * render
       */
      addImagery: function (cesiumModel) {
        this.scene.imageryLayers.add(cesiumModel);
        this.sortImagery();
      },

      /**
       * Remove imagery from the Map.
       * @param {Cesium.ImageryLayer} cesiumModel The Cesium imagery model to
       * remove from the map
       * @since 2.27.0
       */
      removeImagery: function (cesiumModel) {
        console.log("Removing imagery from map", cesiumModel);
        console.log("Imagery layers", this.scene.imageryLayers);
        this.scene.imageryLayers.remove(cesiumModel);
      },

      /**
       * Arranges the imagery that is rendered the Map according to the order
       * that the imagery is arranged in the layers collection.
       * @since 2.21.0
       */
      sortImagery: function () {
        const imageryInMap = this.scene.imageryLayers;
        const imageryModels = _.reduce(this.model.getLayerGroups(), (models, layers) => {
            models.push(...layers.getAll("CesiumImagery"));
            return models;
          }, []);

        // If there are no imagery layers, or just one, return
        if (
          !imageryInMap ||
          !imageryModels ||
          imageryInMap.length &lt;= 1 ||
          imageryModels.length &lt;= 1
        ) {
          return;
        }

        // If there are more than one imagery layer, arrange them in the order
        // that they were added to the map
        for (let i = 0; i &lt; imageryModels.length; i++) {
          const cesiumModel = imageryModels[i].get("cesiumModel");
          if (cesiumModel) {
            if (imageryInMap.contains(cesiumModel)) {
              imageryInMap.lowerToBottom(cesiumModel);
            }
          }
        }
      },

      /**
       * Display a box around every rendered tile in the tiling scheme, and draw
       * a label inside it indicating the X, Y, Level indices of the tile. This
       * is mostly useful for debugging terrain and imagery rendering problems.
       * This function should be called after the other imagery layers have been
       * added to the map, e.g. at the end of the render function.
       * @param {string} [color='#ffffff'] The color of the grid outline and
       * labels. Must be a CSS color string, beginning with a #.
       * @param {'GeographicTilingScheme'|'WebMercatorTilingScheme'}
       *  [tilingScheme='GeographicTilingScheme'] The tiling scheme to use.
       *  Defaults to GeographicTilingScheme.
       */
      showImageryGrid: function (
        color = "#ffffff",
        tilingScheme = "GeographicTilingScheme"
      ) {
        try {
          const view = this;
          // Check the color is valid
          if (!color || typeof color !== "string" || !color.startsWith("#")) {
            console.log(
              `${color} is an invalid color for imagery grid. ` +
                `Must be a hex color starting with '#'. ` +
                `Setting color to white: '#ffffff'`
            );
            color = "#ffffff";
          }

          // Check the tiling scheme is valid
          const availableTS = [
            "GeographicTilingScheme",
            "WebMercatorTilingScheme",
          ];
          if (availableTS.indexOf(tilingScheme) == -1) {
            console.log(
              `${tilingScheme} is not a valid tiling scheme ` +
                `for the imagery grid. Using WebMercatorTilingScheme`
            );
            tilingScheme = "WebMercatorTilingScheme";
          }

          // Create the imagery grid
          const gridOpts = {
            tilingScheme: new Cesium[tilingScheme](),
            color: Cesium.Color.fromCssColorString(color),
          };

          const gridOutlines = new Cesium.GridImageryProvider(gridOpts);
          const gridCoords = new Cesium.TileCoordinatesImageryProvider(
            gridOpts
          );
          view.scene.imageryLayers.addImageryProvider(gridOutlines);
          view.scene.imageryLayers.addImageryProvider(gridCoords);
        } catch (error) {
          console.log(
            "There was an error showing the imagery grid in a CesiumWidgetView" +
              ". Error details: " +
              error
          );
        }
      },
    }
  );

  return CesiumWidgetView;
});
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
