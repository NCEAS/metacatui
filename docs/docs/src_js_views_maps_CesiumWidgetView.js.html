<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>MetacatUI Dev Docs: Source: src/js/views/maps/CesiumWidgetView.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="/metacatui/assets/css/styles.css">
    <link type="text/css" rel="stylesheet" href="styles/style.css">
</head>

<body>

<nav id="nav">
    <a href="/">
      <div class="logo">
<svg class="cat" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="cat" class="svg-inline--fa fa-cat fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M290.59 192c-20.18 0-106.82 1.98-162.59 85.95V192c0-52.94-43.06-96-96-96-17.67 0-32 14.33-32 32s14.33 32 32 32c17.64 0 32 14.36 32 32v256c0 35.3 28.7 64 64 64h176c8.84 0 16-7.16 16-16v-16c0-17.67-14.33-32-32-32h-32l128-96v144c0 8.84 7.16 16 16 16h32c8.84 0 16-7.16 16-16V289.86c-10.29 2.67-20.89 4.54-32 4.54-61.81 0-113.52-44.05-125.41-102.4zM448 96h-64l-64-64v134.4c0 53.02 42.98 96 96 96s96-42.98 96-96V32l-64 64zm-72 80c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16zm80 0c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16z"></path></svg>

<svg width="459px" height="53px" viewBox="0 0 459 53" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="metacatui" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M16.492,52 C17.212,52 17.812,51.748 18.292,51.244 C18.772,50.74 19.012,50.128 19.012,49.408 L19.012,49.408 L18.94,22.912 L30.82,37.816 C31.204,38.344 31.72,38.764 32.368,39.076 C33.016,39.388 33.7,39.544 34.42,39.544 C35.908,39.544 37.132,38.896 38.092,37.6 L38.092,37.6 L49.684,22.912 L49.684,49.408 C49.684,50.128 49.96,50.74 50.512,51.244 C51.064,51.748 51.7,52 52.42,52 L52.42,52 L62.068,52 C62.788,52 63.388,51.748 63.868,51.244 C64.348,50.74 64.588,50.128 64.588,49.408 L64.588,49.408 L64.588,4.12 C64.588,3.448 64.336,2.86 63.832,2.356 C63.328,1.852 62.74,1.6 62.068,1.6 L62.068,1.6 L52.348,1.6 C51.388,1.6 50.56,1.648 49.864,1.744 C49.168,1.84 48.532,2.152 47.956,2.68 L47.956,2.68 L33.916,17.296 L20.524,2.608 C20.332,2.368 19.972,2.14 19.444,1.924 C18.916,1.708 18.412,1.6 17.932,1.6 L17.932,1.6 L6.772,1.6 C6.052,1.6 5.44,1.852 4.936,2.356 C4.432,2.86 4.18,3.448 4.18,4.12 L4.18,4.12 L4.18,49.408 C4.18,50.08 4.432,50.68 4.936,51.208 C5.44,51.736 6.052,52 6.772,52 L6.772,52 L16.492,52 Z M110.74,52 C111.556,52 112.264,51.676 112.864,51.028 C113.464,50.38 113.764,49.624 113.764,48.76 L113.764,48.76 L113.764,42.568 C113.764,41.608 113.464,40.828 112.864,40.228 C112.264,39.628 111.556,39.328 110.74,39.328 L110.74,39.328 L89.428,39.328 L89.428,32.92 L109.732,32.92 C110.5,32.92 111.184,32.596 111.784,31.948 C112.384,31.3 112.684,30.568 112.684,29.752 L112.684,29.752 L112.684,23.488 C112.684,22.576 112.384,21.82 111.784,21.22 C111.184,20.62 110.5,20.32 109.732,20.32 L109.732,20.32 L89.428,20.32 L89.428,14.488 L110.74,14.488 C111.508,14.488 112.204,14.164 112.828,13.516 C113.452,12.868 113.764,12.136 113.764,11.32 L113.764,11.32 L113.764,5.056 C113.764,4.144 113.464,3.388 112.864,2.788 C112.264,2.188 111.556,1.888 110.74,1.888 L110.74,1.888 L76.756,1.888 C75.94,1.888 75.232,2.188 74.632,2.788 C74.032,3.388 73.732,4.144 73.732,5.056 L73.732,5.056 L73.732,48.76 C73.732,49.624 74.032,50.38 74.632,51.028 C75.232,51.676 75.94,52 76.756,52 L76.756,52 L110.74,52 Z M147.604,52 C148.42,52 149.104,51.688 149.656,51.064 C150.208,50.44 150.484,49.672 150.484,48.76 L150.484,48.76 L150.484,16.216 L161.86,16.216 C162.676,16.216 163.396,15.904 164.02,15.28 C164.644,14.656 164.956,13.936 164.956,13.12 L164.956,13.12 L164.956,4.768 C164.956,4 164.644,3.316 164.02,2.716 C163.396,2.116 162.676,1.816 161.86,1.816 L161.86,1.816 L124.132,1.816 C123.22,1.816 122.464,2.104 121.864,2.68 C121.264,3.256 120.964,3.952 120.964,4.768 L120.964,4.768 L120.964,13.12 C120.964,13.936 121.264,14.656 121.864,15.28 C122.464,15.904 123.22,16.216 124.132,16.216 L124.132,16.216 L135.652,16.216 L135.148,48.832 C135.148,49.744 135.424,50.5 135.976,51.1 C136.528,51.7 137.212,52 138.028,52 L138.028,52 L147.604,52 Z M175.828,52 C176.836,52 177.676,51.82 178.348,51.46 C179.02,51.1 179.452,50.584 179.644,49.912 L179.644,49.912 L181.876,42.712 L197.932,42.712 L200.164,49.912 C200.356,50.584 200.8,51.1 201.496,51.46 C202.192,51.82 203.044,52 204.052,52 L204.052,52 L213.916,52 C215.836,51.712 216.796,50.704 216.796,48.976 C216.796,48.304 216.676,47.596 216.436,46.852 C216.196,46.108 216.052,45.616 216.004,45.376 L216.004,45.376 L199.876,4.84 C199.588,3.976 199.036,3.232 198.22,2.608 C197.404,1.984 196.372,1.648 195.124,1.6 L195.124,1.6 L184.756,1.6 C183.604,1.648 182.608,1.948 181.768,2.5 C180.928,3.052 180.292,3.832 179.86,4.84 L179.86,4.84 L163.876,45.376 C163.828,45.472 163.672,45.916 163.408,46.708 C163.144,47.5 163.012,48.304 163.012,49.12 C163.012,50.752 163.948,51.712 165.82,52 L165.82,52 L175.828,52 Z M195.34,30.544 L184.036,30.544 L189.652,13.624 L195.34,30.544 Z M245.38,53.08 C250.612,53.08 255.652,51.544 260.5,48.472 C261.22,47.944 261.58,47.296 261.58,46.528 C261.58,45.808 261.292,45.16 260.716,44.584 L260.716,44.584 L252.796,36.808 C252.364,36.376 251.836,36.16 251.212,36.16 C250.78,36.16 250.372,36.256 249.988,36.448 C248.356,37.12 246.796,37.456 245.308,37.456 C243.244,37.456 241.348,36.952 239.62,35.944 C237.892,34.936 236.512,33.58 235.48,31.876 C234.448,30.172 233.932,28.336 233.932,26.368 C233.932,24.352 234.436,22.504 235.444,20.824 C236.452,19.144 237.832,17.812 239.584,16.828 C241.336,15.844 243.244,15.352 245.308,15.352 C246.892,15.352 248.332,15.64 249.628,16.216 C250.012,16.408 250.444,16.504 250.924,16.504 C251.548,16.504 252.1,16.264 252.58,15.784 L252.58,15.784 L259.636,8.008 C260.164,7.384 260.428,6.76 260.428,6.136 C260.428,5.224 259.996,4.528 259.132,4.048 C254.86,1.552 250.276,0.304 245.38,0.304 C240.532,0.304 236.032,1.492 231.88,3.868 C227.728,6.244 224.44,9.448 222.016,13.48 C219.592,17.512 218.38,21.904 218.38,26.656 C218.38,31.408 219.592,35.812 222.016,39.868 C224.44,43.924 227.728,47.14 231.88,49.516 C236.032,51.892 240.532,53.08 245.38,53.08 Z M279.796,52 C280.804,52 281.644,51.82 282.316,51.46 C282.988,51.1 283.42,50.584 283.612,49.912 L283.612,49.912 L285.844,42.712 L301.9,42.712 L304.132,49.912 C304.324,50.584 304.768,51.1 305.464,51.46 C306.16,51.82 307.012,52 308.02,52 L308.02,52 L317.884,52 C319.804,51.712 320.764,50.704 320.764,48.976 C320.764,48.304 320.644,47.596 320.404,46.852 C320.164,46.108 320.02,45.616 319.972,45.376 L319.972,45.376 L303.844,4.84 C303.556,3.976 303.004,3.232 302.188,2.608 C301.372,1.984 300.34,1.648 299.092,1.6 L299.092,1.6 L288.724,1.6 C287.572,1.648 286.576,1.948 285.736,2.5 C284.896,3.052 284.26,3.832 283.828,4.84 L283.828,4.84 L267.844,45.376 C267.796,45.472 267.64,45.916 267.376,46.708 C267.112,47.5 266.98,48.304 266.98,49.12 C266.98,50.752 267.916,51.712 269.788,52 L269.788,52 L279.796,52 Z M299.308,30.544 L288.004,30.544 L293.62,13.624 L299.308,30.544 Z M352.588,52 C353.404,52 354.088,51.688 354.64,51.064 C355.192,50.44 355.468,49.672 355.468,48.76 L355.468,48.76 L355.468,16.216 L366.844,16.216 C367.66,16.216 368.38,15.904 369.004,15.28 C369.628,14.656 369.94,13.936 369.94,13.12 L369.94,13.12 L369.94,4.768 C369.94,4 369.628,3.316 369.004,2.716 C368.38,2.116 367.66,1.816 366.844,1.816 L366.844,1.816 L329.116,1.816 C328.204,1.816 327.448,2.104 326.848,2.68 C326.248,3.256 325.948,3.952 325.948,4.768 L325.948,4.768 L325.948,13.12 C325.948,13.936 326.248,14.656 326.848,15.28 C327.448,15.904 328.204,16.216 329.116,16.216 L329.116,16.216 L340.636,16.216 L340.132,48.832 C340.132,49.744 340.408,50.5 340.96,51.1 C341.512,51.7 342.196,52 343.012,52 L343.012,52 L352.588,52 Z M402.052,52.792 C408.1,52.792 412.912,51.628 416.488,49.3 C420.064,46.972 422.536,44.068 423.904,40.588 C425.272,37.108 425.932,33.424 425.884,29.536 C425.884,29.5309474 425.883967,29.5237673 425.8839,29.5144598 L425.883102,29.4330859 C425.879911,29.1480111 425.868211,28.3183158 425.848,26.944 C425.8294,25.6792 425.818008,22.91524 425.813823,18.65212 L425.813103,17.80828 C425.812997,17.66452 425.8129,17.5192 425.81281,17.37232 L425.812,3.904 C425.86,3.184 425.632,2.62 425.128,2.212 C424.624,1.804 423.916,1.6 423.004,1.6 L423.004,1.6 L413.428,1.6 C412.612,1.6 411.904,1.828 411.304,2.284 C410.704,2.74 410.404,3.28 410.404,3.904 L410.404,3.904 L410.26,27.808 C410.26,34.144 407.476,37.312 401.908,37.312 C399.076,37.312 396.832,36.412 395.176,34.612 C393.52,32.812 392.668,30.352 392.62,27.232 L392.62,27.232 L392.332,3.76 C392.332,3.088 392.068,2.56 391.54,2.176 C391.012,1.792 390.268,1.6 389.308,1.6 L389.308,1.6 L379.876,1.6 C378.244,1.6 377.428,2.32 377.428,3.76 L377.428,3.76 L377.5,28.816 C377.5,33.04 378.376,36.964 380.128,40.588 C381.88,44.212 384.592,47.152 388.264,49.408 C391.936,51.664 396.532,52.792 402.052,52.792 Z M449.284,52.144 C450.148,52.144 450.88,51.844 451.48,51.244 C452.08,50.644 452.38,49.84 452.38,48.832 L452.38,48.832 L452.38,4.912 C452.38,4 452.08,3.22 451.48,2.572 C450.88,1.924 450.148,1.6 449.284,1.6 L449.284,1.6 L439.42,1.6 C438.46,1.6 437.692,1.924 437.116,2.572 C436.54,3.22 436.252,4 436.252,4.912 L436.252,4.912 L436.252,48.832 C436.252,49.84 436.54,50.644 437.116,51.244 C437.692,51.844 438.46,52.144 439.42,52.144 L439.42,52.144 L449.284,52.144 Z" id="metacatui" fill="#FCBF49" fill-rule="nonzero"></path>
    </g>
</svg>
</logo>

    </a>
    <h3>Namespaces</h3><ul><li><a href="AppConfig.html">AppConfig</a></li><li><a href="MapConfig.html">MapConfig</a></li><li><a href="MetacatUI.html">MetacatUI</a></li><li><a href="Utilities.html">Utilities</a></li></ul><h3>Classes</h3><ul><li class='category-heading' data-category='Collections'>Collections</li><li><a href="AccessPolicy.html">AccessPolicy</a></li><li><a href="Citations.html">Citations</a></li><li><a href="DataPackage.html">DataPackage</a></li><li><a href="Filters.html">Filters</a></li><li><a href="ObjectFormats.html">ObjectFormats</a></li><li><a href="ProjectList.html">ProjectList</a></li><li><a href="QualityReport.html">QualityReport</a></li><li><a href="SolrResults.html">SolrResults</a></li><li><a href="Units.html">Units</a></li><li><a href="UserGroup.html">UserGroup</a></li><li class='category-heading' data-category='Collections/Bookkeeper'>Collections/Bookkeeper</li><li><a href="Quotas.html">Quotas</a></li><li><a href="Usages.html">Usages</a></li><li class='category-heading' data-category='Collections/Geohashes'>Collections/Geohashes</li><li><a href="Geohashes.html">Geohashes</a></li><li class='category-heading' data-category='Collections/Maps'>Collections/Maps</li><li><a href="AssetColors.html">AssetColors</a></li><li><a href="Features.html">Features</a></li><li><a href="MapAssets.html">MapAssets</a></li><li><a href="VectorFilters.html">VectorFilters</a></li><li class='category-heading' data-category='Collections/Metadata/EML'>Collections/Metadata/EML</li><li><a href="EMLAnnotations.html">EMLAnnotations</a></li><li><a href="EMLMissingValueCodes.html">EMLMissingValueCodes</a></li><li class='category-heading' data-category='Collections/QueryFields'>Collections/QueryFields</li><li><a href="QueryFields.html">QueryFields</a></li><li class='category-heading' data-category='Models'>Models</li><li><a href="AccessRule.html">AccessRule</a></li><li><a href="AppModel.html">AppModel</a></li><li><a href="CitationModel.html">CitationModel</a></li><li><a href="CollectionModel.html">CollectionModel</a></li><li><a href="DataONEObject.html">DataONEObject</a></li><li><a href="LookupModel.html">LookupModel</a></li><li><a href="Map.html">Map</a></li><li><a href="Metrics.html">Metrics</a></li><li><a href="QualityCheck.html">QualityCheck</a></li><li><a href="Search.html">Search</a></li><li><a href="SolrResult.html">SolrResult</a></li><li><a href="Stats.html">Stats</a></li><li class='category-heading' data-category='Models/Analytics'>Models/Analytics</li><li><a href="Analytics.html">Analytics</a></li><li><a href="GoogleAnalytics.html">GoogleAnalytics</a></li><li class='category-heading' data-category='Models/Bookkeeper'>Models/Bookkeeper</li><li><a href="Quota.html">Quota</a></li><li><a href="Subscription.html">Subscription</a></li><li><a href="Usage.html">Usage</a></li><li class='category-heading' data-category='Models/Connectors'>Models/Connectors</li><li><a href="FiltersMapConnector.html">FiltersMapConnector</a></li><li><a href="FiltersSearchConnector.html">FiltersSearchConnector</a></li><li><a href="MapSearchConnector.html">MapSearchConnector</a></li><li><a href="MapSearchFiltersConnector.html">MapSearchFiltersConnector</a></li><li class='category-heading' data-category='Models/Filters'>Models/Filters</li><li><a href="BooleanFilter.html">BooleanFilter</a></li><li><a href="ChoiceFilter.html">ChoiceFilter</a></li><li><a href="DateFilter.html">DateFilter</a></li><li><a href="Filter.html">Filter</a></li><li><a href="FilterGroup.html">FilterGroup</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="SpatialFilter.html">SpatialFilter</a></li><li><a href="ToggleFilter.html">ToggleFilter</a></li><li class='category-heading' data-category='Models/Formats'>Models/Formats</li><li><a href="ObjectFormat.html">ObjectFormat</a></li><li class='category-heading' data-category='Models/Geohashes'>Models/Geohashes</li><li><a href="Geohash.html">Geohash</a></li><li class='category-heading' data-category='Models/Maps'>Models/Maps</li><li><a href="AssetColor.html">AssetColor</a></li><li><a href="AssetColorPalette.html">AssetColorPalette</a></li><li><a href="Feature.html">Feature</a></li><li><a href="MapModel.html">MapModel</a></li><li><a href="VectorFilter.html">VectorFilter</a></li><li class='category-heading' data-category='Models/Maps/Assets'>Models/Maps/Assets</li><li><a href="Cesium3DTileset.html">Cesium3DTileset</a></li><li><a href="CesiumGeohash.html">CesiumGeohash</a></li><li><a href="CesiumImagery.html">CesiumImagery</a></li><li><a href="CesiumTerrain.html">CesiumTerrain</a></li><li><a href="CesiumVectorData.html">CesiumVectorData</a></li><li><a href="MapAsset.html">MapAsset</a></li><li class='category-heading' data-category='Models/Metadata'>Models/Metadata</li><li><a href="ScienceMetadata.html">ScienceMetadata</a></li><li class='category-heading' data-category='Models/Metadata/EML'>Models/Metadata/EML</li><li><a href="EMLMethodStep.html">EMLMethodStep</a></li><li><a href="EMLSpecializedText.html">EMLSpecializedText</a></li><li class='category-heading' data-category='Models/Metadata/EML211'>Models/Metadata/EML211</li><li><a href="EML211.html">EML211</a></li><li><a href="EMLAnnotation.html">EMLAnnotation</a></li><li><a href="EMLAttribute.html">EMLAttribute</a></li><li><a href="EMLDataTable.html">EMLDataTable</a></li><li><a href="EMLDistribution.html">EMLDistribution</a></li><li><a href="EMLEntity.html">EMLEntity</a></li><li><a href="EMLGeoCoverage.html">EMLGeoCoverage</a></li><li><a href="EMLMeasurementScale.html">EMLMeasurementScale</a></li><li><a href="EMLMethods.html">EMLMethods</a></li><li><a href="EMLMissingValueCode.html">EMLMissingValueCode</a></li><li><a href="EMLNonNumericDomain.html">EMLNonNumericDomain</a></li><li><a href="EMLNumericDomain.html">EMLNumericDomain</a></li><li><a href="EMLOtherEntity.html">EMLOtherEntity</a></li><li><a href="EMLParty.html">EMLParty</a></li><li><a href="EMLTemporalCoverage.html">EMLTemporalCoverage</a></li><li><a href="EMLText211.html">EMLText211</a></li><li><a href="EMLUnit.html">EMLUnit</a></li><li class='category-heading' data-category='Models/Metadata/EML220'>Models/Metadata/EML220</li><li><a href="EMLText.html">EMLText</a></li><li class='category-heading' data-category='Models/Portals'>Models/Portals</li><li><a href="PortalImage.html">PortalImage</a></li><li><a href="PortalModel.html">PortalModel</a></li><li><a href="PortalSectionModel.html">PortalSectionModel</a></li><li class='category-heading' data-category='Models/Projects'>Models/Projects</li><li><a href="Project.html">Project</a></li><li class='category-heading' data-category='Models/QueryFields'>Models/QueryFields</li><li><a href="QueryField.html">QueryField</a></li><li class='category-heading' data-category='Router'>Router</li><li><a href="UIRouter.html">UIRouter</a></li><li class='category-heading' data-category='Views'>Views</li><li><a href="AccessPolicyView.html">AccessPolicyView</a></li><li><a href="AccessRuleView.html">AccessRuleView</a></li><li><a href="AnnotationView.html">AnnotationView</a></li><li><a href="AppView.html">AppView</a></li><li><a href="CatalogSearchView.html">CatalogSearchView</a></li><li><a href="CitationHeaderView.html">CitationHeaderView</a></li><li><a href="CitationListView.html">CitationListView</a></li><li><a href="CitationModalView.html">CitationModalView</a></li><li><a href="CitationView.html">CitationView</a></li><li><a href="ColorPaletteView.html">ColorPaletteView</a></li><li><a href="DataCatalogViewWithFilters.html">DataCatalogViewWithFilters</a></li><li><a href="DataItemView.html">DataItemView</a></li><li><a href="DataPackageView.html">DataPackageView</a></li><li><a href="DraftsView.html">DraftsView</a></li><li><a href="EditCollectionView.html">EditCollectionView</a></li><li><a href="EditorView.html">EditorView</a></li><li><a href="FooterView.html">FooterView</a></li><li><a href="GroupListView.html">GroupListView</a></li><li><a href="ImageUploaderView.html">ImageUploaderView</a></li><li><a href="MarkdownEditorView.html">MarkdownEditorView</a></li><li><a href="MarkdownView.html">MarkdownView</a></li><li><a href="MdqRunView.html">MdqRunView</a></li><li><a href="MetadataView.html">MetadataView</a></li><li><a href="MetricModalView.html">MetricModalView</a></li><li><a href="MetricView.html">MetricView</a></li><li><a href="MetricsChartView.html">MetricsChartView</a></li><li><a href="NavbarView.html">NavbarView</a></li><li><a href="RegisterCitationView.html">RegisterCitationView</a></li><li><a href="SearchResultView.html">SearchResultView</a></li><li><a href="SignInView.html">SignInView</a></li><li><a href="TOCView.html">TOCView</a></li><li><a href="TableEditorView.html">TableEditorView</a></li><li><a href="UserGroupView.html">UserGroupView</a></li><li><a href="UserView.html">UserView</a></li><li class='category-heading' data-category='Views/Filters'>Views/Filters</li><li><a href="BooleanFilterView.html">BooleanFilterView</a></li><li><a href="ChoiceFilterView.html">ChoiceFilterView</a></li><li><a href="DateFilterView.html">DateFilterView</a></li><li><a href="FilterEditorView.html">FilterEditorView</a></li><li><a href="FilterGroupView.html">FilterGroupView</a></li><li><a href="FilterGroupsView.html">FilterGroupsView</a></li><li><a href="FilterView.html">FilterView</a></li><li><a href="NumericFilterView.html">NumericFilterView</a></li><li><a href="SemanticFilterView.html">SemanticFilterView</a></li><li><a href="ToggleFilterView.html">ToggleFilterView</a></li><li class='category-heading' data-category='Views/Maps'>Views/Maps</li><li><a href="CesiumWidgetView.html">CesiumWidgetView</a></li><li><a href="FeatureInfoView.html">FeatureInfoView</a></li><li><a href="LayerDetailView.html">LayerDetailView</a></li><li><a href="LayerDetailsView.html">LayerDetailsView</a></li><li><a href="LayerInfoView.html">LayerInfoView</a></li><li><a href="LayerItemView.html">LayerItemView</a></li><li><a href="LayerListView.html">LayerListView</a></li><li><a href="LayerNavigationView.html">LayerNavigationView</a></li><li><a href="LayerOpacityView.html">LayerOpacityView</a></li><li><a href="LegendView.html">LegendView</a></li><li><a href="MapView.html">MapView</a></li><li><a href="ScaleBarView.html">ScaleBarView</a></li><li><a href="ToolbarView.html">ToolbarView</a></li><li class='category-heading' data-category='Views/Metadata'>Views/Metadata</li><li><a href="EML211EditorView.html">EML211EditorView</a></li><li><a href="EMLAttributeView.html">EMLAttributeView</a></li><li><a href="EMLEntityView.html">EMLEntityView</a></li><li><a href="EMLMeasurementScaleView.html">EMLMeasurementScaleView</a></li><li><a href="EMLMeasurementTypeView.html">EMLMeasurementTypeView</a></li><li><a href="EMLMethodsView.html">EMLMethodsView</a></li><li><a href="EMLMissingValueCodeView.html">EMLMissingValueCodeView</a></li><li><a href="EMLMissingValueCodesView.html">EMLMissingValueCodesView</a></li><li><a href="EMLOtherEntityView.html">EMLOtherEntityView</a></li><li><a href="EMLPartyView.html">EMLPartyView</a></li><li><a href="EMLTempCoverageView.html">EMLTempCoverageView</a></li><li><a href="EMLView.html">EMLView</a></li><li><a href="EMlGeoCoverageView_.html">EMlGeoCoverageView</a></li><li><a href="ScienceMetadataView.html">ScienceMetadataView</a></li><li class='category-heading' data-category='Views/Portals'>Views/Portals</li><li><a href="PortalDataView.html">PortalDataView</a></li><li><a href="PortalHeaderView.html">PortalHeaderView</a></li><li><a href="PortalListView.html">PortalListView</a></li><li><a href="PortalLogosView.html">PortalLogosView</a></li><li><a href="PortalMembersView.html">PortalMembersView</a></li><li><a href="PortalSectionView.html">PortalSectionView</a></li><li><a href="PortalUsagesView.html">PortalUsagesView</a></li><li><a href="PortalView.html">PortalView</a></li><li><a href="PortalVisualizationsView.html">PortalVisualizationsView</a></li><li><a href="PortalsSearchView.html">PortalsSearchView</a></li><li class='category-heading' data-category='Views/Portals/Editor'>Views/Portals/Editor</li><li><a href="PortEditorDataView.html">PortEditorDataView</a></li><li><a href="PortEditorImageView.html">PortEditorImageView</a></li><li><a href="PortEditorLogosView.html">PortEditorLogosView</a></li><li><a href="PortEditorMdSectionView.html">PortEditorMdSectionView</a></li><li><a href="PortEditorSectionView.html">PortEditorSectionView</a></li><li><a href="PortEditorSectionsView.html">PortEditorSectionsView</a></li><li><a href="PortEditorSettingsView.html">PortEditorSettingsView</a></li><li><a href="PortalEditorView.html">PortalEditorView</a></li><li class='category-heading' data-category='Views/Projects'>Views/Projects</li><li><a href="ProjectView.html">ProjectView</a></li><li class='category-heading' data-category='Views/QueryBuilder'>Views/QueryBuilder</li><li><a href="QueryBuilderView.html">QueryBuilderView</a></li><li><a href="QueryRuleView.html">QueryRuleView</a></li><li class='category-heading' data-category='Views/Search'>Views/Search</li><li><a href="SearchResultsPagerView.html">SearchResultsPagerView</a></li><li><a href="SearchResultsView.html">SearchResultsView</a></li><li><a href="SorterView.html">SorterView</a></li><li class='category-heading' data-category='Views/SearchSelect'>Views/SearchSelect</li><li><a href="AccountSelectView.html">AccountSelectView</a></li><li><a href="AnnotationFilter.html">AnnotationFilter</a></li><li><a href="NodeSelect.html">NodeSelect</a></li><li><a href="ObjectFormatSelect.html">ObjectFormatSelect</a></li><li><a href="QueryFieldSelectView.html">QueryFieldSelectView</a></li><li><a href="SearchableSelectView.html">SearchableSelectView</a></li><li class='category-heading' data-category='Deprecated'>Deprecated</li><li><a href="AnnotatorView.html">AnnotatorView</a></li><li><a href="ExternalView.html">ExternalView</a></li><li><a href="LogsSearch.html">LogsSearch</a></li></ul><h3>Global</h3><ul><li><a href="global.html#appConfigPath">appConfigPath</a></li><li><a href="global.html#classificationsAreEqual">classificationsAreEqual</a></li><li><a href="global.html#defaults">defaults</a></li><li><a href="global.html#distLocations">distLocations</a></li><li><a href="global.html#hasValuesForDistributionLocation">hasValuesForDistributionLocation</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#isDuplicate">isDuplicate</a></li><li><a href="global.html#offlineNodes">offlineNodes</a></li><li><a href="global.html#onlineNodes">onlineNodes</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#removeDuplicateClassifications">removeDuplicateClassifications</a></li><li><a href="global.html#serialize">serialize</a></li><li><a href="global.html#taxonomicClassification">taxonomicClassification</a></li><li><a href="global.html#urlFunctionTypes">urlFunctionTypes</a></li></ul>
</nav>

<div id="main">

    <h1 class="page-title">Source: src/js/views/maps/CesiumWidgetView.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

define(
  [
    'jquery',
    'underscore',
    'backbone',
    'cesium',
    'models/maps/Map',
    'models/maps/assets/MapAsset',
    'models/maps/assets/Cesium3DTileset',
    'models/maps/Feature',
    'text!templates/maps/cesium-widget-view.html'
  ],
  function (
    $,
    _,
    Backbone,
    Cesium,
    Map,
    MapAsset,
    Cesium3DTileset,
    Feature,
    Template
  ) {

    /**
    * @class CesiumWidgetView
    * @classdesc An interactive 2D and/or 3D map/globe rendered using CesiumJS. This view
    * comprises the globe without any of the UI elements like the scalebar, layer list,
    * etc.
    * @classcategory Views/Maps
    * @name CesiumWidgetView
    * @extends Backbone.View
    * @screenshot views/maps/CesiumWidgetView.png
    * @since 2.18.0
    * @constructs
    * @fires CesiumWidgetView#moved
    * @fires CesiumWidgetView#moveEnd
    * @fires CesiumWidgetView#moveStart
    * @fires Map#moved
    * @fires Map#moveEnd
    * @fires Map#moveStart
    */
    var CesiumWidgetView = Backbone.View.extend(
      /** @lends CesiumWidgetView.prototype */{

        /**
        * The type of View this is
        * @type {string}
        */
        type: 'CesiumWidgetView',

        /**
        * The HTML classes to use for this view's element. Note that the first child
        * element added to this view by cesium will have the class "cesium-widget".
        * @type {string}
        */
        className: 'cesium-widget-view',

        /**
        * The model that this view uses
        * @type {Map}
        */
        model: null,

        /**
         * The primary HTML template for this view
         * @type {Underscore.template}
         */
        template: _.template(Template),

        /**
         * An array of objects the match a Map Asset's type property to the function in
         * this view that adds and renders that asset on the map, given the Map Asset
         * model. Each object in the array has two properties: 'types' and
         * 'renderFunction'.
         * @type {Object[]}
         * @property {string[]} types The list of types that can be added to the map given
         * the renderFunction
         * @property {string} renderFunction The name of the function in the view that
         * will add the asset to the map and render it, when passed the cesiumModel
         * attribute from the MapAsset model
         */
        mapAssetRenderFunctions: [
          {
            types: ['Cesium3DTileset'],
            renderFunction: 'add3DTileset'
          },
          {
            types: ['GeoJsonDataSource', 'CzmlDataSource'],
            renderFunction: 'addVectorData'
          },
          {
            types: ['BingMapsImageryProvider', 'IonImageryProvider', 'TileMapServiceImageryProvider', 'WebMapTileServiceImageryProvider', 'WebMapServiceImageryProvider', 'OpenStreetMapImageryProvider'],
            renderFunction: 'addImagery'
          },
          {
            types: ['CesiumTerrainProvider'],
            renderFunction: 'updateTerrain'
          }
        ],

        /**
         * The border color to use on vector features that a user clicks.
         * See {@link https://cesium.com/learn/cesiumjs/ref-doc/Color.html?classFilter=color}
         * @type {Cesium.Color}
         */
        // TODO - Consider making this color configurable in the Map model
        highlightBorderColor: Cesium.Color.WHITE,

        /**
        * Executed when a new CesiumWidgetView is created
        * @param {Object} [options] - A literal object with options to pass to the view
        */
        initialize: function (options) {
          try {

            // Set the Cesium Ion token (required for some map features)
            Cesium.Ion.defaultAccessToken = MetacatUI.appModel.get('cesiumToken');

            // Get all the options and apply them to this view
            if (typeof options == 'object') {
              for (const [key, value] of Object.entries(options)) {
                this[key] = value;
              }
            }

            // Make sure that there is a Map model and that it has a selectedFeature
            // attribute. The selectedFeature attribute is used to store information about
            // the vector feature, if any, that is currently in focus on the map.
            if (!this.model) {
              this.model = new Map()
            }
            if (!this.model.get('selectedFeatures')) {
              this.model.selectFeatures()
            }


          } catch (e) {
            console.log('Failed to initialize a CesiumWidgetView. Error message: ' + e);
          }

        },

        /**
        * Renders this view
        * @return {CesiumWidgetView} Returns the rendered view element
        */
        render: function () {

          try {

            // If Cesium features are disabled in the AppConfig, then exit without rendering
            // anything.
            if (!MetacatUI.appModel.get('enableCesium')) {
              return;
            }

            // Save a reference to this view
            const view = this;

            // Insert the template into the view
            view.$el.html(view.template({}));

            // Ensure the view's main element has the given class name
            view.el.classList.add(view.className);

            // Clock will be used for the timeline component, and for the clock.ontick
            // event
            view.clock = new Cesium.Clock({ shouldAnimate: false })

            // Create the Cesium Widget and save a reference to it to the view
            view.widget = new Cesium.CesiumWidget(view.el, {
              clock: view.clock,
              // We will add a base imagery layer after initialization
              imageryProvider: false,
              terrain: false,
              useBrowserRecommendedResolution: false,
              // Use explicit rendering to make the widget must faster.
              // See https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance
              requestRenderMode: true,
              // Need to change the following once we support a time/clock component.
              // See https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/#handling-simulation-time-changes.
              maximumRenderTimeChange: Infinity
            });

            // Save references to parts of the widget that the view will access often
            view.scene = view.widget.scene;
            view.camera = view.widget.camera;
            view.inputHandler = view.widget.screenSpaceEventHandler;

            // Decrease the amount the camera must change before the changed event is
            // raised.
            view.camera.percentChanged = 0.1


            // Disable HDR lighting for better performance and to avoid changing imagery colors.
            view.scene.highDynamicRange = false;
            view.scene.globe.enableLighting = false;

            // Keep all parts of the globe lit regardless of what time the Cesium clock is
            // set to. This avoids data and imagery appearing too dark.
            view.scene.light = new Cesium.DirectionalLight({
              direction: new Cesium.Cartesian3(1, 0, 0)
            });
            view.scene.preRender.addEventListener(function (scene, time) {
              view.scene.light.direction = Cesium.Cartesian3.clone(
                scene.camera.directionWC, view.scene.light.direction
              );
            });

            // Prepare Cesium to handle vector datasources (e.g. geoJsonDataSources)
            view.dataSourceCollection = new Cesium.DataSourceCollection();
            view.dataSourceDisplay = new Cesium.DataSourceDisplay({
              scene: view.scene,
              dataSourceCollection: view.dataSourceCollection,
            });
            view.clock.onTick.addEventListener(function () {
              view.updateDataSourceDisplay.call(view)
            })

            view.setListeners();
            view.addLayers();

            // Go to the home position, if one is set.
            view.flyHome(0)

            // If users are allowed to click on features for more details,
            // initialize picking behavior on the map.
            if (view.model.get('showFeatureInfo')) {
              view.initializePicking()
            }

            return this

          }
          catch (error) {
            console.log(
              'Failed to render a CesiumWidgetView. Error details: ' + error
            );
          }
        },

        /**
         * Set all of the listeners for the CesiumWidgetView. This function is
         * called during the render function.
         * @since 2.26.0
         */
        setListeners: function () {

          const view = this;

          // Zoom functions executed after each scene render
          view.scene.postRender.addEventListener(function () {
            view.postRender();
          });

          // When the user first interacts with the map, update the model.
          // Ignore the event where the user just moves the mouse over the map.
          view.listenOnceForInteraction(function () {
            view.model.set('firstInteraction', true);
          }, ["MOUSE_MOVE"]);

          // Set listeners for when the Cesium camera changes a significant
          // amount.
          view.camera.changed.addEventListener(function () {
            view.trigger('moved')
            view.model.trigger('moved')
            // Update the bounding box for the visible area in the Map model
            view.updateViewExtent()
            // If the scale bar is showing, update the pixel to meter scale on
            // the map model when the camera angle/zoom level changes
            if (view.model.get('showScaleBar')) {
              view.updateCurrentScale()
            }
          })

          view.camera.moveEnd.addEventListener(function () {
            view.trigger('moveEnd')
            view.model.trigger('moveEnd')
          })
          view.camera.moveStart.addEventListener(function () {
            view.trigger('moveStart')
            view.model.trigger('moveStart')
          })

          // Sets listeners for when the mouse moves, depending on the value
          // of the map model's showScaleBar and showFeatureInfo attributes
          view.setMouseMoveListeners()

          // When the appearance of a layer has been updated, then tell Cesium
          // to re-render the scene. Each layer model triggers the
          // 'appearanceChanged' function whenever the color, opacity, etc.
          // has been updated in the associated Cesium model.
          view.stopListening(view.model.get('layers'), 'appearanceChanged')
          view.listenTo(view.model.get('layers'), 'appearanceChanged', view.requestRender)

          // Other views may trigger an event on the layer/asset model that
          // indicates that the map should navigate to the extent of the data,
          // or on the Map model to navigate to the home position.
          view.stopListening(view.model.get('layers'), 'flyToExtent')
          view.listenTo(view.model.get('layers'), 'flyToExtent', view.flyTo)
          view.stopListening(view.model, 'flyHome')
          view.listenTo(view.model, 'flyHome', view.flyHome)
        },

        /**
         * Listen for any user interaction with the map. Once an interaction has
         * occurred, run the callback function and stop listening for
         * interactions. Useful for detecting the first user interaction with the
         * map.
         * @param {function} callback - The function to run once the interaction
         * has occurred.
         * @param {string[]} ignore - An array of Cesium.ScreenSpaceEventType
         * labels to ignore. See
         * {@link https://cesium.com/learn/cesiumjs/ref-doc/ScreenSpaceEventType.html}
         * @since 2.26.0
         */
        listenOnceForInteraction: function (
          callback,
          ignore = []
        ) {
          const view = this;
          const events = Cesium.ScreenSpaceEventType;
          const inputHandler = new Cesium.ScreenSpaceEventHandler(
            view.scene.canvas
          );
          if (!ignore || !Array.isArray(ignore)) ignore = [];

          Object.entries(events).forEach(function ([label, value]) {
            if (ignore.includes(label)) return;
            inputHandler.setInputAction(function () {
              callback();
              inputHandler.destroy();
            }, value);
          });
        },

        /**
         * Add all of the model's layers to the map. This function is called
         * during the render function.
         * @since 2.26.0
         */
        addLayers: function () {

          const view = this;

          // Add each layer from the Map model to the Cesium widget. Render
          // using the function configured in the View's mapAssetRenderFunctions
          // property. Add in reverse order for layers to appear in the correct
          // order on the map.
          const layers = view.model.get('layers')
          _.each(layers.last(layers.length).reverse(), function (mapAsset) {
            view.addAsset(mapAsset)
          });

          // The Cesium Widget will support just one terrain option to start.
          // Later, we'll allow users to switch between terrains if there is
          // more than one.
          var terrains = view.model.get('terrains')
          var terrainModel = terrains ? terrains.first() : false;
          if (terrainModel) {
            view.addAsset(terrainModel)
          }
        },

        /**
         * Because the Cesium widget is configured to use explicit rendering (see
         * {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/}),
         * we need to tell Cesium when to render a new frame if it's not one of the cases
         * handle automatically. This function tells the Cesium scene to render, but is
         * limited by the underscore.js debounce function to only happen a maximum of once
         * every 50 ms (see {@link https://underscorejs.org/#debounce}).
         */
        requestRender: _.debounce(function () {
          this.scene.requestRender()
        }, 50),

        /**
         * Functions called after each time the scene renders. If a zoom target has been
         * set by the {@link CesiumWidgetView#flyTo} function, then calls the functions
         * that calculates the bounding sphere and zooms to it (which required to visual
         * elements to be rendered first.)
         */
        postRender: function () {
          try {
            if (this.zoomTarget) {
              this.completeFlight(this.zoomTarget, this.zoomOptions)
              this.zoomTarget = null;
              this.zoomOptions = null;
            }
          }
          catch (error) {
            console.log(
              'There was an error calling post render functions in a CesiumWidgetView' +
              '. Error details: ' + error
            );
          }
        },

        /**
         * Runs on every Cesium clock tick. Updates the display of the CesiumVectorData
         * models in the scene. Similar to Cesium.DataSourceDisplay.update function, in
         * that it runs update() on each DataSource and each DataSource's visualizer,
         * except that it also updates each CesiumVectorData model's 'displayReady'
         * attribute. (Sets to true when the asset is ready to be rendered in the map,
         * false otherwise). Also re-renders the scene when the displayReady attribute
         * changes. 
         */
        updateDataSourceDisplay: function () {
          try {
            const view = this;
            const layers = view.model.get('layers')

            var dataSources = view.dataSourceDisplay.dataSources;
            if (!dataSources || !dataSources.length) {
              return
            }

            let allReady = true;
            const allReadyBefore = view.dataSourceDisplay._ready;

            for (let i = 0, len = dataSources.length; i &lt; len; i++) {

              const time = view.clock.currentTime;
              const dataSource = dataSources.get(i);
              const visualizers = dataSource._visualizers;

              const assetModel = layers.findWhere({
                cesiumModel: dataSource
              })
              const displayReadyBefore = assetModel.get('displayReady')
              let displayReadyNow = dataSource.update(time)

              for (let x = 0; x &lt; visualizers.length; x++) {
                displayReadyNow = visualizers[x].update(time) &amp;&amp; displayReadyNow;
              }

              assetModel.set('displayReady', displayReadyNow)

              allReady = displayReadyNow &amp;&amp; allReady

            }

            // If any dataSource has switched display states, then re-render the scene.
            if (allReady !== allReadyBefore) {
              view.scene.requestRender()
            }
            // The dataSourceDisplay must be set to 'ready' to get bounding spheres for
            // dataSources
            view.dataSourceDisplay._ready = allReady

          }
          catch (error) {
            console.log(
              'There was an error updating the data source display in a CesiumWidgetView' +
              '. Error details: ' + error
            );
          }
        },

        /**
         * Set up the Cesium scene and set listeners and behavior that enable users to
         * click on vector features on the map to view more information about them.
         */
        initializePicking: function () {
          try {
            // Save a reference to this view the Cesium scene
            var view = this;
            var scene = this.scene

            // To add an outline to 3D tiles in Cesium, we 'silhouette' them. Set up the the
            // scene to support silhouetting.
            view.silhouettes = Cesium.PostProcessStageLibrary.createEdgeDetectionStage();
            view.silhouettes.uniforms.color = view.highlightBorderColor;
            view.silhouettes.uniforms.length = 0.02;
            view.silhouettes.selected = [];
            scene.postProcessStages.add(
              Cesium.PostProcessStageLibrary.createSilhouetteStage([view.silhouettes])
            );
            // When any Feature models in the Map model's selectedFeature collection are
            // changed, added, or removed, update silhouetting of 3D tiles.
            function setSelectedFeaturesListeners() {
              const selectedFeatures = view.model.get('selectedFeatures')
              view.stopListening(selectedFeatures, 'update')
              view.listenTo(selectedFeatures, 'update', function () {
                // Remove highlights from previously selected 3D tiles
                view.silhouettes.selected = []
                // Highlight the newly selected 3D tiles
                selectedFeatures
                  .getFeatureObjects('Cesium3DTileFeature')
                  .forEach(function (featureObject) {
                    view.silhouettes.selected.push(featureObject)
                  })
              })
            }

            setSelectedFeaturesListeners()
            // If the Selected Features collection is ever completely replaced for any
            // reason, make sure to reset the listeners onto the new collection
            view.stopListening(view.model, 'change:selectedFeatures')
            view.listenTo(view.model, 'change:selectedFeatures', setSelectedFeaturesListeners)

            // When a feature is clicked update the Map model's `selectedFeatures`
            // collection with the newly selected features. This will also trigger an
            // event to update styling of map assets with selected features, and tells the
            // parent map view to open the feature details panel.
            view.inputHandler.setInputAction(function (movement) {
              const pickedFeature = scene.pick(movement.position);
              const action = view.model.get('clickFeatureAction');
              if (action === 'showDetails') {
                view.model.selectFeatures([pickedFeature])
              } else if (action === 'zoom') {
                view.flyTo(pickedFeature)
              }
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

          }
          catch (error) {
            console.log(
              'There was an error initializing picking in a CesiumWidgetView' +
              '. Error details: ' + error
            );
          }
        },

        /**
         * Move the camera position and zoom to the specified target entity or position on
         * the map, using a nice animation. This function starts the flying/zooming
         * action by setting a zoomTarget and zoomOptions on the view and requesting the
         * scene to render. The actual zooming is done by
         * {@link CesiumWidgetView#completeFlight} after the scene has finished rendering.
         * @param {MapAsset|Cesium.BoundingSphere|Object|Feature} target The target asset,
         * bounding sphere, or location to change the camera focus to. If target is a
         * MapAsset, then the bounding sphere from that asset will be used for the target
         * destination. If target is an Object, it may contain any of the properties that
         * are supported by the Cesium camera flyTo options, see
         * {@link https://cesium.com/learn/cesiumjs/ref-doc/Camera.html#flyTo}. If the
         * target is a Feature, then it must be a Feature of a CesiumVectorData layer
         * (currently Cesium3DTileFeatures are not supported). The target can otherwise be
         * a Cesium BoundingSphere, see
         * {@link https://cesium.com/learn/cesiumjs/ref-doc/BoundingSphere.html}
         * @param {object} options - For targets that are a bounding sphere or asset,
         * options to pass to Cesium Camera.flyToBoundingSphere(). See
         * {@link https://cesium.com/learn/cesiumjs/ref-doc/Camera.html#flyToBoundingSphere}.
         */
        flyTo: function (target, options) {
          this.zoomTarget = target;
          this.zoomOptions = options;
          this.requestRender();
        },

        /**
         * This function is called by {@link CesiumWidgetView#postRender}; it should only
         * be called once the target has been fully rendered in the scene. This function
         * gets the bounding sphere, if required, and moves the scene to encompass the
         * full extent of the target.
         * @param {MapAsset|Cesium.BoundingSphere|Object|Feature} target The target asset,
         * bounding sphere, or location to change the camera focus to. If target is a
         * MapAsset, then the bounding sphere from that asset will be used for the target
         * destination. If target is an Object, it may contain any of the properties that
         * are supported by the Cesium camera flyTo options, see
         * {@link https://cesium.com/learn/cesiumjs/ref-doc/Camera.html#flyTo}. If the
         * target is a Feature, then it must be a Feature of a CesiumVectorData layer
         * (currently Cesium3DTileFeatures are not supported). The target can otherwise be
         * a Cesium BoundingSphere, see
         * {@link https://cesium.com/learn/cesiumjs/ref-doc/BoundingSphere.html}
         * @param {object} options - For targets that are a bounding sphere or asset,
         * options to pass to Cesium Camera.flyToBoundingSphere(). See
         * {@link https://cesium.com/learn/cesiumjs/ref-doc/Camera.html#flyToBoundingSphere}.
         */
        completeFlight: function (target, options) {

          try {

            const view = this;
            if (typeof options !== 'object') options = {}

            // A target is required
            if (!target) {
              return
            }

            // If the target is a Bounding Sphere, use the camera's built-in function
            if (target instanceof Cesium.BoundingSphere) {
              view.camera.flyToBoundingSphere(target, options)
              return
            }

            // If the target is some type of map asset, then get a Bounding Sphere for
            // that asset and call this function again.
            if (target instanceof MapAsset &amp;&amp; typeof target.getBoundingSphere === 'function') {
              // Pass the dataSourceDisplay for CesiumVectorData models
              target.getBoundingSphere(view.dataSourceDisplay)
                .then(function (assetBoundingSphere) {
                  // Base value offset required to zoom in close enough to 3D tiles for
                  // them to render.
                  if ((target instanceof Cesium3DTileset) &amp;&amp; !Cesium.defined(options.offset)) {
                    options.offset = new Cesium.HeadingPitchRange(
                      0.0, -0.5, assetBoundingSphere.radius
                    )
                  }
                  view.flyTo(assetBoundingSphere, options)
                })
              return
            }

            // Note: This doesn't work yet for Cesium3DTilesetFeatures -
            // Cesium.BoundingSphereState gets stuck in "PENDING" and never resolves.
            // There's no native way of getting the bounding sphere or location from a
            // 3DTileFeature!
            if (target instanceof Feature) {
              // If the object saved in the Feature is an Entity, then this
              // function will get the bounding sphere for the entity on the
              // next run.
              setTimeout(() => {
                view.flyTo(target.get('featureObject'), options)
              }, 0);
              return
            }

            // If the target is a Cesium Entity, then get the bounding sphere for the
            // entity and call this function again.
            const entity = target instanceof Cesium.Entity ? target : target.id;
            if (entity instanceof Cesium.Entity) {
              let entityBoundingSphere = new Cesium.BoundingSphere();
              view.dataSourceDisplay.getBoundingSphere(
                entity, false, entityBoundingSphere
              )
              setTimeout(() => {
                view.flyTo(entityBoundingSphere, options)
              }, 0);
              return
            }

            // If not a Map Asset or a BoundingSphere, then the target must be an Object.
            // Assume target are options for the Cesium camera flyTo function
            if (typeof target === 'object') {
              view.camera.flyTo(target)
            }

          }
          catch (e) {
            console.log('Failed to navigate to a target in Cesium.', e);
          }
        },

        /**
         * Navigate to the homePosition that's set on the Map.
         * @param {number} duration The duration of the flight in seconds.
         */
        flyHome: function (duration) {
          try {
            var position = this.model.get('homePosition')

            if (position &amp;&amp; Cesium.defined(position.longitude) &amp;&amp; Cesium.defined(position.latitude)) {

              // Set a default height (elevation) if there isn't one set
              if (!Cesium.defined(position.height)) {
                position.height = 1000000;
              }

              const target = {}
              target.destination = Cesium.Cartesian3.fromDegrees(
                position.longitude,
                position.latitude,
                position.height
              )

              if (
                Cesium.defined(position.heading) &amp;&amp;
                Cesium.defined(position.pitch) &amp;&amp;
                Cesium.defined(position.roll)
              ) {
                target.orientation = {
                  heading: Cesium.Math.toRadians(position.heading),
                  pitch: Cesium.Math.toRadians(position.pitch),
                  roll: Cesium.Math.toRadians(position.roll)
                }
              }
              if (Cesium.defined(duration)) {
                target.duration = duration
              }

              this.flyTo(target);
            }
          }
          catch (error) {
            console.log(
              'There was an error navigating to the home position in a CesiumWidgetView' +
              '. Error details: ' + error
            );
          }
        },

        /**
         * Get the current positioning of the camera in the view.
         * @returns {MapConfig#CameraPosition} Returns an object with the longitude, latitude,
         * height, heading, pitch, and roll in the same format that the Map model uses
         * for the homePosition (see {@link Map#defaults})
        */
        getCameraPosition: function () {
          try {
            return this.getDegreesFromCartesian(this.camera.position)
          }
          catch (error) {
            console.log(
              'There was an error getting the current position in a CesiumWidgetView' +
              '. Error details: ' + error
            );
          }
        },

        /**
         * Update the 'currentViewExtent' attribute in the Map model with the
         * bounding box of the currently visible area of the map.
         */
        updateViewExtent: function () {
          try { this.model.set('currentViewExtent', this.getViewExtent()) }
          catch (e) { console.log('Failed to update the Map view extent.', e) }
        },

        /**
         * Get the north, south, east, and west-most lat/long that define a
         * bounding box around the currently visible area of the map. Also gives
         * the height/ altitude of the camera in meters.
         * @returns {MapConfig#ViewExtent} The current view extent.
         */
        getViewExtent: function () {
          const view = this;
          const scene = view.scene;
          const camera = view.camera;
          // Get the height in meters
          const height = camera.positionCartographic.height

          // This will be the bounding box of the visible area
          let coords = {
            north: null, south: null, east: null, west: null, height: height
          }

          // First try getting the visible bounding box using the simple method
          if (!view.scratchRectangle) {
            // Store the rectangle that we use for the calculation (reduces pressure on
            // garbage collector system since this function is called often).
            view.scratchRectangle = new Cesium.Rectangle();
          }
          var rect = camera.computeViewRectangle(
            scene.globe.ellipsoid, view.scratchRectangle
          );
          coords.north = Cesium.Math.toDegrees(rect.north)
          coords.east = Cesium.Math.toDegrees(rect.east)
          coords.south = Cesium.Math.toDegrees(rect.south)
          coords.west = Cesium.Math.toDegrees(rect.west)

          // Check if the resulting coordinates cover the entire globe (happens
          // if some of the sky is visible). If so, limit the bounding box to a
          // smaller extent
          if (view.coversGlobe(coords)) {

            // Find points at the top, bottom, right, and left corners of the globe
            const edges = view.findEdges()

            // Get the midPoint between the top and bottom points on the globe. Use this
            // to decide if the northern or southern hemisphere is more in view.
            let midPoint = view.findMidpoint(edges.top, edges.bottom)
            if (midPoint) {

              // Get the latitude of the mid point
              const midPointLat = view.getDegreesFromCartesian(midPoint).latitude

              // Get the latitudes of all the edge points so that we can calculate the
              // southern and northern most coordinate
              const edgeLatitudes = []
              Object.values(edges).forEach(function (point) {
                if (point) {
                  edgeLatitudes.push(
                    view.getDegreesFromCartesian(point).latitude
                  )
                }
              })

              if (midPointLat > 0) {
                // If the midPoint is in the northern hemisphere, limit the southern part
                // of the bounding box to the southern most edge point latitude
                coords.south = Math.min(...edgeLatitudes)
              } else {
                // Vice versa for the southern hemisphere
                coords.north = Math.max(...edgeLatitudes)
              }
            }

            // If not focused directly on one of the poles, then also limit the east and
            // west sides of the bounding box
            const northPointLat = view.getDegreesFromCartesian(edges.top).latitude
            const southPointLat = view.getDegreesFromCartesian(edges.bottom).latitude

            if (northPointLat > 25 &amp;&amp; southPointLat &lt; -25) {
              if (edges.right) {
                coords.east = view.getDegreesFromCartesian(edges.right).longitude
              }
              if (edges.left) {
                coords.west = view.getDegreesFromCartesian(edges.left).longitude
              }
            }
          }

          return coords
        },

        /**
         * Check if a given bounding box covers the entire globe.
         * @param {Object} coords - An object with the north, south, east, and
         * west coordinates of a bounding box
         * @param {Number} latAllowance - The number of degrees latitude to
         * allow as a buffer. If the north and south coords range from -90 to
         * 90, minus this buffer * 2, then it is considered to cover the globe.
         * @param {Number} lonAllowance - The number of degrees longitude to
         * allow as a buffer.
         * @returns {Boolean} Returns true if the bounding box covers the entire
         * globe, false otherwise.
         */ 
        coversGlobe: function (coords, latAllowance = 0.5, lonAllowance = 1) {
          const maxLat = 90 - latAllowance;
          const minLat = -90 + latAllowance;
          const maxLon = 180 - lonAllowance;
          const minLon = -180 + lonAllowance;

          return coords.west &lt;= minLon &amp;&amp;
            coords.east >= maxLon &amp;&amp;
            coords.south &lt;= minLat &amp;&amp;
            coords.north >= maxLat
        },

        /**
         * Get longitude and latitude degrees from a cartesian point.
         * @param {Cesium.Cartesian3} cartesian - The point to get degrees for
         * @returns Returns an object with the longitude and latitude in degrees, as well
         * as the height in meters
         */
        getDegreesFromCartesian: function (cartesian) {
          const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
          const degrees = {
            height: cartographic.height
          }
          const coordinates = ['longitude', 'latitude', 'heading', 'pitch', 'roll']
          coordinates.forEach(function (coordinate) {
            if (Cesium.defined(cartographic[coordinate])) {
              degrees[coordinate] = Cesium.Math.toDegrees(cartographic[coordinate])
            }
          });
          return degrees
        },

        /**
         * Find four points that exist on the globe that are closest to the top-center,
         * bottom-center, right-middle, and left-middle points of the screen. Note that
         * these are not necessarily the northern, southern, eastern, and western -most
         * points, since the map may be oriented in any direction (e.g. facing the north
         * pole).
         *
         * @returns {Cesium.Cartesian3[]} Returns an object with the top, bottom, left,
         * and right points of the globe.
         */
        findEdges: function () {
          try {
            const view = this;
            const canvas = view.scene.canvas
            const maxX = canvas.clientWidth;
            const maxY = canvas.clientHeight;
            const midX = (maxX / 2) | 0;
            const midY = (maxY / 2) | 0;

            // Points at the extreme edges of the cesium canvas. These may not be points on
            // the globe (i.e. they could be in the sky)
            const topCanvas = new Cesium.Cartesian2(midX, 0)
            const rightCanvas = new Cesium.Cartesian2(maxX, midY)
            const bottomCanvas = new Cesium.Cartesian2(midX, maxY)
            const leftCanvas = new Cesium.Cartesian2(0, midY)

            // Find the real world coordinate that is closest to the canvas edge points
            const points = {
              top: view.findPointOnGlobe(topCanvas, bottomCanvas),
              right: view.findPointOnGlobe(rightCanvas, leftCanvas),
              bottom: view.findPointOnGlobe(bottomCanvas, topCanvas),
              left: view.findPointOnGlobe(leftCanvas, rightCanvas),
            }

            return points
          }
          catch (error) {
            console.log(
              'There was an error finding the edge points in a CesiumWidgetView' +
              '. Error details: ' + error
            );
          }
        },

        /**
         * Given two Cartesian3 points, compute the midpoint.
         * @param {Cesium.Cartesian3} p1  The first point
         * @param {Cesium.Cartesian3} p2  The second point
         * @returns {Cesium.Cartesian3 | null} The midpoint or null if p1 or p2 is not
         * defined.
         */
        findMidpoint: function (p1, p2) {
          try {
            if (!p1 || !p2) {
              return null
            }
            // Compute vector from p1 to p2
            let p1p2 = new Cesium.Cartesian3(0.0, 0.0, 0.0);
            Cesium.Cartesian3.subtract(p2, p1, p1p2);

            // Compute vector to midpoint
            let halfp1p2 = new Cesium.Cartesian3(0.0, 0.0, 0.0);
            Cesium.Cartesian3.multiplyByScalar(p1p2, 0.5, halfp1p2);

            // Compute point half way between p1 and p2
            let p3 = new Cesium.Cartesian3(0.0, 0.0, 0.0);
            p3 = Cesium.Cartesian3.add(p1, halfp1p2, p3);

            // Force point onto surface of ellipsoid
            const midPt = Cesium.Cartographic.fromCartesian(p3);
            const p3a = Cesium.Cartesian3.fromRadians(midPt.longitude, midPt.latitude, 0.0);

            return p3a
          }
          catch (error) {
            console.log(
              'There was an error finding a midpoint in a CesiumWidgetView' +
              '. Error details: ' + error
            );
          }
        },

        /**
         * Find a coordinate that exists on the surface of the globe between two Cartesian
         * points. The points do not need to be withing the bounds of the globe/map (i.e.
         * they can be points in the sky). Uses the Bresenham Algorithm to traverse pixels
         * from the first coordinate to the second, until it finds a valid coordinate.
         * @param {Cesium.Cartesian2} startCoordinates The coordinates to start searching,
         * in pixels
         * @param {Cesium.Cartesian2} endCoordinates The coordinates to stop searching, in
         * pixels
         * @returns {Cesium.Cartesian3 | null} Returns the x, y, z coordinates of the
         * first real point, or null if a valid point was not found.
         *
         * @see {@link https://groups.google.com/g/cesium-dev/c/e2H7EefikAk}
         */
        findPointOnGlobe: function (startCoordinates, endCoordinates) {

          const view = this;
          const camera = view.camera;
          const ellipsoid = view.scene.globe.ellipsoid;

          if (!startCoordinates || !endCoordinates) {
            return null
          }

          let coordinate = camera.pickEllipsoid(startCoordinates, ellipsoid);

          // Translate coordinates
          let x1 = startCoordinates.x;
          let y1 = startCoordinates.y;
          const x2 = endCoordinates.x;
          const y2 = endCoordinates.y;
          // Define differences and error check
          const dx = Math.abs(x2 - x1);
          const dy = Math.abs(y2 - y1);
          const sx = (x1 &lt; x2) ? 1 : -1;
          const sy = (y1 &lt; y2) ? 1 : -1;
          let err = dx - dy;

          coordinate = camera.pickEllipsoid({ x: x1, y: y1 }, ellipsoid);
          if (coordinate) {
            return coordinate
          }

          // Main loop
          while (!((x1 == x2) &amp;&amp; (y1 == y2))) {
            const e2 = err &lt;&lt; 1;
            if (e2 > -dy) {
              err -= dy;
              x1 += sx;
            }
            if (e2 &lt; dx) {
              err += dx;
              y1 += sy;
            }

            coordinate = camera.pickEllipsoid({ x: x1, y: y1 }, ellipsoid);
            if (coordinate) {
              return coordinate
            }
          }

          return null;
        },

        /**
         * Set a Cesium event handler for when the mouse moves. If the scale bar is
         * enabled, then a updates the Map model's current position attribute whenever the
         * mouse moves. If showFeatureInfo is enabled, then changes the cursor to a
         * pointer when it hovers over a feature.
         */
        setMouseMoveListeners: function () {
          try {

            const view = this;

            // Change the cursor to a pointer when it hovers over a clickable feature
            // (e.g. a 3D tile) if picking is enabled.
            const updateCursor = function (mousePosition) {
              var pickedFeature = view.scene.pick(mousePosition);
              if (Cesium.defined(pickedFeature)) {
                view.el.style.cursor = 'pointer';
              } else {
                view.el.style.cursor = 'default';
              }
            }

            // Slow this function down a little. Picking is quite slow.
            const updateCursorThrottled = _.throttle(updateCursor, 150)

            // Update the model with long and lat when the mouse moves, if the map model
            // is set to show the scale bar
            const setCurrentPosition = function (mousePosition) {
              var pickRay = view.camera.getPickRay(mousePosition);
              var cartesian = view.scene.globe.pick(pickRay, view.scene);
              if (cartesian) {
                view.model.set('currentPosition', view.getDegreesFromCartesian(cartesian))
              }
            }

            // Handle mouse move
            this.inputHandler.setInputAction(function (movement) {
              const mousePosition = movement.endPosition;
              if (view.model.get('showScaleBar')) {
                setCurrentPosition(mousePosition)
              }
              if (view.model.get('showFeatureInfo')) {
                updateCursorThrottled(mousePosition)
              }
            }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

          }
          catch (error) {
            console.log(
              'There was an error setting the mouse listeners in a CesiumWidgetView' +
              '. Error details: ' + error
            );
          }
        },

        /**
         * Update the map model's currentScale attribute, which is used for the scale bar.
         * Finds the distance between two pixels at the *bottom center* of the screen.
         */
        updateCurrentScale: function () {
          try {
            const view = this;
            let currentScale = {
              pixels: null,
              meters: null
            }
            const onePixelInMeters = view.pixelToMeters()
            if (onePixelInMeters || onePixelInMeters === 0) {
              currentScale = {
                pixels: 1,
                meters: onePixelInMeters
              }
            }
            view.model.set('currentScale', currentScale);
          }
          catch (error) {
            console.log(
              'There was an error updating the scale from a CesiumWidgetView' +
              '. Error details: ' + error
            );
          }
        },

        /**
         * Finds the geodesic distance (in meters) between two points that are 1 pixel
         * apart at the bottom, center of the Cesium canvas. Adapted from TerriaJS. See
         * {@link https://github.com/TerriaJS/terriajs/blob/main/lib/ReactViews/Map/Legend/DistanceLegend.jsx}
         * @returns {number|boolean} Returns the distance on the globe, in meters, that is
         * equivalent to 1 pixel on the screen at the center bottom point of the current
         * scene. Returns false if there was a problem getting the measurement.
         */
        pixelToMeters: function () {
          try {

            const view = this
            const scene = view.scene
            const globe = scene.globe
            const camera = scene.camera

            // For measuring geodesic distances (shortest route between two points on the
            // Earth's surface)
            if (!view.geodesic) {
              view.geodesic = new Cesium.EllipsoidGeodesic();
            }

            // Find two points that are 1 pixel apart at the bottom center of the cesium
            // canvas.
            const width = scene.canvas.clientWidth;
            const height = scene.canvas.clientHeight;

            const left = camera.getPickRay(
              new Cesium.Cartesian2((width / 2) | 0, height - 1)
            );
            const right = camera.getPickRay(
              new Cesium.Cartesian2((1 + width / 2) | 0, height - 1)
            );

            const leftPosition = globe.pick(left, scene);
            const rightPosition = globe.pick(right, scene);

            // A point must exist at both positions to get the distance
            if (!Cesium.defined(leftPosition) || !Cesium.defined(rightPosition)) {
              return false
            }

            // Find the geodesic distance, in meters, between the two points that are 1
            // pixel apart
            const leftCartographic = globe.ellipsoid.cartesianToCartographic(
              leftPosition
            );
            const rightCartographic = globe.ellipsoid.cartesianToCartographic(
              rightPosition
            );

            view.geodesic.setEndPoints(leftCartographic, rightCartographic);

            const onePixelInMeters = view.geodesic.surfaceDistance;

            return onePixelInMeters

          }
          catch (error) {
            console.log(
              'Failed to get a pixel to meters measurement in a CesiumWidgetView' +
              '. Error details: ' + error
            );
            return false
          }
        },

        /**
         * Finds the function that is configured for the given asset model type in the
         * {@link CesiumWidgetView#mapAssetRenderFunctions} array, then renders the asset
         * in the map. If there is a problem rendering the asset (e.g. it is an
         * unsupported type that is not configured in the mapAssetRenderFunctions), then
         * sets the AssetModel's status to error.
         * @param {MapAsset} mapAsset A MapAsset layer to render in the map, such as a
         * Cesium3DTileset or a CesiumImagery model.
         */
        addAsset: function (mapAsset) {
          try {
            if (!mapAsset) {
              return
            }
            var view = this
            var type = mapAsset.get('type')
            // Find the render option from the options configured in the view, given the
            // asset model type
            const renderOption = _.find(view.mapAssetRenderFunctions, function (option) {
              return option.types.includes(type)
            }) || {};
            // Get the function for this type
            const renderFunction = view[renderOption.renderFunction]

            // If the cesium widget does not have a way to display this error, update the
            // error status in the model (this will be reflected in the LayerListView)
            if (!renderFunction || typeof renderFunction !== 'function') {
              mapAsset.set('statusDetails', 'This type of resource is not supported in the map widget.')
              mapAsset.set('status', 'error')
              return
            }

            // The asset should be visible and the cesium model should be ready before
            // starting to render the asset
            const checkAndRenderAsset = function () {
              let shouldRender = mapAsset.get('visible') &amp;&amp; mapAsset.get('status') === 'ready'
              if (shouldRender) {
                renderFunction.call(view, mapAsset.get('cesiumModel'))
                view.stopListening(mapAsset)
              }
            }

            checkAndRenderAsset()

            if (!mapAsset.get('visible')) {
              view.listenToOnce(mapAsset, 'change:visible', checkAndRenderAsset)
            }

            if (mapAsset.get('status') !== 'ready') {
              view.listenTo(mapAsset, 'change:status', checkAndRenderAsset)
            }

          }
          catch (error) {
            console.error(
              'There was an error rendering an asset in a CesiumWidgetView' +
              '. Error details: ' + error
            );
            mapAsset.set('statusDetails', 'There was a problem rendering this resource in the map widget.')
            mapAsset.set('status', 'error')
          }
        },

        /**
         * Renders peaks and valleys in the 3D version of the map, given a terrain model.
         * If a terrain model has already been set on the map, this will replace it.
         * @param {Cesium.TerrainProvider} cesiumModel a Cesium Terrain Provider model to
         * use for the map
        */
        updateTerrain: function (cesiumModel) {
          this.scene.terrainProvider = cesiumModel
          this.requestRender();
        },

        /**
         * Renders a 3D tileset in the map.
         * @param {Cesium.Cesium3DTileset} cesiumModel The Cesium 3D tileset model that
         * contains the information about the 3D tiles to render in the map
        */
        add3DTileset: function (cesiumModel) {
          this.scene.primitives.add(cesiumModel)
        },

        /**
         * Renders vector data (excluding 3D tilesets) in the Map.
         * @param {Cesium.GeoJsonDataSource} cesiumModel - The Cesium data source
         * model to render on the map
         */
        addVectorData: function (cesiumModel) {
          this.dataSourceCollection.add(cesiumModel)
        },

        /**
         * Renders imagery in the Map.
         * @param {Cesium.ImageryLayer} cesiumModel The Cesium imagery model to render
         */
        addImagery: function (cesiumModel) {
          this.scene.imageryLayers.add(cesiumModel)
          this.sortImagery()
        },

        /**
         * Arranges the imagery that is rendered the Map according to the order
         * that the imagery is arranged in the layers collection.
         * @since 2.21.0
         */
        sortImagery() {
          try {
            const imageryInMap = this.scene.imageryLayers
            const imageryModels = this.model.get('layers').getAll('CesiumImagery')

            // If there are no imagery layers, or just one, return
            if (
              !imageryInMap || !imageryModels ||
              imageryInMap.length &lt;= 1 || imageryModels.length &lt;= 1
            ) {
              return
            }

            // If there are more than one imagery layer, arrange them in the order that
            // they were added to the map
            for (let i = 0; i &lt; imageryModels.length; i++) {
              const cesiumModel = imageryModels[i].get('cesiumModel')
              if (cesiumModel) {
                if (imageryInMap.contains(cesiumModel)) {
                  imageryInMap.lowerToBottom(cesiumModel)
                }
              }
            }
          }
          catch (error) {
            console.log(
              'There was an error sorting displayed imagery in a CesiumWidgetView' +
              '. Error details: ' + error
            );
          }
        },

        /**
         * Display a box around every rendered tile in the tiling scheme, and
         * draw a label inside it indicating the X, Y, Level indices of the
         * tile. This is mostly useful for debugging terrain and imagery
         * rendering problems. This function should be called after the other
         * imagery layers have been added to the map, e.g. at the end of the
         * render function.
         * @param {string} [color='#ffffff'] The color of the grid outline and
         * labels. Must be a CSS color string, beginning with a #.
         * @param {'GeographicTilingScheme'|'WebMercatorTilingScheme'}
         *  [tilingScheme='GeographicTilingScheme'] The tiling scheme to use.
         *  Defaults to GeographicTilingScheme.
         */
        showImageryGrid: function (
          color = '#ffffff',
          tilingScheme = 'GeographicTilingScheme'
        ) {
          try {
            const view = this
            // Check the color is valid
            if (!color || typeof color !== 'string' || !color.startsWith('#')) {
              console.log(`${color} is an invalid color for imagery grid. ` +
                `Must be a hex color starting with '#'. ` +
                `Setting color to white: '#ffffff'`)
              color = '#ffffff'
            }

            // Check the tiling scheme is valid
            const availableTS = ['GeographicTilingScheme', 'WebMercatorTilingScheme']
            if (availableTS.indexOf(tilingScheme) == -1) {
              console.log(`${tilingScheme} is not a valid tiling scheme ` +
                `for the imagery grid. Using WebMercatorTilingScheme`)
              tilingScheme = 'WebMercatorTilingScheme'
            }

            // Create the imagery grid
            const gridOpts = {
              tilingScheme: new Cesium[tilingScheme](),
              color: Cesium.Color.fromCssColorString(color)
            }

            const gridOutlines = new Cesium.GridImageryProvider(gridOpts)
            const gridCoords = new Cesium.TileCoordinatesImageryProvider(gridOpts)
            view.scene.imageryLayers.addImageryProvider(gridOutlines)
            view.scene.imageryLayers.addImageryProvider(gridCoords)
          }
          catch (error) {
            console.log(
              'There was an error showing the imagery grid in a CesiumWidgetView' +
              '. Error details: ' + error
            );
          }
        }

      }
    );

    return CesiumWidgetView;

  }
);
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
