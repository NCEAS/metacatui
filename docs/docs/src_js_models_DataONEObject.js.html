<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>MetacatUI Dev Docs: Source: src/js/models/DataONEObject.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="/assets/css/styles.css">
    <link type="text/css" rel="stylesheet" href="styles/style.css">
</head>

<body>

<nav id="nav">
    <a href="/">
      <div class="logo">
<svg class="cat" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="cat" class="svg-inline--fa fa-cat fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M290.59 192c-20.18 0-106.82 1.98-162.59 85.95V192c0-52.94-43.06-96-96-96-17.67 0-32 14.33-32 32s14.33 32 32 32c17.64 0 32 14.36 32 32v256c0 35.3 28.7 64 64 64h176c8.84 0 16-7.16 16-16v-16c0-17.67-14.33-32-32-32h-32l128-96v144c0 8.84 7.16 16 16 16h32c8.84 0 16-7.16 16-16V289.86c-10.29 2.67-20.89 4.54-32 4.54-61.81 0-113.52-44.05-125.41-102.4zM448 96h-64l-64-64v134.4c0 53.02 42.98 96 96 96s96-42.98 96-96V32l-64 64zm-72 80c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16zm80 0c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16z"></path></svg>

<svg width="459px" height="53px" viewBox="0 0 459 53" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="metacatui" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M16.492,52 C17.212,52 17.812,51.748 18.292,51.244 C18.772,50.74 19.012,50.128 19.012,49.408 L19.012,49.408 L18.94,22.912 L30.82,37.816 C31.204,38.344 31.72,38.764 32.368,39.076 C33.016,39.388 33.7,39.544 34.42,39.544 C35.908,39.544 37.132,38.896 38.092,37.6 L38.092,37.6 L49.684,22.912 L49.684,49.408 C49.684,50.128 49.96,50.74 50.512,51.244 C51.064,51.748 51.7,52 52.42,52 L52.42,52 L62.068,52 C62.788,52 63.388,51.748 63.868,51.244 C64.348,50.74 64.588,50.128 64.588,49.408 L64.588,49.408 L64.588,4.12 C64.588,3.448 64.336,2.86 63.832,2.356 C63.328,1.852 62.74,1.6 62.068,1.6 L62.068,1.6 L52.348,1.6 C51.388,1.6 50.56,1.648 49.864,1.744 C49.168,1.84 48.532,2.152 47.956,2.68 L47.956,2.68 L33.916,17.296 L20.524,2.608 C20.332,2.368 19.972,2.14 19.444,1.924 C18.916,1.708 18.412,1.6 17.932,1.6 L17.932,1.6 L6.772,1.6 C6.052,1.6 5.44,1.852 4.936,2.356 C4.432,2.86 4.18,3.448 4.18,4.12 L4.18,4.12 L4.18,49.408 C4.18,50.08 4.432,50.68 4.936,51.208 C5.44,51.736 6.052,52 6.772,52 L6.772,52 L16.492,52 Z M110.74,52 C111.556,52 112.264,51.676 112.864,51.028 C113.464,50.38 113.764,49.624 113.764,48.76 L113.764,48.76 L113.764,42.568 C113.764,41.608 113.464,40.828 112.864,40.228 C112.264,39.628 111.556,39.328 110.74,39.328 L110.74,39.328 L89.428,39.328 L89.428,32.92 L109.732,32.92 C110.5,32.92 111.184,32.596 111.784,31.948 C112.384,31.3 112.684,30.568 112.684,29.752 L112.684,29.752 L112.684,23.488 C112.684,22.576 112.384,21.82 111.784,21.22 C111.184,20.62 110.5,20.32 109.732,20.32 L109.732,20.32 L89.428,20.32 L89.428,14.488 L110.74,14.488 C111.508,14.488 112.204,14.164 112.828,13.516 C113.452,12.868 113.764,12.136 113.764,11.32 L113.764,11.32 L113.764,5.056 C113.764,4.144 113.464,3.388 112.864,2.788 C112.264,2.188 111.556,1.888 110.74,1.888 L110.74,1.888 L76.756,1.888 C75.94,1.888 75.232,2.188 74.632,2.788 C74.032,3.388 73.732,4.144 73.732,5.056 L73.732,5.056 L73.732,48.76 C73.732,49.624 74.032,50.38 74.632,51.028 C75.232,51.676 75.94,52 76.756,52 L76.756,52 L110.74,52 Z M147.604,52 C148.42,52 149.104,51.688 149.656,51.064 C150.208,50.44 150.484,49.672 150.484,48.76 L150.484,48.76 L150.484,16.216 L161.86,16.216 C162.676,16.216 163.396,15.904 164.02,15.28 C164.644,14.656 164.956,13.936 164.956,13.12 L164.956,13.12 L164.956,4.768 C164.956,4 164.644,3.316 164.02,2.716 C163.396,2.116 162.676,1.816 161.86,1.816 L161.86,1.816 L124.132,1.816 C123.22,1.816 122.464,2.104 121.864,2.68 C121.264,3.256 120.964,3.952 120.964,4.768 L120.964,4.768 L120.964,13.12 C120.964,13.936 121.264,14.656 121.864,15.28 C122.464,15.904 123.22,16.216 124.132,16.216 L124.132,16.216 L135.652,16.216 L135.148,48.832 C135.148,49.744 135.424,50.5 135.976,51.1 C136.528,51.7 137.212,52 138.028,52 L138.028,52 L147.604,52 Z M175.828,52 C176.836,52 177.676,51.82 178.348,51.46 C179.02,51.1 179.452,50.584 179.644,49.912 L179.644,49.912 L181.876,42.712 L197.932,42.712 L200.164,49.912 C200.356,50.584 200.8,51.1 201.496,51.46 C202.192,51.82 203.044,52 204.052,52 L204.052,52 L213.916,52 C215.836,51.712 216.796,50.704 216.796,48.976 C216.796,48.304 216.676,47.596 216.436,46.852 C216.196,46.108 216.052,45.616 216.004,45.376 L216.004,45.376 L199.876,4.84 C199.588,3.976 199.036,3.232 198.22,2.608 C197.404,1.984 196.372,1.648 195.124,1.6 L195.124,1.6 L184.756,1.6 C183.604,1.648 182.608,1.948 181.768,2.5 C180.928,3.052 180.292,3.832 179.86,4.84 L179.86,4.84 L163.876,45.376 C163.828,45.472 163.672,45.916 163.408,46.708 C163.144,47.5 163.012,48.304 163.012,49.12 C163.012,50.752 163.948,51.712 165.82,52 L165.82,52 L175.828,52 Z M195.34,30.544 L184.036,30.544 L189.652,13.624 L195.34,30.544 Z M245.38,53.08 C250.612,53.08 255.652,51.544 260.5,48.472 C261.22,47.944 261.58,47.296 261.58,46.528 C261.58,45.808 261.292,45.16 260.716,44.584 L260.716,44.584 L252.796,36.808 C252.364,36.376 251.836,36.16 251.212,36.16 C250.78,36.16 250.372,36.256 249.988,36.448 C248.356,37.12 246.796,37.456 245.308,37.456 C243.244,37.456 241.348,36.952 239.62,35.944 C237.892,34.936 236.512,33.58 235.48,31.876 C234.448,30.172 233.932,28.336 233.932,26.368 C233.932,24.352 234.436,22.504 235.444,20.824 C236.452,19.144 237.832,17.812 239.584,16.828 C241.336,15.844 243.244,15.352 245.308,15.352 C246.892,15.352 248.332,15.64 249.628,16.216 C250.012,16.408 250.444,16.504 250.924,16.504 C251.548,16.504 252.1,16.264 252.58,15.784 L252.58,15.784 L259.636,8.008 C260.164,7.384 260.428,6.76 260.428,6.136 C260.428,5.224 259.996,4.528 259.132,4.048 C254.86,1.552 250.276,0.304 245.38,0.304 C240.532,0.304 236.032,1.492 231.88,3.868 C227.728,6.244 224.44,9.448 222.016,13.48 C219.592,17.512 218.38,21.904 218.38,26.656 C218.38,31.408 219.592,35.812 222.016,39.868 C224.44,43.924 227.728,47.14 231.88,49.516 C236.032,51.892 240.532,53.08 245.38,53.08 Z M279.796,52 C280.804,52 281.644,51.82 282.316,51.46 C282.988,51.1 283.42,50.584 283.612,49.912 L283.612,49.912 L285.844,42.712 L301.9,42.712 L304.132,49.912 C304.324,50.584 304.768,51.1 305.464,51.46 C306.16,51.82 307.012,52 308.02,52 L308.02,52 L317.884,52 C319.804,51.712 320.764,50.704 320.764,48.976 C320.764,48.304 320.644,47.596 320.404,46.852 C320.164,46.108 320.02,45.616 319.972,45.376 L319.972,45.376 L303.844,4.84 C303.556,3.976 303.004,3.232 302.188,2.608 C301.372,1.984 300.34,1.648 299.092,1.6 L299.092,1.6 L288.724,1.6 C287.572,1.648 286.576,1.948 285.736,2.5 C284.896,3.052 284.26,3.832 283.828,4.84 L283.828,4.84 L267.844,45.376 C267.796,45.472 267.64,45.916 267.376,46.708 C267.112,47.5 266.98,48.304 266.98,49.12 C266.98,50.752 267.916,51.712 269.788,52 L269.788,52 L279.796,52 Z M299.308,30.544 L288.004,30.544 L293.62,13.624 L299.308,30.544 Z M352.588,52 C353.404,52 354.088,51.688 354.64,51.064 C355.192,50.44 355.468,49.672 355.468,48.76 L355.468,48.76 L355.468,16.216 L366.844,16.216 C367.66,16.216 368.38,15.904 369.004,15.28 C369.628,14.656 369.94,13.936 369.94,13.12 L369.94,13.12 L369.94,4.768 C369.94,4 369.628,3.316 369.004,2.716 C368.38,2.116 367.66,1.816 366.844,1.816 L366.844,1.816 L329.116,1.816 C328.204,1.816 327.448,2.104 326.848,2.68 C326.248,3.256 325.948,3.952 325.948,4.768 L325.948,4.768 L325.948,13.12 C325.948,13.936 326.248,14.656 326.848,15.28 C327.448,15.904 328.204,16.216 329.116,16.216 L329.116,16.216 L340.636,16.216 L340.132,48.832 C340.132,49.744 340.408,50.5 340.96,51.1 C341.512,51.7 342.196,52 343.012,52 L343.012,52 L352.588,52 Z M402.052,52.792 C408.1,52.792 412.912,51.628 416.488,49.3 C420.064,46.972 422.536,44.068 423.904,40.588 C425.272,37.108 425.932,33.424 425.884,29.536 C425.884,29.5309474 425.883967,29.5237673 425.8839,29.5144598 L425.883102,29.4330859 C425.879911,29.1480111 425.868211,28.3183158 425.848,26.944 C425.8294,25.6792 425.818008,22.91524 425.813823,18.65212 L425.813103,17.80828 C425.812997,17.66452 425.8129,17.5192 425.81281,17.37232 L425.812,3.904 C425.86,3.184 425.632,2.62 425.128,2.212 C424.624,1.804 423.916,1.6 423.004,1.6 L423.004,1.6 L413.428,1.6 C412.612,1.6 411.904,1.828 411.304,2.284 C410.704,2.74 410.404,3.28 410.404,3.904 L410.404,3.904 L410.26,27.808 C410.26,34.144 407.476,37.312 401.908,37.312 C399.076,37.312 396.832,36.412 395.176,34.612 C393.52,32.812 392.668,30.352 392.62,27.232 L392.62,27.232 L392.332,3.76 C392.332,3.088 392.068,2.56 391.54,2.176 C391.012,1.792 390.268,1.6 389.308,1.6 L389.308,1.6 L379.876,1.6 C378.244,1.6 377.428,2.32 377.428,3.76 L377.428,3.76 L377.5,28.816 C377.5,33.04 378.376,36.964 380.128,40.588 C381.88,44.212 384.592,47.152 388.264,49.408 C391.936,51.664 396.532,52.792 402.052,52.792 Z M449.284,52.144 C450.148,52.144 450.88,51.844 451.48,51.244 C452.08,50.644 452.38,49.84 452.38,48.832 L452.38,48.832 L452.38,4.912 C452.38,4 452.08,3.22 451.48,2.572 C450.88,1.924 450.148,1.6 449.284,1.6 L449.284,1.6 L439.42,1.6 C438.46,1.6 437.692,1.924 437.116,2.572 C436.54,3.22 436.252,4 436.252,4.912 L436.252,4.912 L436.252,48.832 C436.252,49.84 436.54,50.644 437.116,51.244 C437.692,51.844 438.46,52.144 439.42,52.144 L439.42,52.144 L449.284,52.144 Z" id="metacatui" fill="#FCBF49" fill-rule="nonzero"></path>
    </g>
</svg>
</logo>

    </a>
    <h3>Namespaces</h3><ul><li><a href="AppConfig.html">AppConfig</a></li><li><a href="MetacatUI.html">MetacatUI</a></li><li><a href="Utilities.html">Utilities</a></li></ul><h3>Classes</h3><ul><li class='category-heading' data-category='Collections'>Collections</li><li><a href="AccessPolicy.html">AccessPolicy</a></li><li><a href="Citations.html">Citations</a></li><li><a href="DataPackage.html">DataPackage</a></li><li><a href="Filters.html">Filters</a></li><li><a href="ObjectFormats.html">ObjectFormats</a></li><li><a href="QualityReport.html">QualityReport</a></li><li><a href="SolrResults.html">SolrResults</a></li><li><a href="Units.html">Units</a></li><li><a href="UserGroup.html">UserGroup</a></li><li class='category-heading' data-category='Collections/Bookkeeper'>Collections/Bookkeeper</li><li><a href="Quotas.html">Quotas</a></li><li><a href="Usages.html">Usages</a></li><li class='category-heading' data-category='Collections/QueryFields'>Collections/QueryFields</li><li><a href="QueryFields.html">QueryFields</a></li><li class='category-heading' data-category='Models'>Models</li><li><a href="AccessRule.html">AccessRule</a></li><li><a href="AppModel.html">AppModel</a></li><li><a href="Citation.html">Citation</a></li><li><a href="CollectionModel.html">CollectionModel</a></li><li><a href="DataONEObject.html">DataONEObject</a></li><li><a href="LookupModel.html">LookupModel</a></li><li><a href="Map.html">Map</a></li><li><a href="Metrics.html">Metrics</a></li><li><a href="QualityCheck.html">QualityCheck</a></li><li><a href="Search.html">Search</a></li><li><a href="SolrResult.html">SolrResult</a></li><li><a href="Stats.html">Stats</a></li><li class='category-heading' data-category='Models/Bookkeeper'>Models/Bookkeeper</li><li><a href="Quota.html">Quota</a></li><li><a href="Subscription.html">Subscription</a></li><li><a href="Usage.html">Usage</a></li><li class='category-heading' data-category='Models/Filters'>Models/Filters</li><li><a href="BooleanFilter.html">BooleanFilter</a></li><li><a href="ChoiceFilter.html">ChoiceFilter</a></li><li><a href="DateFilter.html">DateFilter</a></li><li><a href="Filter.html">Filter</a></li><li><a href="FilterGroup.html">FilterGroup</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="SpatialFilter.html">SpatialFilter</a></li><li><a href="ToggleFilter.html">ToggleFilter</a></li><li class='category-heading' data-category='Models/Formats'>Models/Formats</li><li><a href="ObjectFormat.html">ObjectFormat</a></li><li class='category-heading' data-category='Models/Metadata'>Models/Metadata</li><li><a href="ScienceMetadata.html">ScienceMetadata</a></li><li class='category-heading' data-category='Models/Metadata/EML211'>Models/Metadata/EML211</li><li><a href="EML211.html">EML211</a></li><li><a href="EMLAttribute.html">EMLAttribute</a></li><li><a href="EMLDataTable.html">EMLDataTable</a></li><li><a href="EMLEntity.html">EMLEntity</a></li><li><a href="EMLGeoCoverage.html">EMLGeoCoverage</a></li><li><a href="EMLMeasurementScale.html">EMLMeasurementScale</a></li><li><a href="EMLNonNumericDomain.html">EMLNonNumericDomain</a></li><li><a href="EMLNumericDomain.html">EMLNumericDomain</a></li><li><a href="EMLOtherEntity.html">EMLOtherEntity</a></li><li><a href="EMLParty.html">EMLParty</a></li><li><a href="EMLTemporalCoverage.html">EMLTemporalCoverage</a></li><li><a href="EMLUnit.html">EMLUnit</a></li><li class='category-heading' data-category='Models/Metadata/EML220'>Models/Metadata/EML220</li><li><a href="EMLText.html">EMLText</a></li><li class='category-heading' data-category='Models/Portals'>Models/Portals</li><li><a href="PortalImage.html">PortalImage</a></li><li><a href="PortalModel.html">PortalModel</a></li><li><a href="PortalSectionModel.html">PortalSectionModel</a></li><li class='category-heading' data-category='Models/QueryFields'>Models/QueryFields</li><li><a href="QueryField.html">QueryField</a></li><li class='category-heading' data-category='Router'>Router</li><li><a href="UIRouter.html">UIRouter</a></li><li class='category-heading' data-category='Views'>Views</li><li><a href="AccessPolicyView.html">AccessPolicyView</a></li><li><a href="AccessRuleView.html">AccessRuleView</a></li><li><a href="AppView.html">AppView</a></li><li><a href="CitationListView.html">CitationListView</a></li><li><a href="ColorPaletteView.html">ColorPaletteView</a></li><li><a href="DataCatalogViewWithFilters.html">DataCatalogViewWithFilters</a></li><li><a href="DataItemView.html">DataItemView</a></li><li><a href="DataPackageView.html">DataPackageView</a></li><li><a href="DraftsView.html">DraftsView</a></li><li><a href="EditCollectionView.html">EditCollectionView</a></li><li><a href="EditorView.html">EditorView</a></li><li><a href="GroupListView.html">GroupListView</a></li><li><a href="ImageUploaderView.html">ImageUploaderView</a></li><li><a href="MarkdownEditorView.html">MarkdownEditorView</a></li><li><a href="MarkdownView.html">MarkdownView</a></li><li><a href="MdqRunView.html">MdqRunView</a></li><li><a href="MetadataView.html">MetadataView</a></li><li><a href="MetricModalView.html">MetricModalView</a></li><li><a href="MetricsChartView.html">MetricsChartView</a></li><li><a href="MetricView.html">MetricView</a></li><li><a href="NavbarView.html">NavbarView</a></li><li><a href="RegisterCitationView.html">RegisterCitationView</a></li><li><a href="SignInView.html">SignInView</a></li><li><a href="TableEditorView.html">TableEditorView</a></li><li><a href="TOCView.html">TOCView</a></li><li><a href="UserView.html">UserView</a></li><li class='category-heading' data-category='Views/Filters'>Views/Filters</li><li><a href="BooleanFilterView.html">BooleanFilterView</a></li><li><a href="ChoiceFilterView.html">ChoiceFilterView</a></li><li><a href="DateFilterView.html">DateFilterView</a></li><li><a href="FilterGroupsView.html">FilterGroupsView</a></li><li><a href="FilterGroupView.html">FilterGroupView</a></li><li><a href="FilterView.html">FilterView</a></li><li><a href="NumericFilterView.html">NumericFilterView</a></li><li><a href="ToggleFilterView.html">ToggleFilterView</a></li><li class='category-heading' data-category='Views/Metadata'>Views/Metadata</li><li><a href="EML211EditorView.html">EML211EditorView</a></li><li><a href="EMLAttributeView.html">EMLAttributeView</a></li><li><a href="EMLEntityView.html">EMLEntityView</a></li><li><a href="EMlGeoCoverageView.html">EMlGeoCoverageView</a></li><li><a href="EMLMeasurementScaleView.html">EMLMeasurementScaleView</a></li><li><a href="EMLMethodsView.html">EMLMethodsView</a></li><li><a href="EMLOtherEntityView.html">EMLOtherEntityView</a></li><li><a href="EMLPartyView.html">EMLPartyView</a></li><li><a href="EMLTempCoverageView.html">EMLTempCoverageView</a></li><li><a href="EMLView.html">EMLView</a></li><li><a href="ScienceMetadataView.html">ScienceMetadataView</a></li><li class='category-heading' data-category='Views/Portals'>Views/Portals</li><li><a href="PortalDataView.html">PortalDataView</a></li><li><a href="PortalHeaderView.html">PortalHeaderView</a></li><li><a href="PortalListView.html">PortalListView</a></li><li><a href="PortalLogosView.html">PortalLogosView</a></li><li><a href="PortalMembersView.html">PortalMembersView</a></li><li><a href="PortalSectionView.html">PortalSectionView</a></li><li><a href="PortalUsagesView.html">PortalUsagesView</a></li><li><a href="PortalView.html">PortalView</a></li><li><a href="PortalVisualizationsView.html">PortalVisualizationsView</a></li><li class='category-heading' data-category='Views/Portals/Editor'>Views/Portals/Editor</li><li><a href="PortalEditorView.html">PortalEditorView</a></li><li><a href="PortEditorDataView.html">PortEditorDataView</a></li><li><a href="PortEditorImageView.html">PortEditorImageView</a></li><li><a href="PortEditorLogosView.html">PortEditorLogosView</a></li><li><a href="PortEditorMdSectionView.html">PortEditorMdSectionView</a></li><li><a href="PortEditorSectionsView.html">PortEditorSectionsView</a></li><li><a href="PortEditorSectionView.html">PortEditorSectionView</a></li><li><a href="PortEditorSettingsView.html">PortEditorSettingsView</a></li><li class='category-heading' data-category='Views/QueryBuilder'>Views/QueryBuilder</li><li><a href="QueryBuilderView.html">QueryBuilderView</a></li><li><a href="QueryRuleView.html">QueryRuleView</a></li><li class='category-heading' data-category='Views/SearchSelect'>Views/SearchSelect</li><li><a href="AccountSelectView.html">AccountSelectView</a></li><li><a href="AnnotationFilter.html">AnnotationFilter</a></li><li><a href="NodeSelect.html">NodeSelect</a></li><li><a href="ObjectFormatSelect.html">ObjectFormatSelect</a></li><li><a href="QueryFieldSelectView.html">QueryFieldSelectView</a></li><li><a href="SearchableSelectView.html">SearchableSelectView</a></li><li class='category-heading' data-category='Deprecated'>Deprecated</li><li><a href="ExternalView.html">ExternalView</a></li><li><a href="LogsSearch.html">LogsSearch</a></li></ul><h3>Global</h3><ul><li><a href="global.html#appConfigPath">appConfigPath</a></li></ul>
</nav>

<div id="main">

    <h1 class="page-title">Source: src/js/models/DataONEObject.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* global define */
define(['jquery', 'underscore', 'backbone', 'uuid', 'he', 'collections/AccessPolicy', 'collections/ObjectFormats', 'md5'],
    function($, _, Backbone, uuid, he, AccessPolicy, ObjectFormats, md5){

        /**
        * @class DataONEObject
        * @classdesc A DataONEObject represents a DataONE object, such as a data file,
        a science metadata object, or a resource map. It stores the system
         metadata attributes for the object, performs updates to the system metadata,
         and other basic DataONE API functions. This model can be extended to provide
         specific functionality for different object types, such as the {@link ScienceMetadata}
         model and the {@link EML211} model.
         * @classcategory Models
        * @augments Backbone.Model
        */
        var DataONEObject = Backbone.Model.extend(
          /** @lends DataONEObject.prototype */{

          type: "DataONEObject",
          selectedInEditor: false, // Has this package member been selected and displayed in the provenance editor?
          PROV:    "http://www.w3.org/ns/prov#",
          PROVONE: "http://purl.dataone.org/provone/2015/01/15/ontology#",

          defaults: function(){
            return{
                    // System Metadata attributes
                    serialVersion: null,
                    identifier: null,
                    formatId: null,
                    size: null,
                    checksum: null,
                    originalChecksum: null,
                    checksumAlgorithm: "MD5",
                    submitter: null,
                    rightsHolder : null,
                    accessPolicy: [], //An array of accessPolicy literal JS objects
                    replicationAllowed: null,
                    replicationPolicy: [],
                    obsoletes: null,
                    obsoletedBy: null,
                    archived: null,
                    dateUploaded: null,
                    dateSysMetadataModified: null,
                    originMemberNode: null,
                    authoritativeMemberNode: null,
                    replica: [],
                    seriesId: null, // uuid.v4(), (decide if we want to auto-set this)
                    mediaType: null,
                    fileName: null,
                    // Non-system metadata attributes:
                    isNew: null,
                    datasource: null,
                    insert_count_i: null,
                    read_count_i: null,
                    changePermission: null,
                    writePermission: null,
                    readPermission: null,
                    isPublic: null,
                    dateModified: null,
                    id: "urn:uuid:" + uuid.v4(),
                    sizeStr: null,
                    type: "", // Data, Metadata, or DataPackage
                    formatType: "",
                    metadataEntity: null, // A model that represents the metadata for this file, e.g. an EMLEntity model
                    latestVersion: null,
                    isDocumentedBy: null,
                    documents: [],
                    resourceMap: [],
                    nodeLevel: 0, // Indicates hierarchy level in the view for indentation
                    sortOrder: 2, // Metadata: 1, Data: 2, DataPackage: 3
                    synced: false, // True if the full model has been synced
                    uploadStatus: null, //c=complete, p=in progress, q=queued, e=error, w=warning, no upload status=not in queue
                    uploadProgress: null,
                    sysMetaUploadStatus: null, //c=complete, p=in progress, q=queued, e=error, no upload status=not in queue
                    percentLoaded: 0, // Percent the file is read before caclculating the md5 sum
                    uploadFile: null, // The file reference to be uploaded (JS object: File)
                    errorMessage: null,
                    sysMetaErrorCode: null, // The status code given when there is an error updating the system metadata
                    numSaveAttempts: 0,
                    notFound: false, //Whether or not this object was found in the system
                    originalAttrs: [], // An array of original attributes in a DataONEObject
                    changed: false, // If any attributes have been changed, including attrs in nested objects
                    hasContentChanges: false, // If attributes outside of originalAttrs have been changed
                    sysMetaXML: null, // A cached original version of the fetched system metadata document
                    objectXML: null, // A cached version of the object fetched from the server
                    isAuthorized: null, // If the stated permission is authorized by the user
                    isAuthorized_read: null, //If the user has permission to read
                    isAuthorized_write: null, //If the user has permission to write
                    isAuthorized_changePermission: null, //If the user has permission to changePermission
                    createSeriesId: false, //If true, a seriesId will be created when this object is saved.
                    collections: [], //References to collections that this model is in
                    possibleAuthMNs: [], //A list of possible authoritative MNs of this object
                    provSources: [],
                    provDerivations: [],
                    prov_generated: [],
                    prov_generatedByExecution: [],
                    prov_generatedByProgram: [],
                    prov_generatedByUser: [],
                    prov_hasDerivations: [],
                    prov_hasSources: [],
                    prov_instanceOfClass: [],
                    prov_used: [],
                    prov_usedByExecution: [],
                    prov_usedByProgram: [],
                    prov_usedByUser: [],
                    prov_wasDerivedFrom: [],
                    prov_wasExecutedByExecution: [],
                    prov_wasExecutedByUser: [],
                    prov_wasInformedBy: []
                }
          },

          initialize: function(attrs, options) {
            if(typeof attrs == "undefined") var attrs = {};

            this.set("accessPolicy", this.createAccessPolicy());

            this.on("change:size", this.bytesToSize);
            if(attrs.size)
                this.bytesToSize();

            // Cache an array of original attribute names to help in handleChange()
            if(this.type == "DataONEObject")
              this.set("originalAttrs", Object.keys(this.attributes));
            else
              this.set("originalAttrs", Object.keys(DataONEObject.prototype.defaults()));

            this.on("successSaving", this.updateRelationships);

            //Save a reference to this DataONEObject model in the metadataEntity model
            //whenever the metadataEntity is set
            this.on("change:metadataEntity", function(){
              var entityMetadataModel = this.get("metadataEntity");

              if( entityMetadataModel )
                entityMetadataModel.set("dataONEObject", this);

            });

            this.on("sync", function(){
              this.set("synced", true);
            });

            //Find Member Node object that might be the authoritative MN
            //This is helpful when MetacatUI may be displaying content from multiple MNs
            this.setPossibleAuthMNs();

          },

          /**
           * Maps the lower-case sys meta node names (valid in HTML DOM) to the
           * camel-cased sys meta node names (valid in DataONE).
           * Used during parse() and serialize()
           */
          nodeNameMap: function(){
            return{
              accesspolicy: "accessPolicy",
              accessrule: "accessRule",
              authoritativemembernode: "authoritativeMemberNode",
              checksumalgorithm: "checksumAlgorithm",
              dateuploaded: "dateUploaded",
              datesysmetadatamodified: "dateSysMetadataModified",
              formatid: "formatId",
              filename: "fileName",
              nodereference: "nodeReference",
              numberreplicas: "numberReplicas",
              obsoletedby: "obsoletedBy",
              originmembernode: "originMemberNode",
              replicamembernode: "replicaMemberNode",
              replicationallowed: "replicationAllowed",
              replicationpolicy: "replicationPolicy",
              replicationstatus: "replicationStatus",
              replicaverified: "replicaVerified",
              rightsholder: "rightsHolder",
              serialversion: "serialVersion",
              seriesid: "seriesId"
            };
          },

          /**
          * Returns the URL string where this DataONEObject can be fetched from or saved to
          * @returns {string}
          */
          url: function(){

            // With no id, we can't do anything
            if( !this.get("id") &amp;&amp; !this.get("seriesid") )
              return "";

            //Get the active alternative repository, if one is configured
            var activeAltRepo = MetacatUI.appModel.getActiveAltRepo();

            //Start the base URL string
            var baseUrl = "";

            // Determine if we're updating a new/existing object,
            // or just its system metadata
            // New uploads use the object service URL
            if ( this.isNew() ) {

              //Use the object service URL from the alt repo
              if( activeAltRepo ){
                baseUrl = activeAltRepo.objectServiceUrl;
              }
              //If this MetacatUI deployment is pointing to a MN, use the object service URL from the AppModel
              else{
                baseUrl = MetacatUI.appModel.get("objectServiceUrl");
              }

              //Return the full URL
              return baseUrl;

            }
            else {
              if ( this.hasUpdates() ) {
                if ( this.get("hasContentChanges") ) {

                  //Use the object service URL from the alt repo
                  if( activeAltRepo ){
                    baseUrl = activeAltRepo.objectServiceUrl;
                  }
                  else{
                    baseUrl = MetacatUI.appModel.get("objectServiceUrl");
                  }

                  // Exists on the server, use MN.update()
                  return baseUrl + (encodeURIComponent(this.get("oldPid")));

                } else {

                  //Use the meta service URL from the alt repo
                  if( activeAltRepo ){
                    baseUrl = activeAltRepo.metaServiceUrl;
                  }
                  else{
                    baseUrl = MetacatUI.appModel.get("metaServiceUrl");
                  }

                  // Exists on the server, use MN.updateSystemMetadata()
                  return baseUrl + (encodeURIComponent(this.get("id")));

                }
              } else {
                //Use the meta service URL from the alt repo
                if( activeAltRepo ){
                  baseUrl = activeAltRepo.metaServiceUrl;
                }
                else{
                  baseUrl = MetacatUI.appModel.get("metaServiceUrl");
                }

                // Use MN.getSystemMetadata()
                return baseUrl +
                        (encodeURIComponent(this.get("id")) ||
                         encodeURIComponent(this.get("seriesid")));
              }
            }
          },

          /**
           * Overload Backbone.Model.fetch, so that we can set custom options for each fetch() request
           */
          fetch: function(options){

            if ( ! options ) var options = {};
            else var options = _.clone(options);

            var baseUrl = "",
                activeAltRepo = MetacatUI.appModel.getActiveAltRepo();
            //Use the meta service URL from the alt repo
            if( activeAltRepo ){
              baseUrl = activeAltRepo.metaServiceUrl;
            }
            //If this MetacatUI deployment is pointing to a MN, use the meta service URL from the AppModel
            else{
              baseUrl = MetacatUI.appModel.get("metaServiceUrl");
            }

            // Default to GET /meta
            options.url = baseUrl + encodeURIComponent(this.get("id"));

            //If we are using the Solr service to retrieve info about this object, then construct a query
            if((typeof options != "undefined") &amp;&amp; options.solrService){

              //Get basic information
              var query = "";

              //Do not search for seriesId when it is not configured in this model/app
              if(typeof this.get("seriesid") === "undefined")
                query += 'id:"' + encodeURIComponent(this.get("id")) + '"';
              //If there is no seriesid set, then search for pid or sid
              else if(!this.get("seriesid"))
                query += '(id:"' + encodeURIComponent(this.get("id")) + '" OR seriesId:"' + encodeURIComponent(this.get("id")) + '")';
              //If a seriesId is specified, then search for that
              else if(this.get("seriesid") &amp;&amp; (this.get("id").length > 0))
                query += '(seriesId:"' + encodeURIComponent(this.get("seriesid")) + '" AND id:"' + encodeURIComponent(this.get("id")) + '")';
              //If only a seriesId is specified, then just search for the most recent version
              else if(this.get("seriesid") &amp;&amp; !this.get("id"))
                query += 'seriesId:"' + encodeURIComponent(this.get("id")) + '" -obsoletedBy:*';

              //The fields to return
              var fl = "formatId,formatType,documents,isDocumentedBy,id,seriesId";

              //Use the Solr query URL
              var solrOptions = {
                url: MetacatUI.appModel.get("queryServiceUrl") + 'q=' + query + "&amp;fl=" + fl + "&amp;wt=json"
              }

              //Merge with the options passed to this function
              var fetchOptions = _.extend(options, solrOptions);
            }
            else if(typeof options != "undefined"){
              //Use custom options for retreiving XML
              //Merge with the options passed to this function
              var fetchOptions = _.extend({
                dataType: "text"
              }, options);
            }
            else{
              //Use custom options for retreiving XML
              var fetchOptions = _.extend({
                dataType: "text"
              });
            }

            //Add the authorization options
            fetchOptions = _.extend(fetchOptions, MetacatUI.appUserModel.createAjaxSettings());

            //Call Backbone.Model.fetch to retrieve the info
            return Backbone.Model.prototype.fetch.call(this, fetchOptions);

          },

          /**
           * This function is called by Backbone.Model.fetch.
           * It deserializes the incoming XML from the /meta REST endpoint and converts it into JSON.
           */
          parse: function(response){

            // If the response is XML
            if( (typeof response == "string") &amp;&amp; response.indexOf("&lt;") == 0 ) {

              var responseDoc = $.parseHTML(response),
                  systemMetadata;

              //Save the raw XML in case it needs to be used later
              this.set("sysMetaXML", response);

              //Find the XML node for the system metadata
              for(var i=0; i&lt;responseDoc.length; i++){
                if((responseDoc[i].nodeType == 1) &amp;&amp; (responseDoc[i].localName.indexOf("systemmetadata") > -1)){
                  systemMetadata = responseDoc[i];
                  break;
                }
              }

              //Parse the XML to JSON
              var sysMetaValues = this.toJson(systemMetadata);

              //Convert the JSON to a camel-cased version, which matches Solr and is easier to work with in code
              _.each(Object.keys(sysMetaValues), function(key){
                var camelCasedKey = this.nodeNameMap()[key];
                if(camelCasedKey){
                  sysMetaValues[camelCasedKey] = sysMetaValues[key];
                  delete sysMetaValues[key];
                }
              }, this);

              //Save the checksum from the system metadata in a separate attribute on the model
              sysMetaValues.originalChecksum = sysMetaValues.checksum;
              sysMetaValues.checksum = this.defaults().checksum;

              //Save the identifier as the id attribute
              sysMetaValues.id = sysMetaValues.identifier;

              //Parse the Access Policy
              if( this.get("accessPolicy") &amp;&amp; AccessPolicy.prototype.isPrototypeOf(this.get("accessPolicy")) ){
                this.get("accessPolicy").parse($(systemMetadata).find("accesspolicy"));
                sysMetaValues.accessPolicy = this.get("accessPolicy");
              }
              else{
                //Create a new AccessPolicy collection, if there isn't one already.
                sysMetaValues.accessPolicy = this.createAccessPolicy($(systemMetadata).find("accesspolicy"));
              }

              return sysMetaValues;

            // If the response is a list of Solr docs
            } else if (( typeof response === "object") &amp;&amp; (response.response &amp;&amp; response.response.docs)){

              //If no objects were found in the index, mark as notFound and exit
              if(!response.response.docs.length){
                this.set("notFound", true);
                this.trigger("notFound");
                return;
              }

              //Get the Solr document (there should be only one)
              var doc = response.response.docs[0];

              //Take out any empty values
              _.each(Object.keys(doc), function(field){
                if( !doc[field] &amp;&amp; doc[field] !== 0 )
                  delete doc[field];
              });

              return doc;
            }
            else
                // Default to returning the raw response
                return response;
          },

          /** A utility function for converting XML to JSON */
          toJson: function(xml) {

              // Create the return object
              var obj = {};

              // do children
              if (xml.hasChildNodes()) {

                for(var i = 0; i &lt; xml.childNodes.length; i++) {
                  var item = xml.childNodes.item(i);

                  //If it's an empty text node, skip it
                  if((item.nodeType == 3) &amp;&amp; (!item.nodeValue.trim()))
                    continue;

                  //Get the node name
                  var nodeName = item.localName;

                  //If it's a new container node, convert it to JSON and add as a new object attribute
                  if((typeof(obj[nodeName]) == "undefined") &amp;&amp; (item.nodeType == 1)) {
                    obj[nodeName] = this.toJson(item);
                  }
                  //If it's a new text node, just store the text value and add as a new object attribute
                  else if((typeof(obj[nodeName]) == "undefined") &amp;&amp; (item.nodeType == 3)){
                    obj = item.nodeValue == "false" ? false : item.nodeValue == "true" ? true : item.nodeValue;
                  }
                  //If this node name is already stored as an object attribute...
                  else if(typeof(obj[nodeName]) != "undefined"){

                    //Cache what we have now
                    var old = obj[nodeName];
                    if(!Array.isArray(old))
                      old = [old];

                    //Create a new object to store this node info
                    var newNode = {};

                    //Add the new node info to the existing array we have now
                    if(item.nodeType == 1){
                      newNode = this.toJson(item);
                      var newArray = old.concat(newNode);
                    }
                    else if(item.nodeType == 3){
                      newNode = item.nodeValue;
                      var newArray = old.concat(newNode);
                    }

                    //Store the attributes for this node
                    _.each(item.attributes, function(attr){
                      newNode[attr.localName] = attr.nodeValue;
                    });

                    //Replace the old array with the updated one
                    obj[nodeName] = newArray;

                    //Exit
                    continue;
                  }

                  //Store the attributes for this node
                  /*_.each(item.attributes, function(attr){
                    obj[nodeName][attr.localName] = attr.nodeValue;
                  });*/

               }

            }
            return obj;
          },

          /**
          Serialize the DataONE object JSON to XML
          @param {object} json - the JSON object to convert to XML
          @param {Element} containerNode - an HTML element to insertt the resulting XML into
          @returns {Element} The updated HTML Element
         */
         toXML: function(json, containerNode){

            if(typeof json == "string"){
              containerNode.textContent = json;
              return containerNode;
            }

            for(var i=0; i&lt;Object.keys(json).length; i++){
              var key = Object.keys(json)[i],
                contents = json[key] || json[key];

              var node = document.createElement(key);

              //Skip this attribute if it is not populated
              if(!contents || (Array.isArray(contents) &amp;&amp; !contents.length))
                continue;

              //If it's a simple text node
              if(typeof contents == "string"){
                containerNode.textContent = contents;
                return containerNode;
              }
              else if(Array.isArray(contents)){
                var allNewNodes = [];

                for(var ii=0; ii&lt;contents.length; ii++){
                  allNewNodes.push(this.toXML(contents[ii], $(node).clone()[0]));
                }

                if(allNewNodes.length)
                  node = allNewNodes;
              }
              else if(typeof contents == "object"){
                $(node).append(this.toXML(contents, node));
                var attributeNames = _.without(Object.keys(json[key]), "content");
              }

              $(containerNode).append(node);
            }

            return containerNode;
         },

          /**
          * Saves the DataONEObject System Metadata to the server
          */
          save: function(attributes, options){

              // Set missing file names before saving
              if ( ! this.get("fileName") ) {
                  this.setMissingFileName();
              }
              else{
                //Replace all non-alphanumeric characters with underscores
                var fileNameWithoutExt = this.get("fileName").substring(0, this.get("fileName").lastIndexOf(".")),
                    extension = this.get("fileName").substring(this.get("fileName").lastIndexOf("."), this.get("fileName").length);
                this.set("fileName", fileNameWithoutExt.replace(/[^a-zA-Z0-9]/g, "_") + extension);
              }

              if ( !this.hasUpdates() ) {
                  this.set("uploadStatus", null);
                  return;
              }

              //Set the upload transfer as in progress
              this.set("uploadProgress", 2);
              this.set("uploadStatus", "p");

              //Check if the checksum has been calculated yet.
              if( !this.get("checksum") ){
                //When it is calculated, restart this function
                this.on("checksumCalculated", this.save);
                //Calculate the checksum for this file
                this.calculateChecksum();
                //Exit this function until the checksum is done
                return;
              }

              //Create a FormData object to send data with our XHR
              var formData = new FormData();

              //If this is not a new object, update the id. New DataONEObjects will have an id
              // created during initialize.
              if( !this.isNew() ){
                this.updateID();
                formData.append("pid", this.get("oldPid"));
                formData.append("newPid", this.get("id"));
              }
              else{
                //Create an ID if there isn't one
                if( !this.get("id") ){
                  this.set("id", "urn:uuid:" + uuid.v4());
                }

                //Add the identifier to the XHR data
                formData.append("pid", this.get("id"));
              }

              //Create the system metadata XML
              var sysMetaXML = this.serializeSysMeta();

              //Send the system metadata as a Blob
              var xmlBlob = new Blob([sysMetaXML], {type : 'application/xml'});
              //Add the system metadata XML to the XHR data
              formData.append("sysmeta", xmlBlob, "sysmeta.xml");

              // Create the new object (MN.create())
              formData.append("object", this.get("uploadFile"), this.get("fileName"));

              var model = this;

              // On create(), add to the package and the metadata
              // Note: This should be added to the parent collection
              // but for now we are using the root collection
              _.each(this.get("collections"), function(collection){

                if(collection.type == "DataPackage"){
                  this.off("successSaving", collection.addNewModel);
                  this.once("successSaving", collection.addNewModel, collection);
                }

              }, this);


              //Put together the AJAX and Backbone.save() options
              var requestSettings = {
                  url: this.url(),
                  cache: false,
                  contentType: false,
                  dataType: "text",
                  processData: false,
                  data: formData,
                  parse: false,
                  xhr: function(){
                    var xhr = new window.XMLHttpRequest();

                    //Upload progress
                    xhr.upload.addEventListener("progress", function(evt){
                      if (evt.lengthComputable) {
                        var percentComplete = evt.loaded / evt.total * 100;

                        model.set("uploadProgress", percentComplete);
                      }
                    }, false);

                    return xhr;
                  },
                  success: this.onSuccessfulSave,
                  error: function(model, response, xhr){

                    //Reset the identifier changes
                    model.resetID();
                    //Reset the checksum, if this is a model that needs to be serialized with each save.
                    if( model.serialize ){
                      model.set("checksum", model.defaults().checksum);
                    }

                    model.set("numSaveAttempts", model.get("numSaveAttempts") + 1);
                    var numSaveAttempts = model.get("numSaveAttempts");

                    if( numSaveAttempts &lt; 3 &amp;&amp; (response.status == 408 || response.status == 0) ){

                        //Try saving again in 10, 40, and 90 seconds
                        setTimeout(function(){
                            model.save.call(model);
                          },
                          (numSaveAttempts * numSaveAttempts) * 10000);
                    }
                    else{
                      model.set("numSaveAttempts", 0);

                      var parsedResponse = $(response.responseText).not("style, title").text();

                      //When there is no network connection (status == 0), there will be no response text
                      if(!parsedResponse)
                        parsedResponse = "There was a network issue that prevented this file from uploading. " +
                                 "Make sure you are connected to a reliable internet connection.";

                      model.set("errorMessage", parsedResponse);

                      //Set the model status as e for error
                      model.set("uploadStatus", "e");

                      //Trigger a custom event for the model save error
                      model.trigger("errorSaving", parsedResponse);

                      //Send this exception to Google Analytics
                      if(MetacatUI.appModel.get("googleAnalyticsKey") &amp;&amp; (typeof ga !== "undefined")){
                        ga("send", "exception", {
                          "exDescription": "DataONEObject save error: " + parsedResponse +
                            " | Id: " + model.get("id") + " | v. " + MetacatUI.metacatUIVersion,
                          "exFatal": true
                        });
                      }
                    }
                  }
              };

              //Add the user settings
              requestSettings = _.extend(requestSettings, MetacatUI.appUserModel.createAjaxSettings());

              //Send the Save request
              Backbone.Model.prototype.save.call(this, null, requestSettings);
        },

        /**
        * This function is executed when the XHR that saves this DataONEObject has
        * successfully completed. It can be called directly if a DataONEObject is saved
        * without directly using the DataONEObject.save() function.
        * @param {DataONEObject} [model] A reference to this DataONEObject model
        * @param {XMLHttpRequest.response} [response] The XHR response object
        * @param {XMLHttpRequest} [xhr] The XHR that was just completed successfully
        */
        onSuccessfulSave: function(model, response, xhr){

          if(typeof model == "undefined"){
            var model = this;
          }

          model.set("numSaveAttempts", 0);
          model.set("uploadStatus", "c");
          model.trigger("successSaving", model);

          // Get the newest sysmeta set by the MN
          model.fetch({
            merge: true,
            systemMetadataOnly: true
          });

          // Reset the content changes status
          model.set("hasContentChanges", false);

          //Reset the model isNew attribute
          model.set("isNew", false);

          // Reset oldPid so we can replace again
          model.set("oldPid", null);

          //Set the last-calculated checksum as the original checksum
          model.set("originalChecksum", model.get("checksum"));
          model.set("checksum", model.defaults().checksum);
        },

          /**
            * Updates the DataONEObject System Metadata to the server
            */
          updateSysMeta: function () {

            //Update the upload status to "p" for "in progress"
            this.set("uploadStatus", "p");
            //Update the system metadata upload status to "p" as well, so the app
            // knows that the system metadata, specifically, is being updated.
            this.set("sysMetaUploadStatus", "p");

            var formData = new FormData();

            //Add the identifier to the XHR data
            formData.append("pid", this.get("id"));

            var sysMetaXML = this.serializeSysMeta();

            //Send the system metadata as a Blob
            var xmlBlob = new Blob([sysMetaXML], {type: 'application/xml'});
            //Add the system metadata XML to the XHR data
            formData.append("sysmeta", xmlBlob, "sysmeta.xml");

            var model = this;

            var baseUrl = "",
                activeAltRepo = MetacatUI.appModel.getActiveAltRepo();
            //Use the meta service URL from the alt repo
            if( activeAltRepo ){
              baseUrl = activeAltRepo.metaServiceUrl;
            }
            //If this MetacatUI deployment is pointing to a MN, use the meta service URL from the AppModel
            else{
              baseUrl = MetacatUI.appModel.get("metaServiceUrl");
            }

            var requestSettings = {
                url: baseUrl + (encodeURIComponent(this.get("id"))),
                cache: false,
                contentType: false,
                dataType: "text",
                type: "PUT",
                processData: false,
                data: formData,
                parse: false,
                success: function() {

                  model.set("numSaveAttempts", 0);

                  //Fetch the system metadata from the server so we have a fresh copy of the newest sys meta.
                  model.fetch({ systemMetadataOnly: true });

                  model.set("sysMetaErrorCode", null);

                  //Update the upload status to "c" for "complete"
                  model.set("uploadStatus", "c");
                  model.set("sysMetaUploadStatus", "c");

                  //Trigger a custom event that the sys meta was updated
                  model.trigger("sysMetaUpdated");
                },
                error: function (xhr, status, statusCode) {

                  model.set("numSaveAttempts", model.get("numSaveAttempts") + 1);
                  var numSaveAttempts = model.get("numSaveAttempts");

                  if (numSaveAttempts &lt; 3 &amp;&amp; (statusCode == 408 || statusCode == 0)) {

                      //Try saving again in 10, 40, and 90 seconds
                      setTimeout(function () {
                              model.updateSysMeta.call(model);
                          },
                          (numSaveAttempts * numSaveAttempts) * 10000);
                  } else {
                        model.set("numSaveAttempts", 0);

                        var parsedResponse = $(xhr.responseText).not("style, title").text();

                        //When there is no network connection (status == 0), there will be no response text
                        if (!parsedResponse)
                            parsedResponse = "There was a network issue that prevented this file from updating. " +
                                "Make sure you are connected to a reliable internet connection.";

                        model.set("errorMessage", parsedResponse);

                        model.set("sysMetaErrorCode", statusCode);

                        model.set("uploadStatus", "e");
                        model.set("sysMetaUploadStatus", "e");

                        // Trigger a custom event for the sysmeta update that
                        // errored
                        model.trigger("sysMetaUpdateError");

                        //Send this exception to Google Analytics
                        if (MetacatUI.appModel.get("googleAnalyticsKey") &amp;&amp; (typeof ga !== "undefined")) {
                            ga("send", "exception", {
                                "exDescription": "DataONEObject update system metadata error: " + parsedResponse +
                                    " | Id: " + model.get("id") + " | v. " + MetacatUI.metacatUIVersion,
                                "exFatal": true
                            });
                        }
                    }
                }
            }

            //Add the user settings
            requestSettings = _.extend(requestSettings, MetacatUI.appUserModel.createAjaxSettings());

            //Send the XHR
            $.ajax(requestSettings);
          },

          /**
           * Check if the current user is authorized to perform an action on this object. This function doesn't return
           * the result of the check, but it sends an XHR, updates this model, and triggers a change event.
           * @param {string} [action=changePermission] - The action (read, write, or changePermission) to check
           * if the current user has authorization to perform. By default checks for the highest level of permission.
           * @param {object} [options] Additional options for this function. See the properties below.
           * @property {function} options.onSuccess - A function to execute when the checkAuthority API is successfully completed
           * @property {function} options.onError - A function to execute when the checkAuthority API returns an error, or when no PID or SID can be found for this object.
           * @return {boolean}
           */
          checkAuthority: function(action = "changePermission", options){

            try{
              // return false - if neither PID nor SID is present to check the authority
              if ( (this.get("id") == null)  &amp;&amp; (this.get("seriesId") == null) ) {
                return false;
              }

              if( typeof options == "undefined" ){
                var options = {};
              }

              // If onError or onSuccess options were provided by the user,
              // check that they are functions first, so we don't try to use
              // some other type of variable as a function later on.
              ["onError", "onSuccess"].forEach(function(userFunction){
                if(typeof options[userFunction] !== "function"){
                  options[userFunction] = null;
                }
              });

              // If PID is not present - check authority with seriesId
              var identifier = this.get("id");
              if ( (identifier == null) ) {
                identifier = this.get("seriesId");
              }

              //If there are alt repositories configured, find the possible authoritative
              // Member Node for this DataONEObject.
              if( MetacatUI.appModel.get("alternateRepositories").length ){

                //Get the array of possible authoritative MNs
                var possibleAuthMNs = this.get("possibleAuthMNs");

                //If there are no possible authoritative MNs, use the auth service URL from the AppModel
                if( !possibleAuthMNs.length ){
                  baseUrl = MetacatUI.appModel.get("authServiceUrl");
                }
                else{
                  //Use the auth service URL from the top possible auth MN
                  baseUrl = possibleAuthMNs[0].authServiceUrl;
                }

              }
              else{
                //Get the auth service URL from the AppModel
                baseUrl = MetacatUI.appModel.get("authServiceUrl");
              }

              if( !baseUrl ){
                return false;
              }

              var onSuccess = options.onSuccess || function(data, textStatus, xhr) {
                    model.set("isAuthorized_" + action, true);
                    model.set("isAuthorized", true);
                    model.trigger("change:isAuthorized");
                  },
                  onError = options.onError || function(xhr, textStatus, errorThrown){
                    if(errorThrown == 404){
                      var possibleAuthMNs = model.get("possibleAuthMNs");
                      if( possibleAuthMNs.length ){
                        //Remove the first MN from the array, since it didn't contain the object, so it's not the auth MN
                        possibleAuthMNs.shift();
                      }

                      //If there are no other possible auth MNs to check, trigger this model as Not Found.
                      if( possibleAuthMNs.length == 0 || !possibleAuthMNs ){
                        model.set("notFound", true);
                        model.trigger("notFound");
                      }
                      //If there's more MNs to check, try again
                      else{
                        model.checkAuthority(action, options);
                      }
                    }
                    else{
                      model.set("isAuthorized_" + action, false);
                      model.set("isAuthorized", false);
                    }
                  };

              var model = this;
              var requestSettings = {
                url: baseUrl + encodeURIComponent(identifier) + "?action=" + action,
                type: "GET",
                success: onSuccess,
                error: onError
              }
              $.ajax(_.extend(requestSettings, MetacatUI.appUserModel.createAjaxSettings()));
            }
            catch(e){
              //Log an error to the console
              console.error("Couldn't check the authority for this user: ", e);

              //Send this exception to Google Analytics
              if (MetacatUI.appModel.get("googleAnalyticsKey") &amp;&amp; (typeof ga !== "undefined")) {
                  ga("send", "exception", {
                      "exDescription": "Couldn't check the authority for the user " + MetacatUI.appModel.get("username") +
                          " | Object Id: " + this.get("id") + " | v. " + MetacatUI.metacatUIVersion,
                      "exFatal": true
                  });
              }

              //Set the user as unauthorized
              model.set("isAuthorized_" + action, false);
              model.set("isAuthorized", false);
              return false;

            }

          },

          /**
          * Using the attributes set on this DataONEObject model, serializes the system metadata XML
          * @returns {string}
          */
          serializeSysMeta: function(){
            //Get the system metadata XML that currently exists in the system
            var sysMetaXML = this.get("sysMetaXML"), // sysmeta as string
                xml, // sysmeta as DOM object
                accessPolicyXML, // The generated access policy XML
                previousSiblingNode, // A DOM node indicating any previous sibling
                rightsHolderNode, // A DOM node for the rights holder field
                accessPolicyNode, // A DOM node for the access policy
                replicationPolicyNode, // A DOM node for the replication policy
                obsoletesNode, // A DOM node for the obsoletes field
                obsoletedByNode, // A DOM node for the obsoletedBy field
                fileNameNode, // A DOM node for the file name
                xmlString, // The system metadata document as a string
                nodeNameMap, // The map of camelCase to lowercase attributes
                extension; // the file name extension for this object

            if ( typeof sysMetaXML === "undefined" || sysMetaXML === null ) {
                xml = this.createSysMeta();
            } else {
                xml = $($.parseHTML(sysMetaXML));
            }

            //Update the system metadata values
            xml.find("serialversion").text(this.get("serialVersion") || "0");
            xml.find("identifier").text((this.get("newPid") || this.get("id")));
            xml.find("submitter").text(this.get("submitter") || MetacatUI.appUserModel.get("username"));
            xml.find("formatid").text(this.get("formatId") || this.getFormatId());

            //If there is a seriesId, add it
            if( this.get("seriesId") ){
              //Get the seriesId XML node
              var seriesIdNode = xml.find("seriesId");

              //If it doesn't exist, create one
              if( !seriesIdNode.length ){
                seriesIdNode = $(document.createElement("seriesid"));
                xml.find("identifier").before(seriesIdNode);
              }

              //Add the seriesId string to the XML node
              seriesIdNode.text( this.get("seriesId") );
            }

            //If there is no size, get it
            if( !this.get("size") &amp;&amp; this.get("uploadFile")){
              this.set("size", this.get("uploadFile").size);
            }

            //Get the size of the file, if there is one
            if( this.get("uploadFile") ){
              xml.find("size").text( this.get("uploadFile").size );
            }
            //Otherwise, use the last known size
            else{
              xml.find("size").text(this.get("size"));
            }

            //Save the original checksum
            if( !this.get("checksum") &amp;&amp; this.get("originalChecksum") ){
              xml.find("checksum").text(this.get("originalChecksum"));
            }
            //Update the checksum and checksum algorithm
            else{
              xml.find("checksum").text(this.get("checksum"));
              xml.find("checksum").attr("algorithm", this.get("checksumAlgorithm"));
            }

            //Update the rightsholder
            xml.find("rightsholder").text(this.get("rightsHolder") || MetacatUI.appUserModel.get("username"));

            //Write the access policy
            accessPolicyXML = this.get("accessPolicy").serialize();

            // Get the access policy node, if it exists
            accessPolicyNode = xml.find("accesspolicy");

            previousSiblingNode = xml.find("rightsholder");

            // Create an access policy node if needed
            if ( (! accessPolicyNode.length) &amp;&amp; accessPolicyXML ) {
                accessPolicyNode = $(document.createElement("accesspolicy"));
                previousSiblingNode.after(accessPolicyNode);

            }

            //Replace the old access policy with the new one if it exists
            if ( accessPolicyXML ) {
              accessPolicyNode.replaceWith(accessPolicyXML);
            }

              // Set the obsoletes node after replPolicy or accessPolicy, or rightsHolder
              replicationPolicyNode = xml.find("replicationpolicy");
              accessPolicyNode = xml.find("accesspolicy");
              rightsHolderNode = xml.find("rightsholder");

              if ( replicationPolicyNode.length ) {
                  previousSiblingNode = replicationPolicyNode;
              } else if ( accessPolicyNode.length ) {
                  previousSiblingNode = accessPolicyNode;
              } else {
                  previousSiblingNode = rightsHolderNode;
              }

              obsoletesNode = xml.find("obsoletes");

              if( this.get("obsoletes") ){
                   if( obsoletesNode.length ) {
                     obsoletesNode.text(this.get("obsoletes"));
                   }
                   else {
                     obsoletesNode = $(document.createElement("obsoletes")).text(this.get("obsoletes"));
                     previousSiblingNode.after(obsoletesNode);
                   }
              }
              else {
                if ( obsoletesNode ) {
                  obsoletesNode.remove();
                }
              }

                if ( obsoletesNode ) {
                    previousSiblingNode = obsoletesNode;
                }

                obsoletedByNode = xml.find("obsoletedby");

                //remove the obsoletedBy node if it exists
                // TODO: Verify this is what we want to do
                if ( obsoletedByNode ) {
                    obsoletedByNode.remove();
                }

                xml.find("archived").text(this.get("archived") || "false");
                xml.find("dateuploaded").text(this.get("dateUploaded") || new Date().toISOString());

                //Get the filename node
                fileNameNode = xml.find("filename");

                //If the filename node doesn't exist, then create one
                if( ! fileNameNode.length ){
                  fileNameNode = $(document.createElement("filename"));
                  xml.find("dateuploaded").after(fileNameNode);
                }

                //Set the object file name
                $(fileNameNode).text(this.get("fileName"));

                xmlString = $(document.createElement("div")).append(xml.clone()).html();

                //Now camel case the nodes
                nodeNameMap = this.nodeNameMap();

                _.each(Object.keys(nodeNameMap), function(name, i){
                  var originalXMLString = xmlString;

                  //Camel case node names
                  var regEx = new RegExp("&lt;" + name, "g");
                  xmlString = xmlString.replace(regEx, "&lt;" + nodeNameMap[name]);
                  var regEx = new RegExp(name + ">", "g");
                  xmlString = xmlString.replace(regEx, nodeNameMap[name] + ">");

                  //If node names haven't been changed, then find an attribute
                  if(xmlString == originalXMLString){
                    var regEx = new RegExp(" " + name + "=", "g");
                    xmlString = xmlString.replace(regEx, " " + nodeNameMap[name] + "=");
                  }
                }, this);

                xmlString = xmlString.replace(/systemmetadata/g, "systemMetadata");

                return xmlString;
          },

          /**
           * Get the object format identifier for this object
           */
          getFormatId: function() {
            var formatId = "application/octet-stream", // default to untyped data
              objectFormats = {
                "mediaTypes": [],  // The list of potential formatIds based on mediaType matches
                "extensions": []   // The list of possible formatIds based onextension matches
              },
              fileName = this.get("fileName"),  // the fileName for this object
              ext;  // The extension of the filename for this object

            objectFormats["mediaTypes"] = MetacatUI.objectFormats.where({formatId: this.get("mediaType")});
            if ( typeof fileName !== "undefined" &amp;&amp; fileName !== null &amp;&amp; fileName.length > 1) {
              ext = fileName.substring(fileName.lastIndexOf(".") + 1, fileName.length);
              objectFormats["extensions"] = MetacatUI.objectFormats.where({extension: ext});
            }

            if (objectFormats["mediaTypes"].length > 0 &amp;&amp; objectFormats["extensions"].length > 0) {
              var firstMediaType = objectFormats["mediaTypes"][0].get("formatId");
              var firstExtension = objectFormats["extensions"][0].get("formatId");
              // Check if they're equal
              if (firstMediaType === firstExtension) {
                formatId = firstMediaType;
                return formatId;
              }
              // Handle mismatched mediaType and extension cases - additional cases can be added below
              if (firstMediaType === 'application/vnd.ms-excel' &amp;&amp; firstExtension === 'text/csv') {
                formatId = firstExtension;
                return formatId;
              }
            }

            if (objectFormats["mediaTypes"].length > 0) {
              formatId = objectFormats["mediaTypes"][0].get("formatId");
              console.log('returning default mediaType');
              console.log(formatId);
              return formatId;
            }

            if (objectFormats["extensions"].length > 0 ) {
              //If this is a "nc" file, assume it is a netCDF-3 file.
              if (ext == "nc") {
                formatId = "netCDF-3";
              } else {
                formatId = objectFormats["extensions"][0].get("formatId");
              }
              return formatId;
            }

            return formatId;

          },

          /**
           * Build a fresh system metadata document for this object when it is new
           * Return it as a DOM object
           */
          createSysMeta: function() {
              var sysmetaDOM, // The DOM
                  sysmetaXML = []; // The document as a string array

              sysmetaXML.push(
                  //'&lt;?xml version="1.0" encoding="UTF-8"?>',
                  '&lt;d1_v2.0:systemmetadata',
                  '    xmlns:d1_v2.0="http://ns.dataone.org/service/types/v2.0"',
                  '    xmlns:d1="http://ns.dataone.org/service/types/v1">',
                  '    &lt;serialversion />',
                  '    &lt;identifier />',
                  '    &lt;formatid />',
                  '    &lt;size />',
                  '    &lt;checksum />',
                  '    &lt;submitter />',
                  '    &lt;rightsholder />',
                  '    &lt;filename />',
                  '&lt;/d1_v2.0:systemmetadata>'
              );

              sysmetaDOM = $($.parseHTML(sysmetaXML.join("")));
              return sysmetaDOM;
          },

          /**
          * Create an access policy for this DataONEObject using the default access
          * policy set in the AppModel.
          *
          * @param {Element} [accessPolicyXML] - An &lt;accessPolicy> XML node
          *   that contains a list of access rules.
          * @return {AccessPolicy} - an AccessPolicy collection that represents the
          *   given XML or the default policy set in the AppModel.
          */
          createAccessPolicy: function(accessPolicyXML){
            //Create a new AccessPolicy collection
            var accessPolicy = new AccessPolicy();

            accessPolicy.dataONEObject = this;

            //If there is no access policy XML sent,
            if( this.isNew() &amp;&amp; !accessPolicyXML ){

              try{
                //If the app is configured to inherit the access policy from the parent metadata,
                // then get the parent metadata and copy it's AccessPolicy
                if( MetacatUI.appModel.get("inheritAccessPolicy") &amp;&amp; this.get("isDocumentedByModels").length ){
                  let scienceMetadata = this.get("isDocumentedByModels")[0];
                  let sciMetaAccessPolicy = scienceMetadata.get("accessPolicy");

                  if( sciMetaAccessPolicy ){
                    accessPolicy.copyAccessPolicy(sciMetaAccessPolicy);
                  }
                  else{
                    accessPolicy.createDefaultPolicy();
                  }
                }
              }
              catch(e){
                console.error("Could not copy access policy, so defaulting to default", e);
                accessPolicy.createDefaultPolicy();
              }

              //Otherwise, set the default access policy using the AppModel configuration
              if( MetacatUI.appModel.get("inheritAccessPolicy") === false ){
                accessPolicy.createDefaultPolicy();
              }
            }
            else{
              //Parse the access policy XML to create AccessRule models from the XML
              accessPolicy.parse(accessPolicyXML);
            }

            //Listen to changes on the collection and trigger a change on this model
            var self = this;
            this.listenTo(accessPolicy, "change update", function(){
              self.trigger("change");
              this.addToUploadQueue();

            });

            return accessPolicy;
          },

          /**
           * Update identifiers for this object
           *
           * @param {string} id - Optional identifier to update with. Generated
           * automatically when not given.
           *
           * Note that this method caches the objects attributes prior to
           * updating so this.resetID() can be called in case of a failure
           * state.
           *
           * Also note that this method won't run if theh oldPid attribute is
           * set. This enables knowing before this.save is called what the next
           * PID will be such as the case where we want to update a matching
           * EML entity when replacing files.
           */
          updateID: function(id){
            // Only run once until oldPid is reset
            if (this.get("oldPid")) {
              return;
            }

            //Save the attributes so we can reset the ID later
            this.attributeCache = this.toJSON();

            //Set the old identifier
            var oldPid = this.get("id"),
                selfDocuments,
                selfDocumentedBy,
                documentedModels,
                documentedModel,
                index;

            //Save the current id as the old pid
            this.set("oldPid", oldPid);

            //Create a new seriesId, if there isn't one, and if this model specifies that one is required
            if( !this.get("seriesId") &amp;&amp; this.get("createSeriesId") ){
              this.set("seriesId", "urn:uuid:" + uuid.v4());
            }

            // Check to see if the old pid documents or is documented by itself
            selfDocuments = _.contains(this.get("documents"), oldPid);
            selfDocumentedBy = _.contains(this.get("isDocumentedBy"), oldPid);

            //Set the new identifier
            if( id ) {
              this.set("id", id);

            } else {
              if( this.get("type") == "DataPackage" ){
                this.set("id", "resource_map_urn:uuid:" + uuid.v4());
              }
              else{
                this.set("id", "urn:uuid:" + uuid.v4());
              }
            }

            // Remove the old pid from the documents list if present
            if ( selfDocuments ) {
                index = this.get("documents").indexOf(oldPid);
                if ( index > -1 ) {
                    this.get("documents").splice(index, 1);

                }
                // And add the new pid in
                this.get("documents").push(this.get("id"));

            }

            // Remove the old pid from the isDocumentedBy list if present
            if ( selfDocumentedBy ) {
                index = this.get("isDocumentedBy").indexOf(oldPid);
                if ( index > -1 ) {
                    this.get("isDocumentedBy").splice(index, 1);

                }
                // And add the new pid in
                this.get("isDocumentedBy").push(this.get("id"));

            }

            // Update all models documented by this pid with the new id
            _.each(this.get("documents"), function(id) {
                documentedModels = MetacatUI.rootDataPackage.where({id: id}),
                documentedModel;

                if ( documentedModels.length > 0 ) {
                    documentedModel = documentedModels[0];
                }
                if ( typeof documentedModel !== "undefined" ) {
                    // Find the oldPid in the array
                    if( Array.isArray(documentedModel.get("isDocumentedBy")) ){
                      index = documentedModel.get("isDocumentedBy").indexOf("oldPid");

                      if ( index > -1 ) {
                          // Remove it
                          documentedModel.get("isDocumentedBy").splice(index, 1);

                      }
                      // And add the new pid in
                      documentedModel.get("isDocumentedBy").push(this.get("id"));
                    }
                }
            }, this);

            this.trigger("change:id")

            //Update the obsoletes and obsoletedBy
            this.set("obsoletes", oldPid);
            this.set("obsoletedBy", null);

            // Update the latest version of this object
            this.set("latestVersion", this.get("id"));

            //Set the archived option to false
            this.set("archived", false);
          },

          /**
           * Resets the identifier for this model. This undos all of the changes made in {DataONEObject#updateID}
           */
          resetID: function(){
            if(!this.attributeCache) return false;

            this.set("oldPid", this.attributeCache.oldPid, {silent:true});
            this.set("id", this.attributeCache.id, {silent: true});
            this.set("obsoletes", this.attributeCache.obsoletes, {silent: true});
            this.set("obsoletedBy", this.attributeCache.obsoletedBy, {silent: true});
            this.set("archived", this.attributeCache.archived, {silent: true});
            this.set("latestVersion", this.attributeCache.latestVersion, {silent: true});

            //Reset the attribute cache
            this.attributeCache = {};
          },

          /**
           * Checks if this system metadata XML has updates that need to be synced with the server.
           * @returns {boolean}
           */
          hasUpdates: function(){
            if(this.isNew()) return true;

            // Compare the new system metadata XML to the old system metadata XML

            var D1ObjectClone = this.clone(),
                // Make sure we are using the parse function in the DataONEObject model.
                // Sometimes hasUpdates is called from extensions of the D1Object model,
                // (e.g. from the portal model), and the parse function is overwritten
                oldSysMetaAttrs = new DataONEObject().parse(D1ObjectClone.get("sysMetaXML"));

            D1ObjectClone.set(oldSysMetaAttrs);

            var oldSysMeta = D1ObjectClone.serializeSysMeta();
            var newSysMeta = this.serializeSysMeta();

            if ( oldSysMeta === "" ) return false;

            return !(newSysMeta == oldSysMeta);
          },

          /**
             Set the changed flag on any system metadata or content attribute changes,
             and set the hasContentChanges flag on content changes only
             @param {DataONEObject} [model]
           */
          handleChange: function(model) {
            if(!model) var model = this;

              var sysMetaAttrs = ["serialVersion", "identifier", "formatId", "formatType", "size", "checksum",
                  "checksumAlgorithm", "submitter", "rightsHolder", "accessPolicy", "replicationAllowed",
                  "replicationPolicy", "obsoletes", "obsoletedBy", "archived", "dateUploaded", "dateSysMetadataModified",
                  "originMemberNode", "authoritativeMemberNode", "replica", "seriesId", "mediaType", "fileName"],
                  nonSysMetaNonContentAttrs = _.difference(model.get("originalAttrs"), sysMetaAttrs),
                  allChangedAttrs = Object.keys(model.changedAttributes()),
                  changedSysMetaOrContentAttrs = [], //sysmeta or content attributes that have changed
                  changedContentAttrs = []; // attributes from sub classes like ScienceMetadata or EML211 ...

              // Get a list of all changed sysmeta and content attributes
              changedSysMetaOrContentAttrs = _.difference(allChangedAttrs, nonSysMetaNonContentAttrs);
              if ( changedSysMetaOrContentAttrs.length > 0 ) {
                  // For any sysmeta or content change, set the package dirty flag
                  if ( MetacatUI.rootDataPackage &amp;&amp;
                       MetacatUI.rootDataPackage.packageModel &amp;&amp;
                       ! MetacatUI.rootDataPackage.packageModel.get("changed") &amp;&amp;
                       model.get("synced") ) {

                      MetacatUI.rootDataPackage.packageModel.set("changed", true);
                  }
              }

              // And get a list of all changed content attributes
              changedContentAttrs = _.difference(changedSysMetaOrContentAttrs, sysMetaAttrs);

              if ( changedContentAttrs.length > 0 &amp;&amp; !this.get("hasContentChanges") &amp;&amp; model.get("synced") ) {
                this.set("hasContentChanges", true);
                this.addToUploadQueue();
              }

          },

          /**
          * Returns true if this DataONE object is new. A DataONE object is new
          * if there is no upload date and it's been synced (i.e. been fetched)
          * @return {boolean}
          */
          isNew: function(){

            //If the model is explicitly marked as not new, return false
            if( this.get("isNew") === false ){
              return false;
            }

            //Check if there is an upload date that was retrieved from the server
            return ( this.get("dateUploaded") === this.defaults().dateUploaded &amp;&amp;
                     this.get("synced") );
          },

          /**
           * Updates the upload status attribute on this model and marks the collection as changed
           */
          addToUploadQueue: function(){

            if( !this.get("synced") ){
              return;
            }

              //Add this item to the queue
              if((this.get("uploadStatus") == "c") || (this.get("uploadStatus") == "e") || !this.get("uploadStatus")){
                this.set("uploadStatus", "q");

                //Mark each DataPackage collection this model is in as changed
                _.each(this.get("collections"), function(collection){
                  if(collection.packageModel)
                    collection.packageModel.set("changed", true);
                }, this);
              }
          },

          /**
           * Updates the progress percentage when the model is getting uploaded
           * @param {ProgressEvent} e - The ProgressEvent when this file is being uploaded
           */
          updateProgress: function(e){
            if(e.lengthComputable){
                var max = e.total;
                var current = e.loaded;

                var Percentage = (current * 100)/max;


                if(Percentage >= 100)
                {
                   // process completed
                }
              }
          },

          /**
           * Updates the relationships with other models when this model has been updated
           */
          updateRelationships: function(){
            _.each(this.get("collections"), function(collection){
              //Get the old id for this model
              var oldId = this.get("oldPid");

              if(!oldId) return;

              //Find references to the old id in the documents relationship
              var  outdatedModels = collection.filter(function(m){
                  return _.contains(m.get("documents"), oldId);
                });

              //Update the documents array in each model
              _.each(outdatedModels, function(model){
                var updatedDocuments = _.without(model.get("documents"), oldId);
                updatedDocuments.push(this.get("id"));

                model.set("documents", updatedDocuments);
              }, this);

            }, this);
          },

          /**
           * Finds the latest version of this object by travesing the obsolescence chain
           * @param {string} [latestVersion] - The identifier of the latest known object in the version chain.
             If not supplied, this model's `id` will be used.
           * @param {string} [possiblyNewer] - The identifier of the object that obsoletes the latestVersion. It's "possibly" newer, because it may be private/inaccessible
           */
          findLatestVersion: function(latestVersion, possiblyNewer){
            var baseUrl = "",
                activeAltRepo = MetacatUI.appModel.getActiveAltRepo();
            //Use the meta service URL from the alt repo
            if( activeAltRepo ){
              baseUrl = activeAltRepo.metaServiceUrl;
            }
            //If this MetacatUI deployment is pointing to a MN, use the meta service URL from the AppModel
            else{
              baseUrl = MetacatUI.appModel.get("metaServiceUrl");
            }

            if( !baseUrl ){
              return;
            }

            //If there is no system metadata, then retrieve it first
            if(!this.get("sysMetaXML")){
              this.once("sync", this.findLatestVersion);
              this.once("systemMetadataSync", this.findLatestVersion);
              this.fetch({
                url: baseUrl + encodeURIComponent(this.get("id")),
                dataType: "text",
                systemMetadataOnly: true
              });
              return;
            }

            //If no pid was supplied, use this model's id
            if(!latestVersion || typeof latestVersion != "string"){
              var latestVersion = this.get("id");
              var possiblyNewer = this.get("obsoletedBy");
            }

            //If this isn't obsoleted by anything, then there is no newer version
            if(!possiblyNewer || typeof latestVersion != "string"){
              this.set("latestVersion", latestVersion);

              //Trigger an event that will fire whether or not the latestVersion
              // attribute was actually changed
              this.trigger("latestVersionFound", this);

              //Remove the listeners now that we found the latest version
              this.stopListening("sync", this.findLatestVersion);
              this.stopListening("systemMetadataSync", this.findLatestVersion);

              return;
            }

            var model = this;

            //Get the system metadata for the possibly newer version
            var requestSettings = {
              url: baseUrl + encodeURIComponent(possiblyNewer),
              type: "GET",
              success: function(data) {

                // the response may have an obsoletedBy element
                var obsoletedBy = $(data).find("obsoletedBy").text();

                //If there is an even newer version, then get it and rerun this function
                if(obsoletedBy){
                  model.findLatestVersion(possiblyNewer, obsoletedBy);
                }
                //If there isn't a newer version, then this is it
                else{
                  model.set("latestVersion", possiblyNewer);
                  model.trigger("latestVersionFound", model);

                  //Remove the listeners now that we found the latest version
                  model.stopListening("sync", model.findLatestVersion);
                  model.stopListening("systemMetadataSync", model.findLatestVersion);
                }

              },
              error: function(xhr){
                //If this newer version isn't accessible, link to the latest version that is
                if(xhr.status == "401"){
                  model.set("latestVersion", latestVersion);
                  model.trigger("latestVersionFound", model);
                }
              }
            }

            $.ajax(_.extend(requestSettings, MetacatUI.appUserModel.createAjaxSettings()));
          },

          /**
           * A utility function that will format an XML string or XML nodes by camel-casing the node names, as necessary
           * @param {string|Element} xml - The XML to format
           * @returns {string} The formatted XML string
           */
          formatXML: function(xml){
            var nodeNameMap = this.nodeNameMap(),
                xmlString = "";

            //XML must be provided for this function
            if(!xml)
              return "";
            //Support XML strings
            else if(typeof xml == "string")
              xmlString = xml;
            //Support DOMs
            else if(typeof xml == "object" &amp;&amp; xml.nodeType){
              //XML comments should be formatted with start and end carets
              if(xml.nodeType == 8)
                xmlString = "&lt;" + xml.nodeValue + ">";
              //XML nodes have the entire XML string available in the outerHTML attribute
              else if(xml.nodeType == 1)
                xmlString = xml.outerHTML;
              //Text node types are left as-is
              else if(xml.nodeType == 3)
                return xml.nodeValue;
            }

            //Return empty strings if something went wrong
            if(!xmlString)
              return "";

            _.each(Object.keys(nodeNameMap), function(name, i){
              var originalXMLString = xmlString;

              //Check for this node name whe it's an opening XML node, e.g. `&lt;name>`
              var regEx = new RegExp("&lt;" + name + ">", "g");
              xmlString = xmlString.replace(regEx, "&lt;" + nodeNameMap[name] + ">");

              //Check for this node name when it's an opening XML node, e.g. `&lt;name `
              regEx = new RegExp("&lt;" + name + " ", "g");
              xmlString = xmlString.replace(regEx, "&lt;" + nodeNameMap[name] + " ");

              //Check for this node name when it's preceeded by a namespace, e.g. `:name `
              regEx = new RegExp(":" + name + " ", "g");
              xmlString = xmlString.replace(regEx, ":" + nodeNameMap[name] + " ");

              //Check for this node name when it's a closing tag preceeded by a namespace, e.g. `:name>`
              regEx = new RegExp(":" + name + ">", "g");
              xmlString = xmlString.replace(regEx, ":" + nodeNameMap[name] + ">");

              //Check for this node name when it's a closing XML tag, e.g. `&lt;/name>`
              regEx = new RegExp("&lt;/" + name + ">", "g");
              xmlString = xmlString.replace(regEx, "&lt;/" + nodeNameMap[name] + ">");

              //If node names haven't been changed, then find an attribute, e.g. ` name=`
              if(xmlString == originalXMLString){
                regEx = new RegExp(" " + name + "=", "g");
                xmlString = xmlString.replace(regEx, " " + nodeNameMap[name] + "=");
              }

            }, this);

            //Take each XML node text value and decode any XML entities
            var regEx = new RegExp("\&amp;[0-9a-zA-Z]+\;", "g");
            xmlString = xmlString.replace(regEx, function(match){ return he.encode(he.decode(match)); });

            return xmlString;
          },

          /**
           * Converts the number of bytes into a human readable format and updates the `sizeStr` attribute
           */
          bytesToSize: function(){
              var kilobyte = 1024;
              var megabyte = kilobyte * 1024;
              var gigabyte = megabyte * 1024;
              var terabyte = gigabyte * 1024;
              var precision = 0;

              var bytes = this.get("size");

              if ((bytes >= 0) &amp;&amp; (bytes &lt; kilobyte)) {
                  this.set("sizeStr", bytes + ' B');

              } else if ((bytes >= kilobyte) &amp;&amp; (bytes &lt; megabyte)) {
                  this.set("sizeStr", (bytes / kilobyte).toFixed(precision) + ' KB');

              } else if ((bytes >= megabyte) &amp;&amp; (bytes &lt; gigabyte)) {
                  precision = 2;
                  this.set("sizeStr", (bytes / megabyte).toFixed(precision) + ' MB');

              } else if ((bytes >= gigabyte) &amp;&amp; (bytes &lt; terabyte)) {
                  precision = 2;
                  this.set("sizeStr", (bytes / gigabyte).toFixed(precision) + ' GB');

              } else if (bytes >= terabyte) {
                  precision = 2;
                  this.set("sizeStr", (bytes / terabyte).toFixed(precision) + ' TB');

              } else {
                  this.set("sizeStr", bytes + ' B');

              }
          },

          /**
           * Creates a file name for this DataONEObject and updates the `fileName` attribute
           */
          setMissingFileName: function() {
            var objectFormats, filename, extension;

            objectFormats = MetacatUI.objectFormats.where({formatId: this.get("formatId")});
            if ( objectFormats.length > 0 ) {
                extension = objectFormats[0].get("extension");
            }

            //Science metadata file names will use the title
            if( this.get("type") == "Metadata" ){
              filename = (Array.isArray(this.get("title")) &amp;&amp; this.get("title").length)? this.get("title")[0] : this.get("id");
            }
            //Resource maps will use a "resource_map_" prefix
            else if( this.get("type") == "DataPackage" ){
              filename = "resource_map_" + this.get("id");
              extension = ".rdf.xml";
            }
            //All other object types will just use the id
            else{
              filename = this.get("id");
            }

            //Replace all non-alphanumeric characters with underscores
            filename = filename.replace(/[^a-zA-Z0-9]/g, "_");

            if ( typeof extension !== "undefined" ) {
              filename = filename + "." + extension;
            }

            this.set("fileName", filename);
          },

          /**
          * Creates a URL for viewing more information about this object
          * @return {string}
          */
          createViewURL: function(){
            return MetacatUI.root + "/view/" + encodeURIComponent((this.get("seriesId") || this.get("id")));
          },

          /**
          * Converts the identifier string to a string safe to use in an XML id attribute
          * @param {string} [id] - The ID string
          * @return {string} - The XML-safe string
          */
          getXMLSafeID: function(id){

            if(typeof id == "undefined"){
              var id = this.get("id");
            }

            //Replace XML id attribute invalid characters and patterns in the identifier
            id = id.replace(/&lt;/g, "-").replace(/:/g, "-").replace(/&amp;[a-zA-Z0-9]+;/g);

            return id;
          },

          /**** Provenance-related functions ****/
          /**
           * Returns true if this provenance field points to a source of this data or metadata object
           * @param {string} field
           * @returns {boolean}
           */
          isSourceField: function(field){
            if((typeof field == "undefined") || !field) return false;
            // Is the field we are checking a prov field?
            if(!_.contains(MetacatUI.appSearchModel.getProvFields(), field)) return false;

            if(field == "prov_generatedByExecution" ||
               field == "prov_generatedByProgram"   ||
               field == "prov_used"           ||
               field == "prov_wasDerivedFrom"     ||
               field == "prov_wasInformedBy")
              return true;
            else
              return false;
           },

          /**
           * Returns true if this provenance field points to a derivation of this data or metadata object
           * @param {string} field
           * @returns {boolean}
           */
          isDerivationField: function(field){
            if((typeof field == "undefined") || !field) return false;
            if(!_.contains(MetacatUI.appSearchModel.getProvFields(), field)) return false;

            if(field == "prov_usedByExecution" ||
               field == "prov_usedByProgram"   ||
               field == "prov_hasDerivations" ||
               field == "prov_generated")
              return true;
            else
              return false;
          },

          /**
          * Returns a plain-english version of the general format - either image, program, metadata, PDF, annotation or data
          */
          getType: function(){
            //The list of formatIds that are images

                    //The list of formatIds that are images
            var pdfIds = ["application/pdf"];
            var annotationIds = ["http://docs.annotatorjs.org/en/v1.2.x/annotation-format.html"];

            // Type has already been set, use that.
            if(this.get("type").toLowerCase() == "metadata")
              return "metadata";

            //Determine the type via provONE
            var instanceOfClass = this.get("prov_instanceOfClass");
            if(typeof instanceOfClass !== "undefined" &amp;&amp; Array.isArray(instanceOfClass) &amp;&amp; instanceOfClass.length){
              var programClass = _.filter(instanceOfClass, function(className){
                return (className.indexOf("#Program") > -1);
              });
              if((typeof programClass !== "undefined") &amp;&amp; programClass.length)
                return "program";
            }
            else{
              if(this.get("prov_generated").length || this.get("prov_used").length)
                return "program";
            }

            //Determine the type via file format
            if(this.isSoftware()) return "program";
            if(this.isData()) return "data";

            if(this.get("type").toLowerCase() == "metadata") return "metadata";
                    if(this.isImage()) return "image";
            if(_.contains(pdfIds, this.get("formatId")))   return "PDF";
            if(_.contains(annotationIds, this.get("formatId")))   return "annotation";

            else return "data";
          },

          /**
           * Checks the formatId of this model and determines if it is an image.
           * @returns {boolean} true if this data object is an image, false if it is other
           */
          isImage: function(){
            //The list of formatIds that are images
            var imageIds = ["image/gif",
                            "image/jp2",
                            "image/jpeg",
                            "image/png"];

            //Does this data object match one of these IDs?
            if(_.indexOf(imageIds, this.get('formatId')) == -1) return false;
            else return true;

          },

          /**
           * Checks the formatId of this model and determines if it is a data file.
           * This determination is mostly used for display and the provenance editor. In the
           * DataONE API, many formatIds are considered `DATA` formatTypes, but they are categorized
           * as images {@link DataONEObject#isImage} or software {@link DataONEObject#isSoftware}.
           * @returns {boolean} true if this data object is a data file, false if it is other
           */
          isData: function() {
            var dataIds =  ["application/atom+xml",
                            "application/mathematica",
                            "application/msword",
                            "application/netcdf",
                            "application/octet-stream",
                            "application/pdf",
                            "application/postscript",
                            "application/rdf+xml",
                            "application/rtf",
                            "application/vnd.google-earth.kml+xml",
                            "application/vnd.ms-excel",
                            "application/vnd.ms-excel.sheet.binary.macroEnabled.12",
                            "application/vnd.ms-powerpoint",
                            "application/vnd.openxmlformats-officedocument.presentationml.presentation",
                            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                            "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                            "application/x-bzip2",
                            "application/x-fasta",
                            "application/x-gzip",
                            "application/x-rar-compressed",
                            "application/x-tar",
                            "application/xhtml+xml",
                            "application/xml",
                            "application/zip",
                            "audio/mpeg",
                            "audio/x-ms-wma",
                            "audio/x-wav",
                            "image/svg xml",
                            "image/svg+xml",
                            "image/bmp",
                            "image/tiff",
                            "text/anvl",
                            "text/csv",
                            "text/html",
                            "text/n3",
                            "text/plain",
                            "text/tab-separated-values",
                            "text/turtle",
                            "text/xml",
                            "video/avi",
                            "video/mp4",
                            "video/mpeg",
                            "video/quicktime",
                            "video/x-ms-wmv"];

            //Does this data object match one of these IDs?
            if(_.indexOf(dataIds, this.get('formatId')) == -1) return false;
            else return true;
          },

          /**
           * Checks the formatId of this model and determines if it is a software file.
           * This determination is mostly used for display and the provenance editor. In the
           * DataONE API, many formatIds are considered `DATA` formatTypes, but they are categorized
           * as images {@link DataONEObject#isImage} for display purposes.
           * @returns {boolean} true if this data object is a software file, false if it is other
           */
          isSoftware: function(){
            //The list of formatIds that are programs
            var softwareIds =  ["text/x-python",
                      "text/x-rsrc",
                      "text/x-matlab",
                      "text/x-sas",
                      "application/R",
                      "application/x-ipynb+json"];
            //Does this data object match one of these IDs?
            if(_.indexOf(softwareIds, this.get('formatId')) == -1) return false;
            else return true;
          },

          /**
           * Checks the formatId of this model and determines if it a PDF.
           * @returns {boolean} true if this data object is a pdf, false if it is other
           */
          isPDF: function(){
            //The list of formatIds that are images
            var ids = ["application/pdf"];

            //Does this data object match one of these IDs?
            if(_.indexOf(ids, this.get('formatId')) == -1) return false;
            else return true;
          },

          /**
           * Set the DataONE ProvONE provenance class
           * param className - the shortened form of the actual classname value. The
           * shortname will be appened to the ProvONE namespace, for example,
           * the className "program" will result in the final class name
           * "http://purl.dataone.org/provone/2015/01/15/ontology#Program"
           * see https://github.com/DataONEorg/sem-prov-ontologies/blob/master/provenance/ProvONE/v1/provone.html
           * @param {string} className
           */
           setProvClass: function(className) {
             className = className.toLowerCase();
             className = className.charAt(0).toUpperCase() + className.slice(1)

             /* This function is intended to be used for the ProvONE classes that are
              * typically represented in DataONEObjects: "Data", "Program", and hopefully
              * someday "Execution", as we don't allow the user to set the namespace
              * e.g. to "PROV", so therefor we check for the currently known ProvONE classes.
              */
              if (_.contains(['Program', 'Data', 'Visualization', 'Document', 'Execution', 'User'], className)) {
                  this.set("prov_instanceOfClass", [this.PROVONE + className]);
              } else if (_.contains(['Entity', 'Usage', 'Generation', 'Association'], className)) {
                  this.set("prov_instanceOfClass", [this.PROV + className]);
              } else {
                 message = "The given class name: " + className + " is not in the known ProvONE or PROV classes."
                 throw new Error(message);
              }
           },

          /**
           *  Calculate a checksum for the object
           *  @param {string} [algorithm]  The algorithm to use, defaults to MD5
           *  @return {string} A checksum plain JS object with value and algorithm attributes
           */
          calculateChecksum: function(algorithm) {
            var algorithm = algorithm || "MD5";
            var checksum = {algorithm: undefined, value: undefined};
            var hash; // The checksum hash
            var file; // The file to be read by slicing
            var reader; // The FileReader used to read each slice
            var offset = 0; // Byte offset for reading slices
            var sliceSize = Math.pow(2,20) // 1MB slices
            var model = this;

            // Do we have a file?
            if (this.get("uploadFile") instanceof Blob) {
                file = this.get("uploadFile");
                reader = new FileReader();
                /* Handle load errors */
                reader.onerror = function(event) {
                    console.log("Error reading: " + event);
                };
                /* Show progress */
                reader.onprogress = function(event) {
                };
                /* Handle load finish */
                reader.onloadend = function(event) {
                    if (event.target.readyState == FileReader.DONE) {
                        hash.update(event.target.result);
                    }
                    offset += sliceSize;
                    if ( _seek() ) {
                        model.set("checksum", hash.hex());
                        model.set("checksumAlgorithm", checksum.algorithm);
                        model.trigger("checksumCalculated", model.attributes);
                    };
                };
            } else {
                message = "The given object is not a blob or a file object."
                throw new Error(message);
            }

            switch ( algorithm ) {
                case "MD5":
                    checksum.algorithm = algorithm;
                    hash = md5.create();
                    _seek();
                    break;
                case "SHA-1":
                    // TODO: Support SHA-1
                    // break;
                default:
                    message = "The given algorithm: " + algorithm + " is not supported."
                    throw new Error(message);
            }

            /*
             *  A helper function internal to calculateChecksum() used to slice
             *  the file at the next offset by slice size
             */
            function _seek() {
                var calculated = false;
                var slice;
                // Digest the checksum when we're done calculating
                if (offset >= file.size) {
                    hash.digest();
                    calculated = true;
                    return calculated;
                }
                // slice the file and read the slice
                slice = file.slice(offset, offset + sliceSize);
                reader.readAsArrayBuffer(slice);
                return calculated;

            }
        },

          /**
           * Checks if the pid or sid or given string is a DOI
           *
           * @param {string} customString - Optional. An identifier string to check instead of the id and seriesId attributes on the model
           * @returns {boolean} True if it is a DOI
           */
          isDOI: function(customString) {
          var DOI_PREFIXES = ["doi:10.", "http://dx.doi.org/10.", "http://doi.org/10.", "http://doi.org/doi:10.",
            "https://dx.doi.org/10.", "https://doi.org/10.", "https://doi.org/doi:10."],
              DOI_REGEX = new RegExp(/^10.\d{4,9}\/[-._;()/:A-Z0-9]+$/i);;

          //If a custom string is given, then check that instead of the seriesId and id from the model
          if( typeof customString == "string" ){
            for (var i=0; i &lt; DOI_PREFIXES.length; i++) {
              if (customString.toLowerCase().indexOf(DOI_PREFIXES[i].toLowerCase()) == 0 )
                return true;
            }

            //If there is no DOI prefix, check for a DOI without the prefix using a regular expression
            if( DOI_REGEX.test(customString) ){
              return true;
            }

          }
          else{
            var seriesId = this.get("seriesId"),
                pid      = this.get("id");

            for (var i=0; i &lt; DOI_PREFIXES.length; i++) {
              if (seriesId &amp;&amp; seriesId.toLowerCase().indexOf(DOI_PREFIXES[i].toLowerCase()) == 0 )
                return true;
              else if (pid &amp;&amp; pid.toLowerCase().indexOf(DOI_PREFIXES[i].toLowerCase()) == 0 )
                return true;
            }

            //If there is no DOI prefix, check for a DOI without the prefix using a regular expression
            if( DOI_REGEX.test(seriesId) || DOI_REGEX.test(pid) ){
              return true;
            }

          }

          return false;
        },

        /**
        * Creates an array of objects that represent Member Nodes that could possibly be this
        * object's authoritative MN. This function updates the `possibleAuthMNs` attribute on this model.
        */
        setPossibleAuthMNs: function(){

          //Only do this for Coordinating Node MetacatUIs.
          if( MetacatUI.appModel.get("alternateRepositories").length ){
            //Set the possibleAuthMNs attribute
            var possibleAuthMNs = [];

            //If a datasource is already found for this Portal, move that to the top of the list of auth MNs
            var datasource = this.get("datasource") || "";
            if( datasource ){
              //Find the MN object that matches the datasource node ID
              var datasourceMN = _.findWhere(MetacatUI.appModel.get("alternateRepositories"), { identifier: datasource });
              if( datasourceMN ){
                //Clone the MN object and add it to the array
                var clonedDatasourceMN = Object.assign({}, datasourceMN);
                possibleAuthMNs.push(clonedDatasourceMN);
              }
            }

            //If there is an active alternate repo, move that to the top of the list of auth MNs
            var activeAltRepo = MetacatUI.appModel.get("activeAlternateRepositoryId") || "";
            if( activeAltRepo ){
              var activeAltRepoMN = _.findWhere(MetacatUI.appModel.get("alternateRepositories"), { identifier: activeAltRepo });
              if( activeAltRepoMN ){
                //Clone the MN object and add it to the array
                var clonedActiveAltRepoMN = Object.assign({}, activeAltRepoMN);
                possibleAuthMNs.push(clonedActiveAltRepoMN);
              }
            }

            //Add all the other alternate repositories to the list of auth MNs
            var otherPossibleAuthMNs = _.reject(MetacatUI.appModel.get("alternateRepositories"), function(mn){
                                         return (mn.identifier == datasource || mn.identifier == activeAltRepo);
                                       });
            //Clone each MN object and add to the array
            _.each(otherPossibleAuthMNs, function(mn){
              var clonedMN = Object.assign({}, mn);
              possibleAuthMNs.push(clonedMN);
            });

            //Update this model
            this.set("possibleAuthMNs", possibleAuthMNs);

          }
        }
    },
    /** @lends DataONEObject.prototype */
    {
      /**
      * Generate a unique identifier to be used as an XML id attribute
      * @returns {string} The identifier string that was generated
      */
      generateId: function() {
        var idStr = ''; // the id to return
        var length = 30; // the length of the generated string
        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz'.split('');

        for (var i = 0; i &lt; length; i++) {
          idStr += chars[Math.floor(Math.random() * chars.length)];
        }
        return idStr;
      }
    });

    return DataONEObject;
});
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
