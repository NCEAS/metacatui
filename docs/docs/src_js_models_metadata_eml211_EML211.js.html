<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>MetacatUI Dev Docs: Source: src/js/models/metadata/eml211/EML211.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="/metacatui/assets/css/styles.css">
    <link type="text/css" rel="stylesheet" href="styles/style.css">
</head>

<body>

<nav id="nav">
    <a href="/">
      <div class="logo">
<svg class="cat" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="cat" class="svg-inline--fa fa-cat fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M290.59 192c-20.18 0-106.82 1.98-162.59 85.95V192c0-52.94-43.06-96-96-96-17.67 0-32 14.33-32 32s14.33 32 32 32c17.64 0 32 14.36 32 32v256c0 35.3 28.7 64 64 64h176c8.84 0 16-7.16 16-16v-16c0-17.67-14.33-32-32-32h-32l128-96v144c0 8.84 7.16 16 16 16h32c8.84 0 16-7.16 16-16V289.86c-10.29 2.67-20.89 4.54-32 4.54-61.81 0-113.52-44.05-125.41-102.4zM448 96h-64l-64-64v134.4c0 53.02 42.98 96 96 96s96-42.98 96-96V32l-64 64zm-72 80c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16zm80 0c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16z"></path></svg>

<svg width="459px" height="53px" viewBox="0 0 459 53" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="metacatui" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M16.492,52 C17.212,52 17.812,51.748 18.292,51.244 C18.772,50.74 19.012,50.128 19.012,49.408 L19.012,49.408 L18.94,22.912 L30.82,37.816 C31.204,38.344 31.72,38.764 32.368,39.076 C33.016,39.388 33.7,39.544 34.42,39.544 C35.908,39.544 37.132,38.896 38.092,37.6 L38.092,37.6 L49.684,22.912 L49.684,49.408 C49.684,50.128 49.96,50.74 50.512,51.244 C51.064,51.748 51.7,52 52.42,52 L52.42,52 L62.068,52 C62.788,52 63.388,51.748 63.868,51.244 C64.348,50.74 64.588,50.128 64.588,49.408 L64.588,49.408 L64.588,4.12 C64.588,3.448 64.336,2.86 63.832,2.356 C63.328,1.852 62.74,1.6 62.068,1.6 L62.068,1.6 L52.348,1.6 C51.388,1.6 50.56,1.648 49.864,1.744 C49.168,1.84 48.532,2.152 47.956,2.68 L47.956,2.68 L33.916,17.296 L20.524,2.608 C20.332,2.368 19.972,2.14 19.444,1.924 C18.916,1.708 18.412,1.6 17.932,1.6 L17.932,1.6 L6.772,1.6 C6.052,1.6 5.44,1.852 4.936,2.356 C4.432,2.86 4.18,3.448 4.18,4.12 L4.18,4.12 L4.18,49.408 C4.18,50.08 4.432,50.68 4.936,51.208 C5.44,51.736 6.052,52 6.772,52 L6.772,52 L16.492,52 Z M110.74,52 C111.556,52 112.264,51.676 112.864,51.028 C113.464,50.38 113.764,49.624 113.764,48.76 L113.764,48.76 L113.764,42.568 C113.764,41.608 113.464,40.828 112.864,40.228 C112.264,39.628 111.556,39.328 110.74,39.328 L110.74,39.328 L89.428,39.328 L89.428,32.92 L109.732,32.92 C110.5,32.92 111.184,32.596 111.784,31.948 C112.384,31.3 112.684,30.568 112.684,29.752 L112.684,29.752 L112.684,23.488 C112.684,22.576 112.384,21.82 111.784,21.22 C111.184,20.62 110.5,20.32 109.732,20.32 L109.732,20.32 L89.428,20.32 L89.428,14.488 L110.74,14.488 C111.508,14.488 112.204,14.164 112.828,13.516 C113.452,12.868 113.764,12.136 113.764,11.32 L113.764,11.32 L113.764,5.056 C113.764,4.144 113.464,3.388 112.864,2.788 C112.264,2.188 111.556,1.888 110.74,1.888 L110.74,1.888 L76.756,1.888 C75.94,1.888 75.232,2.188 74.632,2.788 C74.032,3.388 73.732,4.144 73.732,5.056 L73.732,5.056 L73.732,48.76 C73.732,49.624 74.032,50.38 74.632,51.028 C75.232,51.676 75.94,52 76.756,52 L76.756,52 L110.74,52 Z M147.604,52 C148.42,52 149.104,51.688 149.656,51.064 C150.208,50.44 150.484,49.672 150.484,48.76 L150.484,48.76 L150.484,16.216 L161.86,16.216 C162.676,16.216 163.396,15.904 164.02,15.28 C164.644,14.656 164.956,13.936 164.956,13.12 L164.956,13.12 L164.956,4.768 C164.956,4 164.644,3.316 164.02,2.716 C163.396,2.116 162.676,1.816 161.86,1.816 L161.86,1.816 L124.132,1.816 C123.22,1.816 122.464,2.104 121.864,2.68 C121.264,3.256 120.964,3.952 120.964,4.768 L120.964,4.768 L120.964,13.12 C120.964,13.936 121.264,14.656 121.864,15.28 C122.464,15.904 123.22,16.216 124.132,16.216 L124.132,16.216 L135.652,16.216 L135.148,48.832 C135.148,49.744 135.424,50.5 135.976,51.1 C136.528,51.7 137.212,52 138.028,52 L138.028,52 L147.604,52 Z M175.828,52 C176.836,52 177.676,51.82 178.348,51.46 C179.02,51.1 179.452,50.584 179.644,49.912 L179.644,49.912 L181.876,42.712 L197.932,42.712 L200.164,49.912 C200.356,50.584 200.8,51.1 201.496,51.46 C202.192,51.82 203.044,52 204.052,52 L204.052,52 L213.916,52 C215.836,51.712 216.796,50.704 216.796,48.976 C216.796,48.304 216.676,47.596 216.436,46.852 C216.196,46.108 216.052,45.616 216.004,45.376 L216.004,45.376 L199.876,4.84 C199.588,3.976 199.036,3.232 198.22,2.608 C197.404,1.984 196.372,1.648 195.124,1.6 L195.124,1.6 L184.756,1.6 C183.604,1.648 182.608,1.948 181.768,2.5 C180.928,3.052 180.292,3.832 179.86,4.84 L179.86,4.84 L163.876,45.376 C163.828,45.472 163.672,45.916 163.408,46.708 C163.144,47.5 163.012,48.304 163.012,49.12 C163.012,50.752 163.948,51.712 165.82,52 L165.82,52 L175.828,52 Z M195.34,30.544 L184.036,30.544 L189.652,13.624 L195.34,30.544 Z M245.38,53.08 C250.612,53.08 255.652,51.544 260.5,48.472 C261.22,47.944 261.58,47.296 261.58,46.528 C261.58,45.808 261.292,45.16 260.716,44.584 L260.716,44.584 L252.796,36.808 C252.364,36.376 251.836,36.16 251.212,36.16 C250.78,36.16 250.372,36.256 249.988,36.448 C248.356,37.12 246.796,37.456 245.308,37.456 C243.244,37.456 241.348,36.952 239.62,35.944 C237.892,34.936 236.512,33.58 235.48,31.876 C234.448,30.172 233.932,28.336 233.932,26.368 C233.932,24.352 234.436,22.504 235.444,20.824 C236.452,19.144 237.832,17.812 239.584,16.828 C241.336,15.844 243.244,15.352 245.308,15.352 C246.892,15.352 248.332,15.64 249.628,16.216 C250.012,16.408 250.444,16.504 250.924,16.504 C251.548,16.504 252.1,16.264 252.58,15.784 L252.58,15.784 L259.636,8.008 C260.164,7.384 260.428,6.76 260.428,6.136 C260.428,5.224 259.996,4.528 259.132,4.048 C254.86,1.552 250.276,0.304 245.38,0.304 C240.532,0.304 236.032,1.492 231.88,3.868 C227.728,6.244 224.44,9.448 222.016,13.48 C219.592,17.512 218.38,21.904 218.38,26.656 C218.38,31.408 219.592,35.812 222.016,39.868 C224.44,43.924 227.728,47.14 231.88,49.516 C236.032,51.892 240.532,53.08 245.38,53.08 Z M279.796,52 C280.804,52 281.644,51.82 282.316,51.46 C282.988,51.1 283.42,50.584 283.612,49.912 L283.612,49.912 L285.844,42.712 L301.9,42.712 L304.132,49.912 C304.324,50.584 304.768,51.1 305.464,51.46 C306.16,51.82 307.012,52 308.02,52 L308.02,52 L317.884,52 C319.804,51.712 320.764,50.704 320.764,48.976 C320.764,48.304 320.644,47.596 320.404,46.852 C320.164,46.108 320.02,45.616 319.972,45.376 L319.972,45.376 L303.844,4.84 C303.556,3.976 303.004,3.232 302.188,2.608 C301.372,1.984 300.34,1.648 299.092,1.6 L299.092,1.6 L288.724,1.6 C287.572,1.648 286.576,1.948 285.736,2.5 C284.896,3.052 284.26,3.832 283.828,4.84 L283.828,4.84 L267.844,45.376 C267.796,45.472 267.64,45.916 267.376,46.708 C267.112,47.5 266.98,48.304 266.98,49.12 C266.98,50.752 267.916,51.712 269.788,52 L269.788,52 L279.796,52 Z M299.308,30.544 L288.004,30.544 L293.62,13.624 L299.308,30.544 Z M352.588,52 C353.404,52 354.088,51.688 354.64,51.064 C355.192,50.44 355.468,49.672 355.468,48.76 L355.468,48.76 L355.468,16.216 L366.844,16.216 C367.66,16.216 368.38,15.904 369.004,15.28 C369.628,14.656 369.94,13.936 369.94,13.12 L369.94,13.12 L369.94,4.768 C369.94,4 369.628,3.316 369.004,2.716 C368.38,2.116 367.66,1.816 366.844,1.816 L366.844,1.816 L329.116,1.816 C328.204,1.816 327.448,2.104 326.848,2.68 C326.248,3.256 325.948,3.952 325.948,4.768 L325.948,4.768 L325.948,13.12 C325.948,13.936 326.248,14.656 326.848,15.28 C327.448,15.904 328.204,16.216 329.116,16.216 L329.116,16.216 L340.636,16.216 L340.132,48.832 C340.132,49.744 340.408,50.5 340.96,51.1 C341.512,51.7 342.196,52 343.012,52 L343.012,52 L352.588,52 Z M402.052,52.792 C408.1,52.792 412.912,51.628 416.488,49.3 C420.064,46.972 422.536,44.068 423.904,40.588 C425.272,37.108 425.932,33.424 425.884,29.536 C425.884,29.5309474 425.883967,29.5237673 425.8839,29.5144598 L425.883102,29.4330859 C425.879911,29.1480111 425.868211,28.3183158 425.848,26.944 C425.8294,25.6792 425.818008,22.91524 425.813823,18.65212 L425.813103,17.80828 C425.812997,17.66452 425.8129,17.5192 425.81281,17.37232 L425.812,3.904 C425.86,3.184 425.632,2.62 425.128,2.212 C424.624,1.804 423.916,1.6 423.004,1.6 L423.004,1.6 L413.428,1.6 C412.612,1.6 411.904,1.828 411.304,2.284 C410.704,2.74 410.404,3.28 410.404,3.904 L410.404,3.904 L410.26,27.808 C410.26,34.144 407.476,37.312 401.908,37.312 C399.076,37.312 396.832,36.412 395.176,34.612 C393.52,32.812 392.668,30.352 392.62,27.232 L392.62,27.232 L392.332,3.76 C392.332,3.088 392.068,2.56 391.54,2.176 C391.012,1.792 390.268,1.6 389.308,1.6 L389.308,1.6 L379.876,1.6 C378.244,1.6 377.428,2.32 377.428,3.76 L377.428,3.76 L377.5,28.816 C377.5,33.04 378.376,36.964 380.128,40.588 C381.88,44.212 384.592,47.152 388.264,49.408 C391.936,51.664 396.532,52.792 402.052,52.792 Z M449.284,52.144 C450.148,52.144 450.88,51.844 451.48,51.244 C452.08,50.644 452.38,49.84 452.38,48.832 L452.38,48.832 L452.38,4.912 C452.38,4 452.08,3.22 451.48,2.572 C450.88,1.924 450.148,1.6 449.284,1.6 L449.284,1.6 L439.42,1.6 C438.46,1.6 437.692,1.924 437.116,2.572 C436.54,3.22 436.252,4 436.252,4.912 L436.252,4.912 L436.252,48.832 C436.252,49.84 436.54,50.644 437.116,51.244 C437.692,51.844 438.46,52.144 439.42,52.144 L439.42,52.144 L449.284,52.144 Z" id="metacatui" fill="#FCBF49" fill-rule="nonzero"></path>
    </g>
</svg>
</logo>

    </a>
    <h3>Namespaces</h3><ul><li><a href="AppConfig.html">AppConfig</a></li><li><a href="MetacatUI.html">MetacatUI</a></li><li><a href="Utilities.html">Utilities</a></li></ul><h3>Classes</h3><ul><li class='category-heading' data-category='Collections'>Collections</li><li><a href="AccessPolicy.html">AccessPolicy</a></li><li><a href="Citations.html">Citations</a></li><li><a href="DataPackage.html">DataPackage</a></li><li><a href="Filters.html">Filters</a></li><li><a href="ObjectFormats.html">ObjectFormats</a></li><li><a href="QualityReport.html">QualityReport</a></li><li><a href="SolrResults.html">SolrResults</a></li><li><a href="Units.html">Units</a></li><li><a href="UserGroup.html">UserGroup</a></li><li class='category-heading' data-category='Collections/Bookkeeper'>Collections/Bookkeeper</li><li><a href="Quotas.html">Quotas</a></li><li><a href="Usages.html">Usages</a></li><li class='category-heading' data-category='Collections/QueryFields'>Collections/QueryFields</li><li><a href="QueryFields.html">QueryFields</a></li><li class='category-heading' data-category='Models'>Models</li><li><a href="AccessRule.html">AccessRule</a></li><li><a href="AppModel.html">AppModel</a></li><li><a href="Citation.html">Citation</a></li><li><a href="CollectionModel.html">CollectionModel</a></li><li><a href="DataONEObject.html">DataONEObject</a></li><li><a href="LookupModel.html">LookupModel</a></li><li><a href="Map.html">Map</a></li><li><a href="Metrics.html">Metrics</a></li><li><a href="QualityCheck.html">QualityCheck</a></li><li><a href="Search.html">Search</a></li><li><a href="SolrResult.html">SolrResult</a></li><li><a href="Stats.html">Stats</a></li><li class='category-heading' data-category='Models/Bookkeeper'>Models/Bookkeeper</li><li><a href="Quota.html">Quota</a></li><li><a href="Subscription.html">Subscription</a></li><li><a href="Usage.html">Usage</a></li><li class='category-heading' data-category='Models/Filters'>Models/Filters</li><li><a href="BooleanFilter.html">BooleanFilter</a></li><li><a href="ChoiceFilter.html">ChoiceFilter</a></li><li><a href="DateFilter.html">DateFilter</a></li><li><a href="Filter.html">Filter</a></li><li><a href="FilterGroup.html">FilterGroup</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="SpatialFilter.html">SpatialFilter</a></li><li><a href="ToggleFilter.html">ToggleFilter</a></li><li class='category-heading' data-category='Models/Formats'>Models/Formats</li><li><a href="ObjectFormat.html">ObjectFormat</a></li><li class='category-heading' data-category='Models/Metadata'>Models/Metadata</li><li><a href="ScienceMetadata.html">ScienceMetadata</a></li><li class='category-heading' data-category='Models/Metadata/EML211'>Models/Metadata/EML211</li><li><a href="EML211.html">EML211</a></li><li><a href="EMLAttribute.html">EMLAttribute</a></li><li><a href="EMLDataTable.html">EMLDataTable</a></li><li><a href="EMLEntity.html">EMLEntity</a></li><li><a href="EMLGeoCoverage.html">EMLGeoCoverage</a></li><li><a href="EMLMeasurementScale.html">EMLMeasurementScale</a></li><li><a href="EMLNonNumericDomain.html">EMLNonNumericDomain</a></li><li><a href="EMLNumericDomain.html">EMLNumericDomain</a></li><li><a href="EMLOtherEntity.html">EMLOtherEntity</a></li><li><a href="EMLParty.html">EMLParty</a></li><li><a href="EMLTemporalCoverage.html">EMLTemporalCoverage</a></li><li><a href="EMLUnit.html">EMLUnit</a></li><li class='category-heading' data-category='Models/Metadata/EML220'>Models/Metadata/EML220</li><li><a href="EMLText.html">EMLText</a></li><li class='category-heading' data-category='Models/Portals'>Models/Portals</li><li><a href="PortalImage.html">PortalImage</a></li><li><a href="PortalModel.html">PortalModel</a></li><li><a href="PortalSectionModel.html">PortalSectionModel</a></li><li class='category-heading' data-category='Models/QueryFields'>Models/QueryFields</li><li><a href="QueryField.html">QueryField</a></li><li class='category-heading' data-category='Router'>Router</li><li><a href="UIRouter.html">UIRouter</a></li><li class='category-heading' data-category='Views'>Views</li><li><a href="AccessPolicyView.html">AccessPolicyView</a></li><li><a href="AccessRuleView.html">AccessRuleView</a></li><li><a href="AnnotationView.html">AnnotationView</a></li><li><a href="AppView.html">AppView</a></li><li><a href="CitationListView.html">CitationListView</a></li><li><a href="ColorPaletteView.html">ColorPaletteView</a></li><li><a href="DataCatalogViewWithFilters.html">DataCatalogViewWithFilters</a></li><li><a href="DataItemView.html">DataItemView</a></li><li><a href="DataPackageView.html">DataPackageView</a></li><li><a href="DraftsView.html">DraftsView</a></li><li><a href="EditCollectionView.html">EditCollectionView</a></li><li><a href="EditorView.html">EditorView</a></li><li><a href="GroupListView.html">GroupListView</a></li><li><a href="ImageUploaderView.html">ImageUploaderView</a></li><li><a href="MarkdownEditorView.html">MarkdownEditorView</a></li><li><a href="MarkdownView.html">MarkdownView</a></li><li><a href="MdqRunView.html">MdqRunView</a></li><li><a href="MetadataView.html">MetadataView</a></li><li><a href="MetricModalView.html">MetricModalView</a></li><li><a href="MetricsChartView.html">MetricsChartView</a></li><li><a href="MetricView.html">MetricView</a></li><li><a href="NavbarView.html">NavbarView</a></li><li><a href="RegisterCitationView.html">RegisterCitationView</a></li><li><a href="SignInView.html">SignInView</a></li><li><a href="TableEditorView.html">TableEditorView</a></li><li><a href="TOCView.html">TOCView</a></li><li><a href="UserView.html">UserView</a></li><li class='category-heading' data-category='Views/Filters'>Views/Filters</li><li><a href="BooleanFilterView.html">BooleanFilterView</a></li><li><a href="ChoiceFilterView.html">ChoiceFilterView</a></li><li><a href="DateFilterView.html">DateFilterView</a></li><li><a href="FilterEditorView.html">FilterEditorView</a></li><li><a href="FilterGroupsView.html">FilterGroupsView</a></li><li><a href="FilterGroupView.html">FilterGroupView</a></li><li><a href="FilterView.html">FilterView</a></li><li><a href="NumericFilterView.html">NumericFilterView</a></li><li><a href="ToggleFilterView.html">ToggleFilterView</a></li><li class='category-heading' data-category='Views/Metadata'>Views/Metadata</li><li><a href="EML211EditorView.html">EML211EditorView</a></li><li><a href="EMLAttributeView.html">EMLAttributeView</a></li><li><a href="EMLEntityView.html">EMLEntityView</a></li><li><a href="EMlGeoCoverageView.html">EMlGeoCoverageView</a></li><li><a href="EMLMeasurementScaleView.html">EMLMeasurementScaleView</a></li><li><a href="EMLMeasurementTypeView.html">EMLMeasurementTypeView</a></li><li><a href="EMLMethodsView.html">EMLMethodsView</a></li><li><a href="EMLOtherEntityView.html">EMLOtherEntityView</a></li><li><a href="EMLPartyView.html">EMLPartyView</a></li><li><a href="EMLTempCoverageView.html">EMLTempCoverageView</a></li><li><a href="EMLView.html">EMLView</a></li><li><a href="ScienceMetadataView.html">ScienceMetadataView</a></li><li class='category-heading' data-category='Views/Portals'>Views/Portals</li><li><a href="PortalDataView.html">PortalDataView</a></li><li><a href="PortalHeaderView.html">PortalHeaderView</a></li><li><a href="PortalListView.html">PortalListView</a></li><li><a href="PortalLogosView.html">PortalLogosView</a></li><li><a href="PortalMembersView.html">PortalMembersView</a></li><li><a href="PortalSectionView.html">PortalSectionView</a></li><li><a href="PortalsSearchView.html">PortalsSearchView</a></li><li><a href="PortalUsagesView.html">PortalUsagesView</a></li><li><a href="PortalView.html">PortalView</a></li><li><a href="PortalVisualizationsView.html">PortalVisualizationsView</a></li><li class='category-heading' data-category='Views/Portals/Editor'>Views/Portals/Editor</li><li><a href="PortalEditorView.html">PortalEditorView</a></li><li><a href="PortEditorDataView.html">PortEditorDataView</a></li><li><a href="PortEditorImageView.html">PortEditorImageView</a></li><li><a href="PortEditorLogosView.html">PortEditorLogosView</a></li><li><a href="PortEditorMdSectionView.html">PortEditorMdSectionView</a></li><li><a href="PortEditorSectionsView.html">PortEditorSectionsView</a></li><li><a href="PortEditorSectionView.html">PortEditorSectionView</a></li><li><a href="PortEditorSettingsView.html">PortEditorSettingsView</a></li><li class='category-heading' data-category='Views/QueryBuilder'>Views/QueryBuilder</li><li><a href="QueryBuilderView.html">QueryBuilderView</a></li><li><a href="QueryRuleView.html">QueryRuleView</a></li><li class='category-heading' data-category='Views/SearchSelect'>Views/SearchSelect</li><li><a href="AccountSelectView.html">AccountSelectView</a></li><li><a href="AnnotationFilter.html">AnnotationFilter</a></li><li><a href="NodeSelect.html">NodeSelect</a></li><li><a href="ObjectFormatSelect.html">ObjectFormatSelect</a></li><li><a href="QueryFieldSelectView.html">QueryFieldSelectView</a></li><li><a href="SearchableSelectView.html">SearchableSelectView</a></li><li><a href="EMLAnnotation.html">EMLAnnotation</a></li><li class='category-heading' data-category='Deprecated'>Deprecated</li><li><a href="ExternalView.html">ExternalView</a></li><li><a href="LogsSearch.html">LogsSearch</a></li></ul><h3>Global</h3><ul><li><a href="global.html#appConfigPath">appConfigPath</a></li></ul>
</nav>

<div id="main">

    <h1 class="page-title">Source: src/js/models/metadata/eml211/EML211.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* global define */
define(['jquery', 'underscore', 'backbone', 'uuid',
        'collections/Units',
        'models/metadata/ScienceMetadata',
        'models/DataONEObject',
        'models/metadata/eml211/EMLGeoCoverage',
        'models/metadata/eml211/EMLKeywordSet',
        'models/metadata/eml211/EMLTaxonCoverage',
        'models/metadata/eml211/EMLTemporalCoverage',
        'models/metadata/eml211/EMLDistribution',
        'models/metadata/eml211/EMLEntity',
        'models/metadata/eml211/EMLDataTable',
        'models/metadata/eml211/EMLOtherEntity',
        'models/metadata/eml211/EMLParty',
        'models/metadata/eml211/EMLProject',
        'models/metadata/eml211/EMLText',
        'models/metadata/eml211/EMLMethods',
        'models/metadata/eml211/EMLAnnotation'],
    function($, _, Backbone, uuid, Units, ScienceMetadata, DataONEObject,
        EMLGeoCoverage, EMLKeywordSet, EMLTaxonCoverage, EMLTemporalCoverage,
        EMLDistribution, EMLEntity, EMLDataTable, EMLOtherEntity, EMLParty,
            EMLProject, EMLText, EMLMethods, EMLAnnotation) {

      /**
      * @class EML211
      * @classdesc An EML211 object represents an Ecological Metadata Language
      * document, version 2.1.1
      * @classcategory Models/Metadata/EML211
      * @extends ScienceMetadata
      */
      var EML211 = ScienceMetadata.extend(
        /** @lends EML211.prototype */{

        type: "EML",

        defaults: function(){
          return _.extend(ScienceMetadata.prototype.defaults(), {
            id: "urn:uuid:" + uuid.v4(),
            formatId: "https://eml.ecoinformatics.org/eml-2.2.0",
            objectXML: null,
              isEditable: false,
              alternateIdentifier: [],
              shortName: null,
              title: [],
              creator: [], // array of EMLParty objects
              metadataProvider: [], // array of EMLParty objects
              associatedParty : [], // array of EMLParty objects
              contact: [], // array of EMLParty objects
              publisher: [], // array of EMLParty objects
              pubDate: null,
              language: null,
              series: null,
              abstract: [], //array of EMLText objects
              keywordSets: [], //array of EMLKeywordSet objects
              additionalInfo: [],
              intellectualRights: "This work is dedicated to the public domain under the Creative Commons Universal 1.0 Public Domain Dedication. To view a copy of this dedication, visit https://creativecommons.org/publicdomain/zero/1.0/.",
              onlineDist: [], // array of EMLOnlineDist objects
              offlineDist: [], // array of EMLOfflineDist objects
              geoCoverage : [], //an array for EMLGeoCoverages
              temporalCoverage : [], //an array of EMLTempCoverage models
              taxonCoverage : [], //an array of EMLTaxonCoverages
              purpose: [],
              entities: [], //An array of EMLEntities
              pubplace: null,
              methods: null, // An EMLMethods objects
              project: null, // An EMLProject object,
              annotation: [], // Dataset-level annotations
              nodeOrder: [
                "alternateidentifier",
                "shortname",
                "title",
                "creator",
                "metadataprovider",
                "associatedparty",
                "pubdate",
                "language",
                "series",
                "abstract",
                "keywordset",
                "additionalinfo",
                "intellectualrights",
                "licensed",
                "distribution",
                "coverage",
                "annotation",
                "purpose",
                "introduction",
                "gettingstarted",
                "acknowledgements",
                "maintenance",
                "contact",
                "publisher",
                "pubplace",
                "methods",
                "project",
                "datatable",
                "spatialraster",
                "spatialvector",
                "storedprocedure",
                "view",
                "otherentity",
                "referencepublications",
                "usagecitations",
                "literaturecited",
              ]
          });
        },

        units: new Units(),

        initialize: function(attributes) {
            // Call initialize for the super class
            ScienceMetadata.prototype.initialize.call(this, attributes);

            // EML211-specific init goes here
            // this.set("objectXML", this.createXML());
            this.parse(this.createXML());

            this.on("sync", function(){
              this.set("synced", true);
            });

            //Create a Unit collection
            if(!this.units.length)
              this.createUnits();
        },

        url: function(options) {
            var identifier;
            if ( options &amp;&amp; options.update ) {
                identifier = this.get("oldPid") || this.get("seriesid");
            } else {
                identifier = this.get("id") || this.get("seriesid");
            }
            return MetacatUI.appModel.get("objectServiceUrl") + encodeURIComponent(identifier);
        },

        /*
         * Maps the lower-case EML node names (valid in HTML DOM) to the camel-cased EML node names (valid in EML).
         * Used during parse() and serialize()
         */
        nodeNameMap: function(){
          return _.extend(
              this.constructor.__super__.nodeNameMap(),
              EMLDistribution.prototype.nodeNameMap(),
              EMLGeoCoverage.prototype.nodeNameMap(),
              EMLKeywordSet.prototype.nodeNameMap(),
              EMLParty.prototype.nodeNameMap(),
              EMLProject.prototype.nodeNameMap(),
              EMLTaxonCoverage.prototype.nodeNameMap(),
              EMLTemporalCoverage.prototype.nodeNameMap(),
              EMLMethods.prototype.nodeNameMap(),
              {
                "accuracyreport" : "accuracyReport",
                "actionlist" : "actionList",
                "additionalclassifications" : "additionalClassifications",
                "additionalinfo" : "additionalInfo",
                "additionallinks" : "additionalLinks",
                "additionalmetadata" : "additionalMetadata",
                "allowfirst" : "allowFirst",
                "alternateidentifier" : "alternateIdentifier",
                "altitudedatumname" : "altitudeDatumName",
                "altitudedistanceunits" : "altitudeDistanceUnits",
                "altituderesolution" : "altitudeResolution",
                "altitudeencodingmethod" : "altitudeEncodingMethod",
                "altitudesysdef" : "altitudeSysDef",
                "asneeded" : "asNeeded",
                "associatedparty" : "associatedParty",
                "attributeaccuracyexplanation" : "attributeAccuracyExplanation",
                "attributeaccuracyreport" : "attributeAccuracyReport",
                "attributeaccuracyvalue" : "attributeAccuracyValue",
                "attributedefinition" : "attributeDefinition",
                "attributelabel" : "attributeLabel",
                "attributelist" : "attributeList",
                "attributename" : "attributeName",
                "attributeorientation" : "attributeOrientation",
                "attributereference" : "attributeReference",
                "awardnumber" : "awardNumber",
                "awardurl" : "awardUrl",
                "audiovisual" : "audioVisual",
                "authsystem" : "authSystem",
                "banddescription" : "bandDescription",
                "bilinearfit" : "bilinearFit",
                "binaryrasterformat" : "binaryRasterFormat",
                "blockedmembernode" : "blockedMemberNode",
                "booktitle" : "bookTitle",
                "cameracalibrationinformationavailability" : "cameraCalibrationInformationAvailability",
                "casesensitive" : "caseSensitive",
                "cellgeometry" : "cellGeometry",
                "cellsizexdirection" : "cellSizeXDirection",
                "cellsizeydirection" : "cellSizeYDirection",
                "changehistory" : "changeHistory",
                "changedate" : "changeDate",
                "changescope" : "changeScope",
                "chapternumber" : "chapterNumber",
                "characterencoding" : "characterEncoding",
                "checkcondition" : "checkCondition",
                "checkconstraint" : "checkConstraint",
                "childoccurences" : "childOccurences",
                "citableclassificationsystem" : "citableClassificationSystem",
                "cloudcoverpercentage" : "cloudCoverPercentage",
                "codedefinition" : "codeDefinition",
                "codeexplanation" : "codeExplanation",
                "codesetname" : "codesetName",
                "codeseturl" : "codesetURL",
                "collapsedelimiters" : "collapseDelimiters",
                "communicationtype" : "communicationType",
                "compressiongenerationquality" : "compressionGenerationQuality",
                "compressionmethod" : "compressionMethod",
                "conferencedate" : "conferenceDate",
                "conferencelocation" : "conferenceLocation",
                "conferencename" : "conferenceName",
                "conferenceproceedings" : "conferenceProceedings",
                "constraintdescription" : "constraintDescription",
                "constraintname" : "constraintName",
                "constanttosi" : "constantToSI",
                "controlpoint" : "controlPoint",
                "cornerpoint" : "cornerPoint",
                "customunit" : "customUnit",
                "dataformat" : "dataFormat",
                "datasetgpolygon" : "datasetGPolygon",
                "datasetgpolygonoutergring" : "datasetGPolygonOuterGRing",
                "datasetgpolygonexclusiongring" : "datasetGPolygonExclusionGRing",
                "datatable" : "dataTable",
                "datatype" : "dataType",
                "datetime" : "dateTime",
                "datetimedomain" : "dateTimeDomain",
                "datetimeprecision" : "dateTimePrecision",
                "defaultvalue" : "defaultValue",
                "definitionattributereference" : "definitionAttributeReference",
                "denomflatratio" : "denomFlatRatio",
                "depthsysdef" : "depthSysDef",
                "depthdatumname" : "depthDatumName",
                "depthdistanceunits" : "depthDistanceUnits",
                "depthencodingmethod" : "depthEncodingMethod",
                "depthresolution" : "depthResolution",
                "descriptorvalue" : "descriptorValue",
                "dictref" : "dictRef",
                "diskusage" : "diskUsage",
                "domainDescription" : "domainDescription",
                "editedbook" : "editedBook",
                "encodingmethod" : "encodingMethod",
                "endcondition" : "endCondition",
                "entitycodelist" : "entityCodeList",
                "entitydescription" : "entityDescription",
                "entityname" : "entityName",
                "entityreference" : "entityReference",
                "entitytype" : "entityType",
                "enumerateddomain" : "enumeratedDomain",
                "errorbasis" : "errorBasis",
                "errorvalues" : "errorValues",
                "externalcodeset" : "externalCodeSet",
                "externallydefinedformat" : "externallyDefinedFormat",
                "fielddelimiter" : "fieldDelimiter",
                "fieldstartcolumn" : "fieldStartColumn",
                "fieldwidth" : "fieldWidth",
                "filmdistortioninformationavailability" : "filmDistortionInformationAvailability",
                "foreignkey" : "foreignKey",
                "formatname" : "formatName",
                "formatstring" : "formatString",
                "formatversion" : "formatVersion",
                "fractiondigits" : "fractionDigits",
                "fundername" : "funderName",
                "funderidentifier" : "funderIdentifier",
                "gettingstarted" : "gettingStarted",
                "gring" : "gRing",
                "gringpoint" : "gRingPoint",
                "gringlatitude" : "gRingLatitude",
                "gringlongitude" : "gRingLongitude",
                "geogcoordsys" : "geogCoordSys",
                "geometricobjectcount" : "geometricObjectCount",
                "georeferenceinfo" : "georeferenceInfo",
                "highwavelength" : "highWavelength",
                "horizontalaccuracy" : "horizontalAccuracy",
                "horizcoordsysdef" : "horizCoordSysDef",
                "horizcoordsysname" : "horizCoordSysName",
                "identifiername" : "identifierName",
                "illuminationazimuthangle" : "illuminationAzimuthAngle",
                "illuminationelevationangle" : "illuminationElevationAngle",
                "imagingcondition" : "imagingCondition",
                "imagequalitycode" : "imageQualityCode",
                "imageorientationangle" : "imageOrientationAngle",
                "intellectualrights" : "intellectualRights",
                "imagedescription" : "imageDescription",
                "isbn" : "ISBN",
                "issn" : "ISSN",
                "joincondition" : "joinCondition",
                "keywordtype" : "keywordType",
                "languagevalue" : "LanguageValue",
                "languagecodestandard" : "LanguageCodeStandard",
                "lensdistortioninformationavailability" : "lensDistortionInformationAvailability",
                "licensename" : "licenseName",
                "licenseurl" : "licenseURL",
                "linenumber" : "lineNumber",
                "literalcharacter" : "literalCharacter",
                "literallayout" : "literalLayout",
                "literaturecited" : "literatureCited",
                "lowwavelength" : "lowWaveLength",
                "machineprocessor" : "machineProcessor",
                "maintenanceupdatefrequency" : "maintenanceUpdateFrequency",
                "matrixtype" : "matrixType",
                "maxexclusive" : "maxExclusive",
                "maxinclusive" : "maxInclusive",
                "maxlength" : "maxLength",
                "maxrecordlength" : "maxRecordLength",
                "maxvalues" : "maxValues",
                "measurementscale" : "measurementScale",
                "metadatalist" : "metadataList",
                "methodstep" : "methodStep",
                "minexclusive" : "minExclusive",
                "mininclusive" : "minInclusive",
                "minlength" : "minLength",
                "minvalues" : "minValues",
                "missingvaluecode" : "missingValueCode",
                "moduledocs" : "moduleDocs",
                "modulename" : "moduleName",
                "moduledescription" : "moduleDescription",
                "multiband" : "multiBand",
                "multipliertosi" : "multiplierToSI",
                "nonnumericdomain" : "nonNumericDomain",
                "notnullconstraint" : "notNullConstraint",
                "notplanned" : "notPlanned",
                "numberofbands" : "numberOfBands",
                "numbertype" : "numberType",
                "numericdomain" : "numericDomain",
                "numfooterlines" : "numFooterLines",
                "numheaderlines" : "numHeaderLines",
                "numberofrecords" : "numberOfRecords",
                "numberofvolumes" : "numberOfVolumes",
                "numphysicallinesperrecord" : "numPhysicalLinesPerRecord",
                "objectname" : "objectName",
                "oldvalue" : "oldValue",
                "operatingsystem" : "operatingSystem",
                "orderattributereference" : "orderAttributeReference",
                "originalpublication" : "originalPublication",
                "otherentity" : "otherEntity",
                "othermaintenanceperiod" : "otherMaintenancePeriod",
                "parameterdefinition" : "parameterDefinition",
                "packageid" : "packageId",
                "pagerange" : "pageRange",
                "parentoccurences" : "parentOccurences",
                "parentsi" : "parentSI",
                "peakresponse" : "peakResponse",
                "personalcommunication" : "personalCommunication",
                "physicallinedelimiter" : "physicalLineDelimiter",
                "pointinpixel" : "pointInPixel",
                "preferredmembernode" : "preferredMemberNode",
                "preprocessingtypecode" : "preProcessingTypeCode",
                "primarykey" : "primaryKey",
                "primemeridian" : "primeMeridian",
                "proceduralstep" : "proceduralStep",
                "programminglanguage" : "programmingLanguage",
                "projcoordsys" : "projCoordSys",
                "projectionlist" : "projectionList",
                "propertyuri" : "propertyURI",
                "pubdate" : "pubDate",
                "pubplace" : "pubPlace",
                "publicationplace" : "publicationPlace",
                "quantitativeaccuracyreport" : "quantitativeAccuracyReport",
                "quantitativeaccuracyvalue" : "quantitativeAccuracyValue",
                "quantitativeaccuracymethod" : "quantitativeAccuracyMethod",
                "quantitativeattributeaccuracyassessment" : "quantitativeAttributeAccuracyAssessment",
                "querystatement" : "queryStatement",
                "quotecharacter" : "quoteCharacter",
                "radiometricdataavailability" : "radiometricDataAvailability",
                "rasterorigin" : "rasterOrigin",
                "recommendedunits" : "recommendedUnits",
                "recommendedusage" : "recommendedUsage",
                "referencedkey" : "referencedKey",
                "referencetype" : "referenceType",
                "relatedentry" : "relatedEntry",
                "relationshiptype" : "relationshipType",
                "reportnumber" : "reportNumber",
                "reprintedition" : "reprintEdition",
                "researchproject" : "researchProject",
                "researchtopic" : "researchTopic",
                "recorddelimiter" : "recordDelimiter",
                "referencepublication" : "referencePublication",
                "revieweditem" : "reviewedItem",
                "rowcolumnorientation" : "rowColumnOrientation",
                "runtimememoryusage" : "runtimeMemoryUsage",
                "samplingdescription" : "samplingDescription",
                "scalefactor" : "scaleFactor",
                "sequenceidentifier" : "sequenceIdentifier",
                "semiaxismajor" : "semiAxisMajor",
                "shortname" : "shortName",
                "simpledelimited" : "simpleDelimited",
                "spatialraster" : "spatialRaster",
                "spatialreference" : "spatialReference",
                "spatialvector" : "spatialVector",
                "standalone" : "standAlone",
                "standardunit" : "standardUnit",
                "startcondition" : "startCondition",
                "studyareadescription" : "studyAreaDescription",
                "storagetype" : "storageType",
                "studyextent" : "studyExtent",
                "studytype" : "studyType",
                "textdelimited" : "textDelimited",
                "textdomain" : "textDomain",
                "textfixed" : "textFixed",
                "textformat" : "textFormat",
                "topologylevel" : "topologyLevel",
                "tonegradation" : "toneGradation",
                "totaldigits" : "totalDigits",
                "totalfigures" : "totalFigures",
                "totalpages" : "totalPages",
                "totaltables" : "totalTables",
                "triangulationindicator" : "triangulationIndicator",
                "typesystem" : "typeSystem",
                "uniquekey" : "uniqueKey",
                "unittype" : "unitType",
                "unitlist" : "unitList",
                "usagecitation" : "usageCitation",
                "valueuri" : "valueURI",
                "valueattributereference" : "valueAttributeReference",
                "verticalaccuracy" : "verticalAccuracy",
                "vertcoordsys" : "vertCoordSys",
                "virtualmachine" : "virtualMachine",
                "wavelengthunits" : "waveLengthUnits",
                "whitespace" : "whiteSpace",
                "xintercept" : "xIntercept",
                "xcoordinate" : "xCoordinate",
                "xsi:schemalocation" : "xsi:schemaLocation",
                "xslope" : "xSlope",
                "ycoordinate" : "yCoordinate",
                "yintercept" : "yIntercept",
                "yslope" : "ySlope"
              }
          );
        },

        /**
        * Fetch the EML from the MN object service
        * @param {object} [options] - A set of options for this fetch()
        * @property {boolean} [options.systemMetadataOnly=false] - If true, only the system metadata will be fetched.
        * If false, the system metadata AND EML document will be fetched.
        */
        fetch: function(options) {
          if( ! options ) var options = {};

          //Add the authorization header and other AJAX settings
           _.extend(options, MetacatUI.appUserModel.createAjaxSettings(), {dataType: "text"});

            // Merge the system metadata into the object first
            _.extend(options, {merge: true});
            this.fetchSystemMetadata(options);

            //If we are retrieving system metadata only, then exit now
            if(options.systemMetadataOnly)
              return;

          //Call Backbone.Model.fetch to retrieve the info
            return Backbone.Model.prototype.fetch.call(this, options);

        },

        /*
         Deserialize an EML 2.1.1 XML document
        */
        parse: function(response) {
          // Save a reference to this model for use in setting the
          // parentModel inside anonymous functions
          var model = this;

          //If the response is XML
          if((typeof response == "string") &amp;&amp; response.indexOf("&lt;") == 0){
            //Look for a system metadata tag and call DataONEObject parse instead
            if(response.indexOf("systemMetadata>") > -1)
              return DataONEObject.prototype.parse.call(this, response);

            response = this.cleanUpXML(response);
                response = this.dereference(response);
            this.set("objectXML", response);
            var emlElement = $($.parseHTML(response)).filter("eml\\:eml");
          }

          var datasetEl;
          if(emlElement[0])
            datasetEl = $(emlElement[0]).find("dataset");

          if(!datasetEl || !datasetEl.length)
            return {};

          var emlParties = ["metadataprovider", "associatedparty", "creator", "contact", "publisher"],
              emlDistribution = ["distribution"],
              emlEntities = ["datatable", "otherentity", "spatialvector"],
              emlText = ["abstract", "additionalinfo"],
              emlMethods = ["methods"];

          var nodes = datasetEl.children(),
              modelJSON = {};

          for(var i=0; i&lt;nodes.length; i++){

            var thisNode = nodes[i];
            var convertedName = this.nodeNameMap()[thisNode.localName] || thisNode.localName;

            //EML Party modules are stored in EMLParty models
            if(_.contains(emlParties, thisNode.localName)){
              if(thisNode.localName == "metadataprovider")
                var attributeName = "metadataProvider";
              else if(thisNode.localName == "associatedparty")
                var attributeName = "associatedParty";
              else
                var attributeName = thisNode.localName;

              if(typeof modelJSON[attributeName] == "undefined") modelJSON[attributeName] = [];

              modelJSON[attributeName].push(new EMLParty({
                objectDOM: thisNode,
                parentModel: model,
                type: attributeName
              }));
            }
            //EML Distribution modules are stored in EMLDistribution models
            else if(_.contains(emlDistribution, thisNode.localName)){
              if(typeof modelJSON[thisNode.localName] == "undefined") modelJSON[thisNode.localName] = [];

              modelJSON[thisNode.localName].push(new EMLDistribution({
                objectDOM: thisNode,
                parentModel: model
              }));
            }
            //The EML Project is stored in the EMLProject model
            else if(thisNode.localName == "project"){

              modelJSON.project = new EMLProject({
                objectDOM: thisNode,
                parentModel: model
               });

            }
            //EML Temporal, Taxonomic, and Geographic Coverage modules are stored in their own models
            else if(thisNode.localName == "coverage"){

              var temporal = $(thisNode).children("temporalcoverage"),
                geo      = $(thisNode).children("geographiccoverage"),
                taxon    = $(thisNode).children("taxonomiccoverage");

              if(temporal.length){
                modelJSON.temporalCoverage = [];

                _.each(temporal, function(t){
                  modelJSON.temporalCoverage.push(new EMLTemporalCoverage({
                    objectDOM: t,
                    parentModel: model
                      }));
                });
              }

              if(geo.length){
                modelJSON.geoCoverage = [];
                _.each(geo, function(g){
                    modelJSON.geoCoverage.push(new EMLGeoCoverage({
                      objectDOM: g,
                      parentModel: model
                      }));
                });

              }

              if(taxon.length){
                modelJSON.taxonCoverage = [];
                _.each(taxon, function(t){
                    modelJSON.taxonCoverage.push(new EMLTaxonCoverage({
                      objectDOM: t,
                      parentModel: model
                        }));
                });

              }

            }
                //Parse EMLText modules
                else if(_.contains(emlText, thisNode.localName)){
                  if(typeof modelJSON[convertedName] == "undefined") modelJSON[convertedName] = [];

                  modelJSON[convertedName].push(new EMLText({
                      objectDOM: thisNode,
                      parentModel: model
                    }));

                }
          else if(_.contains(emlMethods, thisNode.localName)) {
            if(typeof modelJSON[thisNode.localName] === "undefined") modelJSON[thisNode.localName] = [];

            modelJSON[thisNode.localName] =  new EMLMethods({
              objectDOM: thisNode,
              parentModel: model
            });

          }
          //Parse keywords
          else if(thisNode.localName == "keywordset"){
            //Start an array of keyword sets
            if(typeof modelJSON["keywordSets"] == "undefined") modelJSON["keywordSets"] = [];

            modelJSON["keywordSets"].push(new EMLKeywordSet({
              objectDOM: thisNode,
              parentModel: model
            }));
          }
          //Parse intellectual rights
          else if(thisNode.localName == "intellectualrights"){
            var value = "";

            if($(thisNode).children("para").length == 1)
              value = $(thisNode).children("para").first().text().trim();
            else
              $(thisNode).text().trim();

            //If the value is one of our pre-defined options, then add it to the model
            //if(_.contains(this.get("intellRightsOptions"), value))
            modelJSON["intellectualRights"] = value;

          }
          //Parse Entities
          else if(_.contains(emlEntities, thisNode.localName)){

            //Start an array of Entities
            if(typeof modelJSON["entities"] == "undefined")
              modelJSON["entities"] = [];

            //Create the model
            var entityModel;
            if(thisNode.localName == "otherentity"){
              entityModel = new EMLOtherEntity({
                  objectDOM: thisNode,
                  parentModel: model
                }, {
                  parse: true
                });
                  } else if ( thisNode.localName == "datatable") {
                      entityModel = new EMLDataTable({
                          objectDOM: thisNode,
                          parentModel: model
                      }, {
                          parse: true
                      });
            } else {
              entityModel = new EMLOtherEntity({
                  objectDOM: thisNode,
                  parentModel: model,
                          entityType: "application/octet-stream"
                }, {
                  parse: true
                });
            }

            modelJSON["entities"].push(entityModel);
          }
          else if (thisNode.localName === "annotation") {
            if(typeof modelJSON["annotation"] == "undefined") {
              modelJSON["annotation"] = [];
            }

            var annotationModel = new EMLAnnotation({
              objectDOM: thisNode
            }, { parse: true });

            modelJSON["annotation"].push(annotationModel);
          }
          else{
            //Is this a multi-valued field in EML?
            if(Array.isArray(this.get(convertedName))){
              //If we already have a value for this field, then add this value to the array
              if(Array.isArray(modelJSON[convertedName]))
                modelJSON[convertedName].push(this.toJson(thisNode));
              //If it's the first value for this field, then create a new array
              else
                modelJSON[convertedName] = [this.toJson(thisNode)];
            }
            else
              modelJSON[convertedName] = this.toJson(thisNode);
          }

        }

        return modelJSON;
      },

      /*
       * Retireves the model attributes and serializes into EML XML, to produce the new or modified EML document.
       * Returns the EML XML as a string.
       */
      serialize: function(){
        //Get the EML document
        var xmlString   = this.get("objectXML"),
            html        = $.parseHTML(xmlString),
            eml         = $(html).filter("eml\\:eml"),
            datasetNode = $(eml).find("dataset");

        //Update the packageId on the eml node with the EML id
        $(eml).attr("packageId", this.get("id"));

        // Set id attribute on dataset node if needed
        if (this.get("xmlID")) {
          $(datasetNode).attr("id", this.get("xmlID"));
        }

        // Set schema version
        $(eml).attr("xmlns:eml",
          MetacatUI.appModel.get("editorSerializationFormat") ||
          "https://eml.ecoinformatics.org/eml-2.2.0");

        // Set formatID
        this.set("formatId",
          MetacatUI.appModel.get("editorSerializationFormat") ||
          "https://eml.ecoinformatics.org/eml-2.2.0");

        // Ensure xsi:schemaLocation has a value for the current format
        eml = this.setSchemaLocation(eml);

        var nodeNameMap = this.nodeNameMap();

        //Serialize the basic text fields
        var basicText = ["alternateIdentifier", "title"];
        _.each(basicText, function(fieldName){
        var basicTextValues = this.get(fieldName);

        if(!Array.isArray(basicTextValues))
          basicTextValues = [basicTextValues];

        // Remove existing nodes
        datasetNode.children(fieldName.toLowerCase()).remove();

        // Create new nodes
        var nodes = _.map(basicTextValues, function(value) {

          if(value){

            var node = document.createElement(fieldName.toLowerCase());
            $(node).text(value);
            return node;

          }
          else{
            return "";
          }
        });

        var insertAfter = this.getEMLPosition(eml, fieldName.toLowerCase());

        if(insertAfter){
          insertAfter.after(nodes);
        }
        else{
          datasetNode.prepend(nodes);
        }
      }, this);

      // Serialize pubDate
      // This one is special because it has a default behavior, unlike
      // the others: When no pubDate is set, it should be set to
      // the current year
      var pubDate = this.get('pubDate');

      datasetNode.find('pubdate').remove();

      if (pubDate != null &amp;&amp; pubDate.length > 0) {

        var pubDateEl = document.createElement('pubdate');

        $(pubDateEl).text(pubDate);

        this.getEMLPosition(eml, 'pubdate').after(pubDateEl);
      }

      // Serialize the parts of EML that are eml-text modules
      var textFields = ["abstract", "additionalInfo"];

      _.each(textFields, function(field){

        var fieldName = this.nodeNameMap()[field] || field;

        // Get the EMLText model
        var emlTextModels = Array.isArray(this.get(field)) ? this.get(field) : [this.get(field)];
        if( ! emlTextModels.length ) return;

        // Get the node from the EML doc
        var nodes = datasetNode.find(fieldName);

        // Update the DOMs for each model
        _.each(emlTextModels, function(thisTextModel, i){
          //Don't serialize falsey values
          if(!thisTextModel) return;

          var node;

          //Get the existing node or create a new one
          if(nodes.length &lt; i+1){
            node = document.createElement(fieldName);
            this.getEMLPosition(eml, fieldName).after(node);

          }
          else {
             node = nodes[i];
          }

          $(node).html( $(thisTextModel.updateDOM() ).html());

        }, this);

        // Remove the extra nodes
        this.removeExtraNodes(nodes, emlTextModels);

      }, this);

      //Create a &lt;coverage> XML node if there isn't one
      if( datasetNode.children('coverage').length === 0 ) {
        var coverageNode = $(document.createElement('coverage')),
            coveragePosition = this.getEMLPosition(eml, 'coverage');

        if(coveragePosition)
          coveragePosition.after(coverageNode);
        else
          datasetNode.append(coverageNode);
      }
      else{
        var coverageNode = datasetNode.children("coverage").first();
      }

      //Serialize the geographic coverage
      if ( typeof this.get('geoCoverage') !== 'undefined' &amp;&amp; this.get('geoCoverage').length > 0) {

        // Don't serialize if geoCoverage is invalid
        var validCoverages = _.filter(this.get('geoCoverage'), function(cov) {
          return cov.isValid();
        });

        //Get the existing geo coverage nodes from the EML
        var existingGeoCov = datasetNode.find("geographiccoverage");

        //Update the DOM of each model
        _.each(validCoverages, function(cov, position){

          //Update the existing node if it exists
          if(existingGeoCov.length-1 >= position){
            $(existingGeoCov[position]).replaceWith(cov.updateDOM());
          }
          //Or, append new nodes
          else{
            var insertAfter = existingGeoCov.length? datasetNode.find("geographiccoverage").last() : null;

            if(insertAfter)
              insertAfter.after(cov.updateDOM());
            else
              coverageNode.append(cov.updateDOM());
          }
        }, this);

        //Remove existing taxon coverage nodes that don't have an accompanying model
        this.removeExtraNodes(datasetNode.find("geographiccoverage"), validCoverages);
      }
      else{
        //If there are no geographic coverages, remove the nodes
        coverageNode.children("geographiccoverage").remove();
      }

      //Serialize the taxonomic coverage
      if ( typeof this.get('taxonCoverage') !== 'undefined' &amp;&amp; this.get('taxonCoverage').length > 0) {

        // Group the taxonomic coverage models into empty and non-empty
        var sortedTaxonModels = _.groupBy(this.get('taxonCoverage'), function(t) {
          if( _.flatten(t.get('taxonomicClassification')).length > 0 ){
            return "notEmpty";
          }
          else{
            return "empty";
          }
        });

        //Get the existing taxon coverage nodes from the EML
        var existingTaxonCov = coverageNode.children("taxonomiccoverage");

        //Iterate over each taxon coverage and update it's DOM
        if(sortedTaxonModels["notEmpty"] &amp;&amp; sortedTaxonModels["notEmpty"].length > 0) {

          //Update the DOM of each model
          _.each(sortedTaxonModels["notEmpty"], function(taxonCoverage, position){

            //Update the existing taxonCoverage node if it exists
            if(existingTaxonCov.length-1 >= position){
              $(existingTaxonCov[position]).replaceWith(taxonCoverage.updateDOM());
            }
            //Or, append new nodes
            else{
              coverageNode.append(taxonCoverage.updateDOM());
            }
          });

          //Remove existing taxon coverage nodes that don't have an accompanying model
          this.removeExtraNodes(existingTaxonCov, this.get("taxonCoverage"));

        }
        //If all the taxon coverages are empty, remove the parent taxonomicCoverage node
        else if( !sortedTaxonModels["notEmpty"] || sortedTaxonModels["notEmpty"].length == 0 ){
          existingTaxonCov.remove();
        }

      }

      //Serialize the temporal coverage
      var existingTemporalCoverages = datasetNode.find("temporalcoverage");

      //Update the DOM of each model
      _.each(this.get("temporalCoverage"), function(temporalCoverage, position){

        //Update the existing temporalCoverage node if it exists
        if(existingTemporalCoverages.length-1 >= position){
          $(existingTemporalCoverages[position]).replaceWith(temporalCoverage.updateDOM());
        }
        //Or, append new nodes
        else{
          coverageNode.append(temporalCoverage.updateDOM());
        }
      });

      //Remove existing taxon coverage nodes that don't have an accompanying model
      this.removeExtraNodes(existingTemporalCoverages, this.get("temporalCoverage"));

      //Remove the temporal coverage if it is empty
      if( !coverageNode.children("temporalcoverage").children().length ){
        coverageNode.children("temporalcoverage").remove();
      }

      //Remove the &lt;coverage> node if it's empty
      if(coverageNode.children().length == 0){
        coverageNode.remove();
      }

      // Dataset-level annotations
      datasetNode.children("annotation").remove();

      _.each(this.get("annotation"), function(annotation) {
        if (annotation.isEmpty()) {
          return;
        }

        var after = this.getEMLPosition(eml, "annotation");

        $(after).after(annotation.updateDOM());
      }, this);

      //If there is no creator, create one from the user
      if(!this.get("creator").length){
       var party = new EMLParty({ parentModel: this, type: "creator" });

       party.createFromUser();

       this.set("creator", [party]);
      }

      //Serialize the creators
      this.serializeParties(eml, "creator");

      //Serialize the metadata providers
      this.serializeParties(eml, "metadataProvider");

      //Serialize the associated parties
      this.serializeParties(eml, "associatedParty");

      //Serialize the contacts
      this.serializeParties(eml, "contact");

      //Serialize the publishers
      this.serializeParties(eml, "publisher");

      // Serialize methods
      if(this.get('methods')) {

        //If the methods model is empty, remove it from the EML
        if( this.get("methods").isEmpty() )
          datasetNode.find("methods").remove();
        else{

          //Serialize the methods model
          var methodsEl = this.get('methods').updateDOM();

          //If the methodsEl is an empty string or other falsey value, then remove the methods node
          if( !methodsEl || !$(methodsEl).children().length ){
            datasetNode.find("methods").remove();
          }
          else{

            //Add the &lt;methods> node to the EML
            datasetNode.find("methods").detach();

            var insertAfter = this.getEMLPosition(eml, "methods");

            if(insertAfter)
              insertAfter.after(methodsEl);
            else
              datasetNode.append(methodsEl);
          }
        }
      }
      //If there are no methods, then remove the methods nodes
      else{

        if( datasetNode.find("methods").length > 0 ){
          datasetNode.find("methods").remove();
        }

      }

      //Serialize the keywords
      this.serializeKeywords(eml, "keywordSets");

      //Serialize the intellectual rights
      if(this.get("intellectualRights")){
        if(datasetNode.find("intellectualRights").length)
          datasetNode.find("intellectualRights").html("&lt;para>" + this.get("intellectualRights") + "&lt;/para>")
        else{

          this.getEMLPosition(eml, "intellectualrights").after(
              $(document.createElement("intellectualRights"))
                .html("&lt;para>" + this.get("intellectualRights") + "&lt;/para>"));
        }
      }

      //Detach the project elements from the DOM
      if(datasetNode.find("project").length){

        datasetNode.find("project").detach();

      }

      //If there is an EMLProject, update its DOM
      if(this.get("project")){

        this.getEMLPosition(eml, "project").after(this.get("project").updateDOM());

      }

      //Get the existing taxon coverage nodes from the EML
      var existingEntities = datasetNode.find("otherEntity, dataTable");

      //Serialize the entities
      _.each(this.get("entities"), function(entity, position) {

        //Update the existing node if it exists
        if(existingEntities.length - 1 >= position) {
          //Remove the entity from the EML
          $(existingEntities[position]).detach();
          //Insert it into the correct position
          this.getEMLPosition(eml, entity.get("type").toLowerCase()).after(entity.updateDOM());        }
        //Or, append new nodes
        else {
          //Inser the entity into the correct position
          this.getEMLPosition(eml, entity.get("type").toLowerCase()).after(entity.updateDOM());
        }

      }, this);

      //Remove extra entities that have been removed
      var numExtraEntities = existingEntities.length - this.get("entities").length;
      for( var i = (existingEntities.length - numExtraEntities); i&lt;existingEntities.length; i++){
        $(existingEntities)[i].remove();
      }

      //Do a final check to make sure there are no duplicate ids in the EML
      var elementsWithIDs = $(eml).find("[id]"),
      //Get an array of all the ids in this EML doc
          allIDs = _.map(elementsWithIDs, function(el){ return $(el).attr("id") });

      //If there is at least one id in the EML...
      if(allIDs &amp;&amp; allIDs.length){
        //Boil the array down to just the unique values
        var uniqueIDs = _.uniq(allIDs);

        //If the unique array is shorter than the array of all ids,
        // then there is a duplicate somewhere
        if(uniqueIDs.length &lt; allIDs.length){

          //For each element in the EML that has an id,
          _.each(elementsWithIDs, function(el){

            //Get the id for this element
            var id = $(el).attr("id");

            //If there is more than one element in the EML with this id,
            if( $(eml).find("[id='" + id + "']").length > 1 ){
              //And if it is not a unit node, which we don't want to change,
              if( !$(el).is("unit") )
                //Then change the id attribute to a random uuid
                $(el).attr("id", "urn-uuid-" + uuid.v4());
            }

          });

        }
      }

      //Camel-case the XML
      var emlString = "";
      _.each(html, function(rootEMLNode){ emlString += this.formatXML(rootEMLNode); }, this);

      return emlString;
    },

    /*
     * Given an EML DOM and party type, this function updated and/or adds the EMLParties to the EML
     */
    serializeParties: function(eml, type){

      //Remove the nodes from the EML for this party type
      $(eml).children("dataset").children(type.toLowerCase()).remove();

      //Serialize each party of this type
       _.each(this.get(type), function(party, i){

         //Get the last node of this type to insert after
         var insertAfter = $(eml).children("dataset").children(type.toLowerCase()).last();

         //If there isn't a node found, find the EML position to insert after
         if( !insertAfter.length ) {
           insertAfter = this.getEMLPosition(eml, type);
         }

         //Update the DOM of the EMLParty
         var emlPartyDOM = party.updateDOM();

         //Make sure we don't insert empty EMLParty nodes into the EML
         if( $(emlPartyDOM).children().length ){
           //Insert the party DOM at the insert position
                if ( insertAfter &amp;&amp; insertAfter.length )
                  insertAfter.after(emlPartyDOM);
                //If an insert position still hasn't been found, then just append to the dataset node
                else
                  $(eml).find("dataset").append(emlPartyDOM);
            }

       }, this);

      //Create a certain parties from the current app user if none is given
      if(type == "contact" &amp;&amp; !this.get("contact").length){
        //Get the creators
        var creators = this.get("creator"),
          contacts = [];

        _.each(creators, function(creator){
          //Clone the creator model and add it to the contacts array
          var newModel = new EMLParty({ parentModel: this });
          newModel.set(creator.toJSON());
          newModel.set("type", type);

          contacts.push(newModel);
        }, this);

         this.set(type, contacts);

         //Call this function again to serialize the new models
         this.serializeParties(eml, type);
       }
     },


      serializeKeywords: function(eml) {
        // Remove all existing keywordSets before appending
        $(eml).find('dataset').find('keywordset').remove();

        if (this.get('keywordSets').length == 0) return;

        // Create the new keywordSets nodes
        var nodes = _.map(this.get('keywordSets'), function(kwd) {
          return kwd.updateDOM();
        });

            this.getEMLPosition(eml, "keywordset").after(nodes);
      },

      /*
       * Remoes nodes from the EML that do not have an accompanying model
       * (Were probably removed from the EML by the user during editing)
       */
      removeExtraNodes: function(nodes, models){
        // Remove the extra nodes
         var extraNodes =  nodes.length - models.length;
         if(extraNodes > 0){
           for(var i = models.length; i &lt; nodes.length; i++){
             $(nodes[i]).remove();
           }
         }
      },

      /*
       * Saves the EML document to the server using the DataONE API
       */
      save: function(attributes, options){

        //Validate before we try anything else
        if(!this.isValid()){
          this.trigger("invalid");
          this.trigger("cancelSave");
          return false;
        }
        else{
          this.trigger("valid");
        }

        this.setFileName();

        //Set the upload transfer as in progress
        this.set("uploadStatus", "p");

        //Reset the draftSaved attribute
        this.set("draftSaved", false);

        //Create the creator from the current user if none is provided
        if(!this.get("creator").length){
         var party = new EMLParty({ parentModel: this, type: "creator" });

         party.createFromUser();

         this.set("creator", [party]);
        }

        //Create the contact from the current user if none is provided
        if(!this.get("contact").length){
         var party = new EMLParty({ parentModel: this, type: "contact" });

         party.createFromUser();

         this.set("contact", [party]);
        }

        //If this is an existing object and there is no system metadata, retrieve it
        if(!this.isNew() &amp;&amp; !this.get("sysMetaXML")){
          var model = this;

          //When the system metadata is fetched, try saving again
          var fetchOptions = {
             success: function(response){
               model.set(DataONEObject.prototype.parse.call(model, response));
               model.save(attributes, options);
             }
          }

          //Fetch the system metadata now
          this.fetchSystemMetadata(fetchOptions);

          return;
        }

       //Create a FormData object to send data with our XHR
       var formData = new FormData();

       try{

         //Add the identifier to the XHR data
        if(this.isNew()){
          formData.append("pid", this.get("id"));
        }
        else{
          //Create a new ID
          this.updateID();

          //Add the ids to the form data
          formData.append("newPid", this.get("id"));
          formData.append("pid", this.get("oldPid"));
        }

        //Serialize the EML XML
        var xml = this.serialize();
        var xmlBlob = new Blob([xml], {type : 'application/xml'});

        //Get the size of the new EML XML
        this.set("size", xmlBlob.size);

        //Get the new checksum of the EML XML
        var checksum = md5(xml);
        this.set("checksum", checksum);
        this.set("checksumAlgorithm", "MD5");

        //Create the system metadata XML
        var sysMetaXML = this.serializeSysMeta();

        //Send the system metadata as a Blob
        var sysMetaXMLBlob = new Blob([sysMetaXML], {type : 'application/xml'});

        //Add the object XML and System Metadata XML to the form data
        //Append the system metadata first, so we can take advantage of Metacat's streaming multipart handler
        formData.append("sysmeta", sysMetaXMLBlob, "sysmeta");
        formData.append("object", xmlBlob);
      }
      catch(error){
         //Reset the identifier since we didn't actually update the object
         this.resetID();

         this.set("uploadStatus", "e");
         this.trigger("error");
         this.trigger("cancelSave");
         return false;
       }

       var model = this;
       var saveOptions = options || {};
       _.extend(saveOptions, {
         data : formData,
         cache: false,
         contentType: false,
         dataType: "text",
         processData: false,
         parse: false,
         //Use the URL function to determine the URL
         url: this.isNew() ? this.url() : this.url({update: true}),
         xhr: function(){
            var xhr = new window.XMLHttpRequest();

            //Upload progress
            xhr.upload.addEventListener("progress", function(evt){
              if (evt.lengthComputable) {
                var percentComplete = evt.loaded / evt.total * 100;

                model.set("uploadProgress", percentComplete);
              }
            }, false);

            return xhr;
        },
        success: function(model, response, xhr){

          model.set("numSaveAttempts", 0);
          model.set("uploadStatus", "c");
          model.set("sysMetaXML", model.serializeSysMeta());
          model.set("oldPid", null);
          model.fetch({merge: true, systemMetadataOnly: true});
          model.trigger("successSaving", model);

        },
        error: function(model, response, xhr){

          model.set("numSaveAttempts", model.get("numSaveAttempts") + 1);
          var numSaveAttempts = model.get("numSaveAttempts");

          //Reset the identifier changes
          model.resetID();

          if( numSaveAttempts &lt; 3 &amp;&amp; (response.status == 408 || response.status == 0) ){

            //Try saving again in 10, 40, and 90 seconds
            setTimeout(function(){
                        model.save.call(model);
                       },
                       (numSaveAttempts * numSaveAttempts) * 10000);
          }
          else{
            model.set("numSaveAttempts", 0);

            //Get the error error information
            var errorDOM       = $($.parseHTML(response.responseText)),
                errorContainer = errorDOM.filter("error"),
                msgContainer   = errorContainer.length? errorContainer.find("description") : errorDOM.not("style, title"),
                errorMsg       = msgContainer.length? msgContainer.text() : errorDOM;

            //When there is no network connection (status == 0), there will be no response text
            if(!errorMsg || (response.status == 408 || response.status == 0))
              errorMsg = "There was a network issue that prevented your metadata from uploading. " +
                     "Make sure you are connected to a reliable internet connection.";

            //Save the error message in the model
            model.set("errorMessage", errorMsg);

            //Set the model status as e for error
            model.set("uploadStatus", "e");

            //Save the EML as a plain text file, until drafts are a supported feature
            var copy = model.createTextCopy();

            //If the EML copy successfully saved, let the user know that there is a copy saved behind the scenes
            model.listenToOnce(copy, "successSaving", function(){

              model.set("draftSaved", true);

              //Trigger the errorSaving event so other parts of the app know that the model failed to save
              //And send the error message with it
              model.trigger("errorSaving", errorMsg);

            });

            //If the EML copy fails to save too, then just display the usual error message
            model.listenToOnce(copy, "errorSaving", function(){

              //Trigger the errorSaving event so other parts of the app know that the model failed to save
              //And send the error message with it
              model.trigger("errorSaving", errorMsg);

            });

            //Save the EML plain text copy
            copy.save();

            //Send this exception to Google Analytics
            if(MetacatUI.appModel.get("googleAnalyticsKey") &amp;&amp; (typeof ga !== "undefined")){
              ga('send', 'exception', {
                'exDescription': "EML save error: " + errorMsg + " | Id: " + model.get("id") +
                  " | v. " + MetacatUI.metacatUIVersion + " | EML draft: " + copy.get("id"),
                'exFatal': true
              });
            }
          }
        }
     }, MetacatUI.appUserModel.createAjaxSettings());

      return Backbone.Model.prototype.save.call(this, attributes, saveOptions);
    },


      /*
       * Checks if this EML model has all the required values necessary to save to the server
       */
      validate: function() {
        var errors = {};

        //A title is always required by EML
        if( !this.get("title").length || !this.get("title")[0] ){
          errors.title = "A title is required";
        }

        // Validate the publication date
        if (this.get("pubDate") != null) {
          if (!this.isValidYearDate(this.get("pubDate"))) {
            errors["pubDate"] = ["The value entered for publication date, '"
              + this.get("pubDate") +
              "' is not a valid value for this field. Enter with a year (e.g. 2017) or a date in the format YYYY-MM-DD."]
          }
        }

        // Validate the temporal coverage
        errors.temporalCoverage = [];

        //If temporal coverage is required and there aren't any, return an error
        if( MetacatUI.appModel.get("emlEditorRequiredFields").temporalCoverage &amp;&amp;
             !this.get("temporalCoverage").length ){
          errors.temporalCoverage = [{ beginDate:  "Provide a begin date." }];
        }
        //If temporal coverage is required and they are all empty, return an error
        else if( MetacatUI.appModel.get("emlEditorRequiredFields").temporalCoverage &amp;&amp;
                 _.every(this.get("temporalCoverage"), function(tc){
                   return tc.isEmpty();
                 }) ){
          errors.temporalCoverage = [{ beginDate:  "Provide a begin date." }];
        }
        //If temporal coverage is not required, validate each one
        else if( this.get("temporalCoverage").length ||
                  ( MetacatUI.appModel.get("emlEditorRequiredFields").temporalCoverage &amp;&amp;
                           _.every(this.get("temporalCoverage"), function(tc){
                             return tc.isEmpty();
                           }) )) {
          //Iterate over each temporal coverage and add it's validation errors
          _.each(this.get("temporalCoverage"), function(temporalCoverage){
            if( !temporalCoverage.isValid() &amp;&amp; !temporalCoverage.isEmpty() ){
              errors.temporalCoverage.push(temporalCoverage.validationError);
            }
          });
        }

        //Remove the temporalCoverage attribute if no errors were found
        if( errors.temporalCoverage.length == 0 ){
          delete errors.temporalCoverage;
        }

        //Validate the EMLParty models
        var partyTypes = ["associatedParty", "contact", "creator", "metadataProvider", "publisher"];
        _.each(partyTypes, function(type){

          var people = this.get(type);
          _.each(people, function(person, i){

            if( !person.isValid() ){
              if( !errors[type] )
                errors[type] = [person.validationError];
              else
                errors[type].push(person.validationError);
            }

          }, this);

        }, this);

        //Validate the EMLGeoCoverage models
        _.each(this.get("geoCoverage"), function(geoCoverageModel, i){

          if( !geoCoverageModel.isValid() ){
            if( !errors.geoCoverage )
              errors.geoCoverage = [geoCoverageModel.validationError];
            else
              errors.geoCoverage.push(geoCoverageModel.validationError);
          }

        }, this);

        //Validate the EMLTaxonCoverage model
        var taxonModel = this.get("taxonCoverage")[0];

        if( !taxonModel.isEmpty() &amp;&amp; !taxonModel.isValid() ){
          errors = _.extend(errors, taxonModel.validationError);
        }
        else if( taxonModel.isEmpty() &amp;&amp;
          this.get("taxonCoverage").length == 1 &amp;&amp;
          MetacatUI.appModel.get("emlEditorRequiredFields").taxonCoverage ){

          taxonModel.isValid();
          errors = _.extend(errors, taxonModel.validationError);

        }

        //Validate each EMLEntity model
        _.each( this.get("entities"), function(entityModel){

          if( !entityModel.isValid() ){
            if( !errors.entities )
              errors.entities = [entityModel.validationError];
            else
              errors.entities.push(entityModel.validationError);
          }

        });

        // Validate each EMLAnnotation model
        _.each(this.get("annotation"), function (model) {
          if (model.isValid()) {
            return;
          }

          if (!errors.annotations) {
            errors.annotations = [];
          }

          errors.annotations.push(model.validationError);
        });

        //Check the required fields for this MetacatUI configuration
        if(MetacatUI.appModel.get("emlEditorRequiredFields")){
            _.each(Object.keys(MetacatUI.appModel.get("emlEditorRequiredFields")), function(key){
              var isRequired = MetacatUI.appModel.get("emlEditorRequiredFields")[key];

              //If it's not required, then exit
              if(!isRequired) return;

              if(key == "alternateIdentifier"){
                if( !this.get("alternateIdentifier").length || _.every(this.get("alternateIdentifier"), function(altId){ return altId.trim() == "" }) )
                  errors.alternateIdentifier = "At least one alternate identifier is required."
              }
              else if(key == "generalTaxonomicCoverage"){
                if( !this.get("taxonCoverage").length || !this.get("taxonCoverage")[0].get("generalTaxonomicCoverage") )
                  errors.generalTaxonomicCoverage = "Provide a description of the general taxonomic coverage of this data set.";
              }
              else if(key == "geoCoverage"){
                if(!this.get("geoCoverage").length)
                  errors.geoCoverage = "At least one location is required.";
              }
              else if(key == "intellectualRights"){
                if( !this.get("intellectualRights") )
                  errors.intellectualRights = "Select usage rights for this data set.";
              }
              else if(key == "studyExtentDescription"){
                if( !this.get("methods") || !this.get("methods").get("studyExtentDescription") )
                  errors.studyExtentDescription = "Provide a study extent description.";
              }
              else if(key == "samplingDescription"){
                if( !this.get("methods") || !this.get("methods").get("samplingDescription") )
                  errors.samplingDescription = "Provide a sampling description.";
              }
              else if(key == "temporalCoverage"){
                if(!this.get("temporalCoverage").length)
                  errors.temporalCoverage = "Provide the date(s) for this data set.";
              }
              else if(key == "taxonCoverage"){
                if(!this.get("taxonCoverage").length)
                  errors.taxonCoverage = "At least one taxa rank and value is required.";
              }
              else if(key == "keywordSets"){
                if( !this.get("keywordSets").length )
                  errors.keywordSets = "Provide at least one keyword.";
              }
              else if(key == "methods"){
                if(!this.get("methods"))
                  errors.methods = "At least one method step is required.";
              }
              else if(key == "funding"){
                // Note: Checks for either the funding or award element. award
                // element is checked by the project's objectDOM for now until
                // EMLProject fully supports the award element
                if(!this.get("project") ||
                   !(this.get("project").get("funding").length ||
                     (this.get("project").get("objectDOM") &amp;&amp;
                      this.get("project").get("objectDOM").querySelectorAll &amp;&amp;
                      this.get("project").get("objectDOM").querySelectorAll("award").length > 0)))
                  errors.funding = "Provide at least one project funding number or name.";
              }
              else if(key == "abstract"){
                if(!this.get("abstract").length)
                  errors["abstract"] = "Provide an abstract.";
              }
              else if( !this.get(key) || (Array.isArray(this.get(key)) &amp;&amp; !this.get(key).length) ){
                errors[key] = "Provide a " + key + ".";
              }
            }, this);

        }

        if( Object.keys(errors).length )
          return errors;
        else{
          return;
        }
      },

      /* Returns a boolean for whether the argument 'value' is a valid
      value for EML's yearDate type which is used in a few places.

      Note that this method considers a zero-length String to be valid
      because the EML211.serialize() method will properly handle a null
      or zero-length String by serializing out the current year. */
      isValidYearDate: function(value) {
        return (value === "" || /^\d{4}$/.test(value) || /^\d{4}-\d{2}-\d{2}$/.test(value));
      },

      /*
       * Sends an AJAX request to fetch the system metadata for this EML object.
       * Will not trigger a sync event since it does not use Backbone.Model.fetch
       */
      fetchSystemMetadata: function(options){

        if(!options) var options = {};
        else options = _.clone(options);

        var model = this,
          fetchOptions = _.extend({
            url: MetacatUI.appModel.get("metaServiceUrl") + encodeURIComponent(this.get("id")),
            dataType: "text",
            success: function(response){
              model.set(DataONEObject.prototype.parse.call(model, response));

              //Trigger a custom event that the sys meta was updated
              model.trigger("sysMetaUpdated");
            },
            error: function(){
              model.trigger('error');
            }
          }, options);

          //Add the authorization header and other AJAX settings
          _.extend(fetchOptions, MetacatUI.appUserModel.createAjaxSettings());

          $.ajax(fetchOptions);
      },
      /*
       * Returns the nofde in the given EML document that the given node type
       * should be inserted after
       *
       * Returns false if either the node is not found in the and this should
       * be handled by the caller.
       */
      getEMLPosition: function(eml, nodeName) {
        var nodeOrder = this.get("nodeOrder");
        var position = _.indexOf(nodeOrder, nodeName.toLowerCase());

        if (position == -1) {
          return false;
        }

        // Go through each node in the node list and find the position where this
        // node will be inserted after
        for (var i = position - 1; i >= 0; i--) {
          if ($(eml).find("dataset").find(nodeOrder[i]).length) {
            return $(eml).find("dataset").children(nodeOrder[i]).last();
          }
        }

        return false;
      },

      /*
       * Checks if this model has updates that need to be synced with the server.
       */
      hasUpdates: function(){
        if(this.constructor.__super__.hasUpdates.call(this)) return true;

        //If nothing else has been changed, then this object hasn't had any updates
        return false;
      },

      /*
       Add an entity into the EML 2.1.1 object
      */
      addEntity: function(emlEntity, position) {
        //Get the current list of entities
        var currentEntities = this.get("entities");

        if( typeof position == "undefined" || position == -1)
          currentEntities.push(emlEntity);
        else
          //Add the entity model to the entity array
          currentEntities.splice(position, 0, emlEntity);

        this.trigger("change:entities");

        this.trickleUpChange();

        return this;
      },

      /*
       Remove an entity from the EML 2.1.1 object
      */
      removeEntity: function(emlEntity) {
          if(!emlEntity || typeof emlEntity != "object")
            return;

        //Get the current list of entities
        var entities = this.get("entities");

        entities = _.without(entities, emlEntity);

        this.set("entities", entities);
      },

      /*
       * Find the entity model for a given DataONEObject
       */
      getEntity: function(dataONEObj){

        //If an EMLEntity model has been found for this object before, then return it
        if( dataONEObj.get("metadataEntity") ){
          dataONEObj.get("metadataEntity").set("dataONEObject", dataONEObj);
          return dataONEObj.get("metadataEntity");
        }

        var entity = _.find(this.get("entities"), function(e){

          //Matches of the checksum or identifier are definite matches
          if( e.get("xmlID") == dataONEObj.getXMLSafeID() )
            return true;
          else if( e.get("physicalMD5Checksum") &amp;&amp; (e.get("physicalMD5Checksum") == dataONEObj.get("checksum") &amp;&amp; dataONEObj.get("checksumAlgorithm").toUpperCase() == "MD5"))
            return true;
          else if(e.get("downloadID") &amp;&amp; e.get("downloadID") == dataONEObj.get("id"))
            return true;

          // Get the file name from the EML for this entity
          var fileNameFromEML = e.get("physicalObjectName") || e.get("entityName");

          // If the EML file name matches the DataONEObject file name
          if (fileNameFromEML &amp;&amp;
              dataONEObj.get("fileName") &amp;&amp;
              ((fileNameFromEML.toLowerCase() == dataONEObj.get("fileName").toLowerCase()) ||
                (fileNameFromEML.replace(/ /g, "_").toLowerCase() == dataONEObj.get("fileName").toLowerCase()))) {

            //Get an array of all the other entities in this EML
            var otherEntities = _.without(this.get("entities"), e);

              // If this entity name matches the dataone object file name, AND no other dataone object file name
              // matches, then we can assume this is the entity element for this file.
            var otherMatchingEntity = _.find(otherEntities, function(otherE){

              // Get the file name from the EML for the other entities
              var otherFileNameFromEML = otherE.get("physicalObjectName") || otherE.get("entityName");

              // If the file names match, return true
              if( (otherFileNameFromEML == dataONEObj.get("fileName")) || (otherFileNameFromEML.replace(/ /g, "_") == dataONEObj.get("fileName")) )
                return true;
            });

            // If this entity's file name didn't match any other file names in the EML,
            // then this entity is a match for the given dataONEObject
            if( !otherMatchingEntity )
              return true;
          }

        }, this);

        //If we found an entity, give it an ID and return it
        if(entity){

          //If this entity has been matched to another DataONEObject already, then don't match it again
          if( entity.get("dataONEObject") == dataONEObj ){
            return entity;
          }
          //If this entity has been matched to a different DataONEObject already, then don't match it again.
          //i.e. We will not override existing entity&lt;->DataONEObject pairings
          else if( entity.get("dataONEObject") ){
            return;
          }
          else{
            entity.set("dataONEObject", dataONEObj);
          }

            //Create an XML-safe ID and set it on the Entity model
            var entityID = this.getUniqueEntityId(dataONEObj);
            entity.set("xmlID", entityID);

            //Save a reference to this entity so we don't have to refind it later
            dataONEObj.set("metadataEntity", entity);

          return entity;
        }

        //See if one data object is of this type in the package
        var matchingTypes = _.filter(this.get("entities"), function(e){
          return (e.get("formatName") == (dataONEObj.get("formatId") || dataONEObj.get("mediaType")));
        });

        if(matchingTypes.length == 1){
            //Create an XML-safe ID and set it on the Entity model
          matchingTypes[0].set("xmlID", dataONEObj.getXMLSafeID());

          return matchingTypes[0];
        }

        //If this EML is in a DataPackage with only one other DataONEObject,
        // and there is only one entity in the EML, then we can assume they are the same entity
        if( this.get("entities").length == 1 ){

          if( this.get("collections")[0] &amp;&amp; this.get("collections")[0].type == "DataPackage" &amp;&amp;
              this.get("collections")[0].length == 2 &amp;&amp; _.contains(this.get("collections")[0].models, dataONEObj)){
                return this.get("entities")[0];
          }

        }

        return false;

      },

      createEntity: function(dataONEObject){
        // Add or append an entity to the parent's entity list
          var entityModel = new EMLOtherEntity({
              entityName : dataONEObject.get("fileName"),
              entityType : dataONEObject.get("formatId") ||
                           dataONEObject.get("mediaType") ||
                           "application/octet-stream",
              dataONEObject: dataONEObject,
              parentModel: this,
              xmlID: dataONEObject.getXMLSafeID()
          });

          this.addEntity(entityModel);

          //If this DataONEObject fails to upload, remove the EML entity
          this.listenTo(dataONEObject, "errorSaving", function(){
            this.removeEntity(dataONEObject.get("metadataEntity"));

            //Listen for a successful save so the entity can be added back
            this.listenToOnce(dataONEObject, "successSaving", function(){
              this.addEntity(dataONEObject.get("metadataEntity"))
            });
          });

      },

      /*
      * Creates an XML-safe identifier that is unique to this EML document,
      * based on the given DataONEObject model. It is intended for EML entity nodes in particular.
      *
      * @param {DataONEObject} - a DataONEObject model that this EML documents
      * @return {string} - an identifier string unique to this EML document
      */
      getUniqueEntityId: function(dataONEObject){

        var uniqueId = "";

        uniqueId = dataONEObject.getXMLSafeID();

        //Get the EML string, if there is one, to check if this id already exists
        var emlString = this.get("objectXML");

        //If this id already exists in the EML...
        if(emlString &amp;&amp; emlString.indexOf(' id="' + uniqueId + '"')){
          //Create a random uuid to use instead
          uniqueId = "urn-uuid-" + uuid.v4();
        }

        return uniqueId;

      },

      /*
       * removeParty - removes the given EMLParty model from this EML211 model's attributes
       */
      removeParty: function(partyModel){
        //The list of attributes this EMLParty might be stored in
        var possibleAttr = ["creator", "contact", "metadataProvider", "publisher", "associatedParty"];

        // Iterate over each possible attribute
        _.each(possibleAttr, function(attr){

          if( _.contains(this.get(attr), partyModel) ){
            this.set( attr, _.without(this.get(attr), partyModel) );
          }

        }, this);
      },

      /**
       * Attempt to move a party one index forward within its sibling models
       *
       * @param {EMLParty} partyModel: The EMLParty model we're moving
       */
      movePartyUp: function(partyModel) {
        var possibleAttr = ["creator", "contact", "metadataProvider", "publisher", "associatedParty"];

        // Iterate over each possible attribute
        _.each(possibleAttr, function(attr){
          if (!_.contains(this.get(attr), partyModel)) {
            return;
          }
          // Make a clone because we're going to use splice
          var models = _.clone(this.get(attr));

          // Find the index of the model we're moving
          var index = _.findIndex(models, function(m) {
            return m === partyModel;
          });

          if (index === 0) {
            // Already first
            return;
          }

          if (index === -1) {
            // Couldn't find the model
            return;
          }

          // Do the move using splice and update the model
          models.splice(index - 1, 0, models.splice(index, 1)[0])
          this.set(attr, models);
          this.trigger("change:" + attr);
        }, this);
      },

      /**
       * Attempt to move a party one index forward within its sibling models
       *
       * @param {EMLParty} partyModel: The EMLParty model we're moving
       */
      movePartyDown: function(partyModel) {
        var possibleAttr = ["creator", "contact", "metadataProvider", "publisher", "associatedParty"];

        // Iterate over each possible attribute
        _.each(possibleAttr, function(attr){
          if (!_.contains(this.get(attr), partyModel)) {
            return;
          }
          // Make a clone because we're going to use splice
          var models = _.clone(this.get(attr));

          // Find the index of the model we're moving
          var index = _.findIndex(models, function(m) {
            return m === partyModel;
          });

          if (index === -1) {
            // Couldn't find the model
            return;
          }

          // Figure out where to put the new model
          //   Leave it in the same place if the next index doesn't exist
          //   Move one forward if it does
          var newIndex = (models.length &lt;= index + 1) ? index : index + 1;

          // Do the move using splice and update the model
          models.splice(newIndex, 0, models.splice(index, 1)[0])
          this.set(attr, models);
          this.trigger("change:" + attr);
        }, this);
      },

      /*
      * Adds the given EMLParty model to this EML211 model in the
      * appropriate role array in the given position
      *
      * @param {EMLParty} - The EMLParty model to add
      * @param {number} - The position in the role array in which to insert this EMLParty
      * @return {boolean} - Returns true if the EMLParty was successfully added, false if it was cancelled
      */
      addParty: function(partyModel, position){

        //If the EMLParty model is empty, don't add it to the EML211 model
        if(partyModel.isEmpty())
          return false;

        //Get the role of this EMLParty
        var role = partyModel.get("type") || "associatedParty";

        //If this model already contains this EMLParty, then exit
        if( _.contains(this.get(role), partyModel) )
          return false;

        if( typeof position == "undefined" ){
          this.get(role).push(partyModel);
        }
        else {
          this.get(role).splice(position, 0, partyModel);
        }

        this.trigger("change:" + role);

        return true;
      },

      /**
       * getPartiesByType - Gets an array of EMLParty members that have a particular party type or role.
       * @param {string} partyType - A string that represents either the role or the party type. For example, "contact", "creator", "principalInvestigator", etc.
       * @since 2.15.0
       */
      getPartiesByType: function(partyType){

        try {
          if(!partyType){
            return false
          }
          var associatedPartyTypes = new EMLParty().get("roleOptions"),
              isAssociatedParty = associatedPartyTypes.includes(partyType),
              parties = [];
          // For "contact", "creator", "metadataProvider", "publisher", each party type has it's own
          // array in the EML model
          if(!isAssociatedParty){
            parties = this.get(partyType);
          // For "custodianSteward", "principalInvestigator", "collaboratingPrincipalInvestigator", etc.,
          // party members are listed in the EML model's associated parties array. Each associated party's
          // party type is indicated in the role attribute.
          } else {
            parties = _.filter(this.get("associatedParty"), function (associatedParty) {
              return associatedParty.get("roles").includes(partyType) }
            );
          }

          return parties;

        } catch (error) {
          console.log("Error trying to find a list of party members in an EML model by type. Error details: " + error);
        }
      },

      createUnits: function(){
        this.units.fetch();
      },

      /* Initialize the object XML for brand spankin' new EML objects */
      createXML: function() {
          var xml = "&lt;eml:eml xmlns:eml=\"https://eml.ecoinformatics.org/eml-2.2.0\">&lt;/eml:eml>",
              eml = $($.parseHTML(xml));

              // Set base attributes
              eml.attr("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
              eml.attr("xmlns:stmml", "http://www.xml-cml.org/schema/stmml-1.1");
              eml.attr("xsi:schemaLocation", "https://eml.ecoinformatics.org/eml-2.2.0 https://eml.ecoinformatics.org/eml-2.2.0/eml.xsd");
              eml.attr("packageId", this.get("id"));
              eml.attr("system", "knb"); // We could make this configurable at some point

              // Add the dataset
              eml.append(document.createElement("dataset"));
              eml.find("dataset").append(document.createElement("title"));

              emlString = $(document.createElement("div")).append(eml.clone()).html();

              return emlString;
      },

      /*
          Replace elements named "source" with "sourced" due to limitations
          with using $.parseHTML() rather than $.parseXML()

          @param xmlString  The XML string to make the replacement in
      */
      cleanUpXML: function(xmlString){
        xmlString.replace("&lt;source>", "&lt;sourced>");
        xmlString.replace("&lt;/source>", "&lt;/sourced>");

        return xmlString;
      },

      createTextCopy: function(){
        var emlDraftText = "EML draft for " + this.get("id") + "(" + this.get("title") + ") by " +
              MetacatUI.appUserModel.get("firstName") + " " + MetacatUI.appUserModel.get("lastName");

        if(this.get("uploadStatus") == "e" &amp;&amp; this.get("errorMessage")){
          emlDraftText += ". This EML had the following save error: `" + this.get("errorMessage") + "`   ";
        }
        else {
          emlDraftText += ":   ";
        }

        emlDraftText += this.serialize();

        var plainTextEML = new DataONEObject({
              formatId: "text/plain",
              fileName: "eml_draft_" + (MetacatUI.appUserModel.get("lastName") || "") + ".txt",
              uploadFile: new Blob([emlDraftText], {type : 'plain/text'}),
              synced: true
            });

        return plainTextEML;
      },

      /*
      * Cleans up the given text so that it is XML-valid by escaping reserved characters, trimming white space, etc.
      *
      * @param {string} textString - The string to clean up
      * @return {string} - The cleaned up string
      */
      cleanXMLText: function(textString){

        if( typeof textString != "string" )
          return;

        textString = textString.trim();

        //Check for XML/HTML elements
        _.each(textString.match(/&lt;\s*[^>]*>/g), function(xmlNode){

          //Encode &lt;, >, and &lt;/ substrings
          var tagName = xmlNode.replace(/>/g, "&amp;gt;");
          tagName = tagName.replace(/&lt;/g, "&amp;lt;");

          //Replace the xmlNode in the full text string
          textString = textString.replace(xmlNode, tagName);

        });

        //Remove Unicode characters that are not valid XML characters
        //Create a regular expression that matches any character that is not a valid XML character
        // (see https://www.w3.org/TR/xml/#charsets)
        var invalidCharsRegEx = /[^\u0009\u000a\u000d\u0020-\uD7FF\uE000-\uFFFD]/g;
        textString = textString.replace(invalidCharsRegEx, "");

        return textString;

      },

      /*
          Dereference "reference" elements and replace them with a cloned copy
          of the referenced content

          @param xmlString  The XML string with reference elements to transform
      */
      dereference: function(xmlString) {
          var referencesList; // the array of references elements in the document
          var referencedID;  // The id of the referenced element
          var referencesParentEl;  // The parent of the given references element
          var referencedEl; // The referenced DOM to be copied

          xmlDOM = $.parseXML(xmlString);
          referencesList = xmlDOM.getElementsByTagName("references");

          if (referencesList.length) {
              // Process each references elements
              _.each(referencesList, function(referencesEl, index, referencesList) {
                  // Can't rely on the passed referencesEl since the list length changes
                  // because of the remove() below. Reuse referencesList[0] for every item:
                  // referencedID = $(referencesEl).text(); // doesn't work
                  referencesEl = referencesList[0];
                  referencedID = $(referencesEl).text();
                  referencesParentEl = ($(referencesEl).parent())[0];
                  if (typeof referencedID !== "undefined" &amp;&amp; referencedID != "") {
                      referencedEl = xmlDOM.getElementById(referencedID);
                      if (typeof referencedEl != "undefined") {
                          // Clone the referenced element and replace the references element
                          var referencedClone = ($(referencedEl).clone())[0];
                          $(referencesParentEl)
                              .children(referencesEl.localName)
                              .replaceWith($(referencedClone).children());
                          //$(referencesParentEl).append($(referencedClone).children());
                          $(referencesParentEl).attr("id", DataONEObject.generateId());
                      }
                  }
              }, xmlDOM);
          }
          return (new XMLSerializer()).serializeToString(xmlDOM);
      },

      /*
      * Uses the EML `title` to set the `fileName` attribute on this model.
      */
      setFileName: function(){

        var title = "";

        // Get the title from the metadata
        if( Array.isArray(this.get("title")) ){
          title = this.get("title")[0];
        }
        else if( typeof this.get("title") == "string" ){
          title = this.get("title");
        }

        //Max title length
        var maxLength = 50;

        //trim the string to the maximum length
        var trimmedTitle = title.trim().substr(0, maxLength);

        //re-trim if we are in the middle of a word
        if( trimmedTitle.indexOf(" ") > -1 ){
          trimmedTitle = trimmedTitle.substr(0, Math.min(trimmedTitle.length, trimmedTitle.lastIndexOf(" ")));
        }

        //Replace all non alphanumeric characters with underscores
        // and make sure there isn't more than one underscore in a row
        trimmedTitle = trimmedTitle.replace(/[^a-zA-Z0-9]/g, "_").replace(/_{2,}/g, "_");

        //Set the fileName on the model
        this.set("fileName", trimmedTitle + ".xml");
      },

      trickleUpChange: function(){
        if( !MetacatUI.rootDataPackage || !MetacatUI.rootDataPackage.packageModel )
          return;

        //Mark the package as changed
        MetacatUI.rootDataPackage.packageModel.set("changed", true);
      },

      /**
       * Sets the xsi:schemaLocation attribute on the passed-in Element
       * depending on the application configuration.
       *
       * @param {Element} eml: The root eml:eml element to modify
       * @return {Element} The element, possibly modified
       */
      setSchemaLocation: function(eml) {
        if (!MetacatUI || !MetacatUI.appModel) {
          return eml;
        }

        var current = $(eml).attr("xsi:schemaLocation"),
            format = MetacatUI.appModel.get("editorSerializationFormat"),
            location = MetacatUI.appModel.get("editorSchemaLocation");

        // Return now if we can't do anything anyway
        if (!format || !location) {
          return eml;
        }

        // Simply add if the attribute isn't present to begin with
        if (!current || typeof current !== "string") {
          $(eml).attr("xsi:schemaLocation", format + " " + location);

          return eml;
        }

        // Don't append if it's already present
        if (current.indexOf(format) >= 0) {
          return eml;
        }

        $(eml).attr("xsi:schemaLocation", current + " " + location);

        return eml;
      },

      createID: function() {
        this.set("xmlID", uuid.v4());
      }
    });

    return EML211;
  }
);
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
