<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>MetacatUI Dev Docs: Source: src/js/models/metadata/eml211/EML211.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="/metacatui/assets/css/styles.css">
    <link type="text/css" rel="stylesheet" href="styles/style.css">
</head>

<body>

<nav id="nav">
    <a href="/">
      <div class="logo">
<svg class="cat" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="cat" class="svg-inline--fa fa-cat fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M290.59 192c-20.18 0-106.82 1.98-162.59 85.95V192c0-52.94-43.06-96-96-96-17.67 0-32 14.33-32 32s14.33 32 32 32c17.64 0 32 14.36 32 32v256c0 35.3 28.7 64 64 64h176c8.84 0 16-7.16 16-16v-16c0-17.67-14.33-32-32-32h-32l128-96v144c0 8.84 7.16 16 16 16h32c8.84 0 16-7.16 16-16V289.86c-10.29 2.67-20.89 4.54-32 4.54-61.81 0-113.52-44.05-125.41-102.4zM448 96h-64l-64-64v134.4c0 53.02 42.98 96 96 96s96-42.98 96-96V32l-64 64zm-72 80c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16zm80 0c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16z"></path></svg>

<svg width="459px" height="53px" viewBox="0 0 459 53" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="metacatui" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M16.492,52 C17.212,52 17.812,51.748 18.292,51.244 C18.772,50.74 19.012,50.128 19.012,49.408 L19.012,49.408 L18.94,22.912 L30.82,37.816 C31.204,38.344 31.72,38.764 32.368,39.076 C33.016,39.388 33.7,39.544 34.42,39.544 C35.908,39.544 37.132,38.896 38.092,37.6 L38.092,37.6 L49.684,22.912 L49.684,49.408 C49.684,50.128 49.96,50.74 50.512,51.244 C51.064,51.748 51.7,52 52.42,52 L52.42,52 L62.068,52 C62.788,52 63.388,51.748 63.868,51.244 C64.348,50.74 64.588,50.128 64.588,49.408 L64.588,49.408 L64.588,4.12 C64.588,3.448 64.336,2.86 63.832,2.356 C63.328,1.852 62.74,1.6 62.068,1.6 L62.068,1.6 L52.348,1.6 C51.388,1.6 50.56,1.648 49.864,1.744 C49.168,1.84 48.532,2.152 47.956,2.68 L47.956,2.68 L33.916,17.296 L20.524,2.608 C20.332,2.368 19.972,2.14 19.444,1.924 C18.916,1.708 18.412,1.6 17.932,1.6 L17.932,1.6 L6.772,1.6 C6.052,1.6 5.44,1.852 4.936,2.356 C4.432,2.86 4.18,3.448 4.18,4.12 L4.18,4.12 L4.18,49.408 C4.18,50.08 4.432,50.68 4.936,51.208 C5.44,51.736 6.052,52 6.772,52 L6.772,52 L16.492,52 Z M110.74,52 C111.556,52 112.264,51.676 112.864,51.028 C113.464,50.38 113.764,49.624 113.764,48.76 L113.764,48.76 L113.764,42.568 C113.764,41.608 113.464,40.828 112.864,40.228 C112.264,39.628 111.556,39.328 110.74,39.328 L110.74,39.328 L89.428,39.328 L89.428,32.92 L109.732,32.92 C110.5,32.92 111.184,32.596 111.784,31.948 C112.384,31.3 112.684,30.568 112.684,29.752 L112.684,29.752 L112.684,23.488 C112.684,22.576 112.384,21.82 111.784,21.22 C111.184,20.62 110.5,20.32 109.732,20.32 L109.732,20.32 L89.428,20.32 L89.428,14.488 L110.74,14.488 C111.508,14.488 112.204,14.164 112.828,13.516 C113.452,12.868 113.764,12.136 113.764,11.32 L113.764,11.32 L113.764,5.056 C113.764,4.144 113.464,3.388 112.864,2.788 C112.264,2.188 111.556,1.888 110.74,1.888 L110.74,1.888 L76.756,1.888 C75.94,1.888 75.232,2.188 74.632,2.788 C74.032,3.388 73.732,4.144 73.732,5.056 L73.732,5.056 L73.732,48.76 C73.732,49.624 74.032,50.38 74.632,51.028 C75.232,51.676 75.94,52 76.756,52 L76.756,52 L110.74,52 Z M147.604,52 C148.42,52 149.104,51.688 149.656,51.064 C150.208,50.44 150.484,49.672 150.484,48.76 L150.484,48.76 L150.484,16.216 L161.86,16.216 C162.676,16.216 163.396,15.904 164.02,15.28 C164.644,14.656 164.956,13.936 164.956,13.12 L164.956,13.12 L164.956,4.768 C164.956,4 164.644,3.316 164.02,2.716 C163.396,2.116 162.676,1.816 161.86,1.816 L161.86,1.816 L124.132,1.816 C123.22,1.816 122.464,2.104 121.864,2.68 C121.264,3.256 120.964,3.952 120.964,4.768 L120.964,4.768 L120.964,13.12 C120.964,13.936 121.264,14.656 121.864,15.28 C122.464,15.904 123.22,16.216 124.132,16.216 L124.132,16.216 L135.652,16.216 L135.148,48.832 C135.148,49.744 135.424,50.5 135.976,51.1 C136.528,51.7 137.212,52 138.028,52 L138.028,52 L147.604,52 Z M175.828,52 C176.836,52 177.676,51.82 178.348,51.46 C179.02,51.1 179.452,50.584 179.644,49.912 L179.644,49.912 L181.876,42.712 L197.932,42.712 L200.164,49.912 C200.356,50.584 200.8,51.1 201.496,51.46 C202.192,51.82 203.044,52 204.052,52 L204.052,52 L213.916,52 C215.836,51.712 216.796,50.704 216.796,48.976 C216.796,48.304 216.676,47.596 216.436,46.852 C216.196,46.108 216.052,45.616 216.004,45.376 L216.004,45.376 L199.876,4.84 C199.588,3.976 199.036,3.232 198.22,2.608 C197.404,1.984 196.372,1.648 195.124,1.6 L195.124,1.6 L184.756,1.6 C183.604,1.648 182.608,1.948 181.768,2.5 C180.928,3.052 180.292,3.832 179.86,4.84 L179.86,4.84 L163.876,45.376 C163.828,45.472 163.672,45.916 163.408,46.708 C163.144,47.5 163.012,48.304 163.012,49.12 C163.012,50.752 163.948,51.712 165.82,52 L165.82,52 L175.828,52 Z M195.34,30.544 L184.036,30.544 L189.652,13.624 L195.34,30.544 Z M245.38,53.08 C250.612,53.08 255.652,51.544 260.5,48.472 C261.22,47.944 261.58,47.296 261.58,46.528 C261.58,45.808 261.292,45.16 260.716,44.584 L260.716,44.584 L252.796,36.808 C252.364,36.376 251.836,36.16 251.212,36.16 C250.78,36.16 250.372,36.256 249.988,36.448 C248.356,37.12 246.796,37.456 245.308,37.456 C243.244,37.456 241.348,36.952 239.62,35.944 C237.892,34.936 236.512,33.58 235.48,31.876 C234.448,30.172 233.932,28.336 233.932,26.368 C233.932,24.352 234.436,22.504 235.444,20.824 C236.452,19.144 237.832,17.812 239.584,16.828 C241.336,15.844 243.244,15.352 245.308,15.352 C246.892,15.352 248.332,15.64 249.628,16.216 C250.012,16.408 250.444,16.504 250.924,16.504 C251.548,16.504 252.1,16.264 252.58,15.784 L252.58,15.784 L259.636,8.008 C260.164,7.384 260.428,6.76 260.428,6.136 C260.428,5.224 259.996,4.528 259.132,4.048 C254.86,1.552 250.276,0.304 245.38,0.304 C240.532,0.304 236.032,1.492 231.88,3.868 C227.728,6.244 224.44,9.448 222.016,13.48 C219.592,17.512 218.38,21.904 218.38,26.656 C218.38,31.408 219.592,35.812 222.016,39.868 C224.44,43.924 227.728,47.14 231.88,49.516 C236.032,51.892 240.532,53.08 245.38,53.08 Z M279.796,52 C280.804,52 281.644,51.82 282.316,51.46 C282.988,51.1 283.42,50.584 283.612,49.912 L283.612,49.912 L285.844,42.712 L301.9,42.712 L304.132,49.912 C304.324,50.584 304.768,51.1 305.464,51.46 C306.16,51.82 307.012,52 308.02,52 L308.02,52 L317.884,52 C319.804,51.712 320.764,50.704 320.764,48.976 C320.764,48.304 320.644,47.596 320.404,46.852 C320.164,46.108 320.02,45.616 319.972,45.376 L319.972,45.376 L303.844,4.84 C303.556,3.976 303.004,3.232 302.188,2.608 C301.372,1.984 300.34,1.648 299.092,1.6 L299.092,1.6 L288.724,1.6 C287.572,1.648 286.576,1.948 285.736,2.5 C284.896,3.052 284.26,3.832 283.828,4.84 L283.828,4.84 L267.844,45.376 C267.796,45.472 267.64,45.916 267.376,46.708 C267.112,47.5 266.98,48.304 266.98,49.12 C266.98,50.752 267.916,51.712 269.788,52 L269.788,52 L279.796,52 Z M299.308,30.544 L288.004,30.544 L293.62,13.624 L299.308,30.544 Z M352.588,52 C353.404,52 354.088,51.688 354.64,51.064 C355.192,50.44 355.468,49.672 355.468,48.76 L355.468,48.76 L355.468,16.216 L366.844,16.216 C367.66,16.216 368.38,15.904 369.004,15.28 C369.628,14.656 369.94,13.936 369.94,13.12 L369.94,13.12 L369.94,4.768 C369.94,4 369.628,3.316 369.004,2.716 C368.38,2.116 367.66,1.816 366.844,1.816 L366.844,1.816 L329.116,1.816 C328.204,1.816 327.448,2.104 326.848,2.68 C326.248,3.256 325.948,3.952 325.948,4.768 L325.948,4.768 L325.948,13.12 C325.948,13.936 326.248,14.656 326.848,15.28 C327.448,15.904 328.204,16.216 329.116,16.216 L329.116,16.216 L340.636,16.216 L340.132,48.832 C340.132,49.744 340.408,50.5 340.96,51.1 C341.512,51.7 342.196,52 343.012,52 L343.012,52 L352.588,52 Z M402.052,52.792 C408.1,52.792 412.912,51.628 416.488,49.3 C420.064,46.972 422.536,44.068 423.904,40.588 C425.272,37.108 425.932,33.424 425.884,29.536 C425.884,29.5309474 425.883967,29.5237673 425.8839,29.5144598 L425.883102,29.4330859 C425.879911,29.1480111 425.868211,28.3183158 425.848,26.944 C425.8294,25.6792 425.818008,22.91524 425.813823,18.65212 L425.813103,17.80828 C425.812997,17.66452 425.8129,17.5192 425.81281,17.37232 L425.812,3.904 C425.86,3.184 425.632,2.62 425.128,2.212 C424.624,1.804 423.916,1.6 423.004,1.6 L423.004,1.6 L413.428,1.6 C412.612,1.6 411.904,1.828 411.304,2.284 C410.704,2.74 410.404,3.28 410.404,3.904 L410.404,3.904 L410.26,27.808 C410.26,34.144 407.476,37.312 401.908,37.312 C399.076,37.312 396.832,36.412 395.176,34.612 C393.52,32.812 392.668,30.352 392.62,27.232 L392.62,27.232 L392.332,3.76 C392.332,3.088 392.068,2.56 391.54,2.176 C391.012,1.792 390.268,1.6 389.308,1.6 L389.308,1.6 L379.876,1.6 C378.244,1.6 377.428,2.32 377.428,3.76 L377.428,3.76 L377.5,28.816 C377.5,33.04 378.376,36.964 380.128,40.588 C381.88,44.212 384.592,47.152 388.264,49.408 C391.936,51.664 396.532,52.792 402.052,52.792 Z M449.284,52.144 C450.148,52.144 450.88,51.844 451.48,51.244 C452.08,50.644 452.38,49.84 452.38,48.832 L452.38,48.832 L452.38,4.912 C452.38,4 452.08,3.22 451.48,2.572 C450.88,1.924 450.148,1.6 449.284,1.6 L449.284,1.6 L439.42,1.6 C438.46,1.6 437.692,1.924 437.116,2.572 C436.54,3.22 436.252,4 436.252,4.912 L436.252,4.912 L436.252,48.832 C436.252,49.84 436.54,50.644 437.116,51.244 C437.692,51.844 438.46,52.144 439.42,52.144 L439.42,52.144 L449.284,52.144 Z" id="metacatui" fill="#FCBF49" fill-rule="nonzero"></path>
    </g>
</svg>
</logo>

    </a>
    <h3>Externals</h3><ul><li><a href="external-TaxonomicClassification.html">TaxonomicClassification</a></li></ul><h3>Namespaces</h3><ul><li><a href="AppConfig.html">AppConfig</a></li><li><a href="IconUtilities.html">IconUtilities</a></li><li><a href="MapConfig.html">MapConfig</a></li><li><a href="MetacatUI.html">MetacatUI</a></li><li><a href="SearchParams.html">SearchParams</a></li><li><a href="Utilities.html">Utilities</a></li><li><a href="XMLUtilities.html">XMLUtilities</a></li></ul><h3>Classes</h3><ul><li class='category-heading' data-category='Collections'>Collections</li><li><a href="AccessPolicy.html">AccessPolicy</a></li><li><a href="Citations.html">Citations</a></li><li><a href="DataPackage.html">DataPackage</a></li><li><a href="Filters.html">Filters</a></li><li><a href="ObjectFormats.html">ObjectFormats</a></li><li><a href="ProjectList.html">ProjectList</a></li><li><a href="QualityReport.html">QualityReport</a></li><li><a href="SolrResults.html">SolrResults</a></li><li><a href="Units.html">Units</a></li><li><a href="UserGroup.html">UserGroup</a></li><li class='category-heading' data-category='Collections/Bookkeeper'>Collections/Bookkeeper</li><li><a href="Quotas.html">Quotas</a></li><li><a href="Usages.html">Usages</a></li><li class='category-heading' data-category='Collections/Geohashes'>Collections/Geohashes</li><li><a href="Geohashes.html">Geohashes</a></li><li class='category-heading' data-category='Collections/Maps'>Collections/Maps</li><li><a href="AssetCategories.html">AssetCategories</a></li><li><a href="AssetColors.html">AssetColors</a></li><li><a href="Features.html">Features</a></li><li><a href="GeoPoints.html">GeoPoints</a></li><li><a href="MapAssets.html">MapAssets</a></li><li><a href="VectorFilters.html">VectorFilters</a></li><li><a href="ZoomPresets.html">ZoomPresets</a></li><li class='category-heading' data-category='Collections/Metadata/EML'>Collections/Metadata/EML</li><li><a href="EMLAnnotations.html">EMLAnnotations</a></li><li><a href="EMLAttributes.html">EMLAttributes</a></li><li><a href="EMLEntities.html">EMLEntities</a></li><li><a href="EMLMissingValueCodes.html">EMLMissingValueCodes</a></li><li class='category-heading' data-category='Collections/Ontologies'>Collections/Ontologies</li><li><a href="BioontologyResults.html">BioontologyResults</a></li><li class='category-heading' data-category='Collections/QueryFields'>Collections/QueryFields</li><li><a href="QueryFields.html">QueryFields</a></li><li class='category-heading' data-category='Collections/SearchSelect'>Collections/SearchSelect</li><li><a href="SearchSelectOptions.html">SearchSelectOptions</a></li><li class='category-heading' data-category='Errors'>Errors</li><li><a href="InvalidAttributeListError.html">InvalidAttributeListError</a></li><li class='category-heading' data-category='Models'>Models</li><li><a href="AccessRule.html">AccessRule</a></li><li><a href="Accordion.html">Accordion</a></li><li><a href="AppModel.html">AppModel</a></li><li><a href="CitationModel.html">CitationModel</a></li><li><a href="CollectionModel.html">CollectionModel</a></li><li><a href="CrossRef.html">CrossRef</a></li><li><a href="DataONEObject.html">DataONEObject</a></li><li><a href="LookupModel.html">LookupModel</a></li><li><a href="Map.html">Map</a></li><li><a href="Metrics.html">Metrics</a></li><li><a href="QualityCheck.html">QualityCheck</a></li><li><a href="Search.html">Search</a></li><li><a href="SolrResult.html">SolrResult</a></li><li><a href="Stats.html">Stats</a></li><li class='category-heading' data-category='Models/Accordion'>Models/Accordion</li><li><a href="AccordionItem.html">AccordionItem</a></li><li class='category-heading' data-category='Models/Analytics'>Models/Analytics</li><li><a href="Analytics.html">Analytics</a></li><li><a href="GoogleAnalytics.html">GoogleAnalytics</a></li><li class='category-heading' data-category='Models/Bookkeeper'>Models/Bookkeeper</li><li><a href="Quota.html">Quota</a></li><li><a href="Subscription.html">Subscription</a></li><li><a href="Usage.html">Usage</a></li><li class='category-heading' data-category='Models/Connectors'>Models/Connectors</li><li><a href="BioontologyAccordionSearchSelect.html">BioontologyAccordionSearchSelect</a></li><li><a href="FiltersMapConnector.html">FiltersMapConnector</a></li><li><a href="FiltersSearchConnector.html">FiltersSearchConnector</a></li><li><a href="GeoPointsCesiumConnector.html">GeoPointsCesiumConnector</a></li><li><a href="GeoPointsCesiumPointsConnector.html">GeoPointsCesiumPointsConnector</a></li><li><a href="GeoPointsCesiumPolygonConnector.html">GeoPointsCesiumPolygonConnector</a></li><li><a href="MapSearchConnector.html">MapSearchConnector</a></li><li><a href="MapSearchFiltersConnector.html">MapSearchFiltersConnector</a></li><li class='category-heading' data-category='Models/Filters'>Models/Filters</li><li><a href="BooleanFilter.html">BooleanFilter</a></li><li><a href="ChoiceFilter.html">ChoiceFilter</a></li><li><a href="DateFilter.html">DateFilter</a></li><li><a href="Filter.html">Filter</a></li><li><a href="FilterGroup.html">FilterGroup</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="SpatialFilter.html">SpatialFilter</a></li><li><a href="ToggleFilter.html">ToggleFilter</a></li><li class='category-heading' data-category='Models/Formats'>Models/Formats</li><li><a href="ObjectFormat.html">ObjectFormat</a></li><li class='category-heading' data-category='Models/Geocoder'>Models/Geocoder</li><li><a href="GeocodedLocation.html">GeocodedLocation</a></li><li><a href="GeocoderSearch.html">GeocoderSearch</a></li><li><a href="GoogleMapsAutocompleter.html">GoogleMapsAutocompleter</a></li><li><a href="GoogleMapsGeocoder.html">GoogleMapsGeocoder</a></li><li><a href="Prediction.html">Prediction</a></li><li class='category-heading' data-category='Models/Geohashes'>Models/Geohashes</li><li><a href="Geohash.html">Geohash</a></li><li class='category-heading' data-category='Models/Maps'>Models/Maps</li><li><a href="AssetCategory.html">AssetCategory</a></li><li><a href="AssetColor.html">AssetColor</a></li><li><a href="AssetColorPalette.html">AssetColorPalette</a></li><li><a href="ExpansionPanelsModel.html">ExpansionPanelsModel</a></li><li><a href="Feature.html">Feature</a></li><li><a href="GeoBoundingBox.html">GeoBoundingBox</a></li><li><a href="GeoPoint.html">GeoPoint</a></li><li><a href="GeoScale.html">GeoScale</a></li><li><a href="GeoUtilities.html">GeoUtilities</a></li><li><a href="MapInteraction.html">MapInteraction</a></li><li><a href="MapModel.html">MapModel</a></li><li><a href="VectorFilter.html">VectorFilter</a></li><li><a href="ViewfinderModel.html">ViewfinderModel</a></li><li><a href="ZoomPresetModel.html">ZoomPresetModel</a></li><li class='category-heading' data-category='Models/Maps/Assets'>Models/Maps/Assets</li><li><a href="Cesium3DTileset.html">Cesium3DTileset</a></li><li><a href="CesiumGeohash.html">CesiumGeohash</a></li><li><a href="CesiumImagery.html">CesiumImagery</a></li><li><a href="CesiumTerrain.html">CesiumTerrain</a></li><li><a href="CesiumVectorData.html">CesiumVectorData</a></li><li><a href="MapAsset.html">MapAsset</a></li><li class='category-heading' data-category='Models/Metadata'>Models/Metadata</li><li><a href="ScienceMetadata.html">ScienceMetadata</a></li><li class='category-heading' data-category='Models/Metadata/EML'>Models/Metadata/EML</li><li><a href="EMLMethodStep.html">EMLMethodStep</a></li><li><a href="EMLSpecializedText.html">EMLSpecializedText</a></li><li><a href="EMLTaxonCoverage.html">EMLTaxonCoverage</a></li><li class='category-heading' data-category='Models/Metadata/EML211'>Models/Metadata/EML211</li><li><a href="EML211.html">EML211</a></li><li><a href="EMLAnnotation.html">EMLAnnotation</a></li><li><a href="EMLAttribute.html">EMLAttribute</a></li><li><a href="EMLDataTable.html">EMLDataTable</a></li><li><a href="EMLDistribution.html">EMLDistribution</a></li><li><a href="EMLEntity.html">EMLEntity</a></li><li><a href="EMLGeoCoverage.html">EMLGeoCoverage</a></li><li><a href="EMLMeasurementScale.html">EMLMeasurementScale</a></li><li><a href="EMLMethods.html">EMLMethods</a></li><li><a href="EMLMissingValueCode.html">EMLMissingValueCode</a></li><li><a href="EMLNonNumericDomain.html">EMLNonNumericDomain</a></li><li><a href="EMLNumericDomain.html">EMLNumericDomain</a></li><li><a href="EMLOtherEntity.html">EMLOtherEntity</a></li><li><a href="EMLParty.html">EMLParty</a></li><li><a href="EMLTemporalCoverage.html">EMLTemporalCoverage</a></li><li><a href="EMLText211.html">EMLText211</a></li><li><a href="EMLUnit.html">EMLUnit</a></li><li class='category-heading' data-category='Models/Metadata/EML220'>Models/Metadata/EML220</li><li><a href="EMLText.html">EMLText</a></li><li class='category-heading' data-category='Models/Ontologies'>Models/Ontologies</li><li><a href="BioOntology.html">BioOntology</a></li><li><a href="Bioontology_.html">Bioontology</a></li><li><a href="BioontologyBatch.html">BioontologyBatch</a></li><li><a href="BioontologyClass.html">BioontologyClass</a></li><li class='category-heading' data-category='Models/Portals'>Models/Portals</li><li><a href="PortalImage.html">PortalImage</a></li><li><a href="PortalModel.html">PortalModel</a></li><li><a href="PortalSectionModel.html">PortalSectionModel</a></li><li class='category-heading' data-category='Models/Projects'>Models/Projects</li><li><a href="Project.html">Project</a></li><li class='category-heading' data-category='Models/QueryFields'>Models/QueryFields</li><li><a href="QueryField.html">QueryField</a></li><li class='category-heading' data-category='Models/SearchSelect'>Models/SearchSelect</li><li><a href="AccountSearchSelect.html">AccountSearchSelect</a></li><li><a href="QueryFieldSearchSelect.html">QueryFieldSearchSelect</a></li><li><a href="SearchSelect.html">SearchSelect</a></li><li><a href="SelectOptionModel.html">SelectOptionModel</a></li><li><a href="SolrAutocomplete.html">SolrAutocomplete</a></li><li class='category-heading' data-category='Models/schemaOrg'>Models/schemaOrg</li><li><a href="SchemaOrgModel.html">SchemaOrgModel</a></li><li class='category-heading' data-category='Router'>Router</li><li><a href="UIRouter.html">UIRouter</a></li><li class='category-heading' data-category='Views'>Views</li><li><a href="AccessPolicyView.html">AccessPolicyView</a></li><li><a href="AccessRuleView.html">AccessRuleView</a></li><li><a href="AnnotationView.html">AnnotationView</a></li><li><a href="AppView.html">AppView</a></li><li><a href="CanonicalDatasetHandlerView.html">CanonicalDatasetHandlerView</a></li><li><a href="CatalogSearchView.html">CatalogSearchView</a></li><li><a href="CitationHeaderView.html">CitationHeaderView</a></li><li><a href="CitationListView.html">CitationListView</a></li><li><a href="CitationModalView.html">CitationModalView</a></li><li><a href="CitationView.html">CitationView</a></li><li><a href="ColorPaletteView.html">ColorPaletteView</a></li><li><a href="DataCatalogView.html">DataCatalogView</a></li><li><a href="DataCatalogViewWithFilters.html">DataCatalogViewWithFilters</a></li><li><a href="DataItemView.html">DataItemView</a></li><li><a href="DataObjectView.html">DataObjectView</a></li><li><a href="DataPackageView.html">DataPackageView</a></li><li><a href="DraftsView.html">DraftsView</a></li><li><a href="EditCollectionView.html">EditCollectionView</a></li><li><a href="EditorView.html">EditorView</a></li><li><a href="FooterView.html">FooterView</a></li><li><a href="GroupListView.html">GroupListView</a></li><li><a href="ImageUploaderView.html">ImageUploaderView</a></li><li><a href="MarkdownEditorView.html">MarkdownEditorView</a></li><li><a href="MarkdownView.html">MarkdownView</a></li><li><a href="MdqRunView.html">MdqRunView</a></li><li><a href="MetadataView.html">MetadataView</a></li><li><a href="MetricModalView.html">MetricModalView</a></li><li><a href="MetricView.html">MetricView</a></li><li><a href="MetricsChartView.html">MetricsChartView</a></li><li><a href="NavbarView.html">NavbarView</a></li><li><a href="RegisterCitationView.html">RegisterCitationView</a></li><li><a href="SearchResultView.html">SearchResultView</a></li><li><a href="SignInView.html">SignInView</a></li><li><a href="TOCView.html">TOCView</a></li><li><a href="TableEditorView.html">TableEditorView</a></li><li><a href="UserGroupView.html">UserGroupView</a></li><li><a href="UserView.html">UserView</a></li><li><a href="ViewDataButtonView.html">ViewDataButtonView</a></li><li class='category-heading' data-category='Views/Accordion'>Views/Accordion</li><li><a href="AccordionItemView.html">AccordionItemView</a></li><li><a href="AccordionView.html">AccordionView</a></li><li class='category-heading' data-category='Views/Filters'>Views/Filters</li><li><a href="BooleanFilterView.html">BooleanFilterView</a></li><li><a href="ChoiceFilterView.html">ChoiceFilterView</a></li><li><a href="DateFilterView.html">DateFilterView</a></li><li><a href="FilterEditorView.html">FilterEditorView</a></li><li><a href="FilterGroupView.html">FilterGroupView</a></li><li><a href="FilterGroupsView.html">FilterGroupsView</a></li><li><a href="FilterView.html">FilterView</a></li><li><a href="NumericFilterView.html">NumericFilterView</a></li><li><a href="SemanticFilterView.html">SemanticFilterView</a></li><li><a href="ToggleFilterView.html">ToggleFilterView</a></li><li class='category-heading' data-category='Views/Maps'>Views/Maps</li><li><a href="CesiumWidgetView.html">CesiumWidgetView</a></li><li><a href="DownloadPanelView.html">DownloadPanelView</a></li><li><a href="FeatureInfoView.html">FeatureInfoView</a></li><li><a href="LayerCategoryListView.html">LayerCategoryListView</a></li><li><a href="LayerDetailView.html">LayerDetailView</a></li><li><a href="LayerDetailsView.html">LayerDetailsView</a></li><li><a href="LayerInfoView.html">LayerInfoView</a></li><li><a href="LayerItemView.html">LayerItemView</a></li><li><a href="LayerListView.html">LayerListView</a></li><li><a href="LayerNavigationView.html">LayerNavigationView</a></li><li><a href="LayerOpacityView.html">LayerOpacityView</a></li><li><a href="LayersPanelView.html">LayersPanelView</a></li><li><a href="MapHelpPanel.html">MapHelpPanel</a></li><li><a href="MapView.html">MapView</a></li><li><a href="MapWidgetContainerView.html">MapWidgetContainerView</a></li><li><a href="PredictionView.html">PredictionView</a></li><li><a href="PredictionsListView.html">PredictionsListView</a></li><li><a href="ScaleBarView.html">ScaleBarView</a></li><li><a href="SchemaOrgView.html">SchemaOrgView</a></li><li><a href="SearchInputView.html">SearchInputView</a></li><li><a href="SearchView.html">SearchView</a></li><li><a href="ShareUrlView.html">ShareUrlView</a></li><li><a href="ToolbarView.html">ToolbarView</a></li><li><a href="ViewfinderView.html">ViewfinderView</a></li><li class='category-heading' data-category='Views/Maps/Legend'>Views/Maps/Legend</li><li><a href="CategoricalSwatchView.html">CategoricalSwatchView</a></li><li><a href="ContinuousSwatchView.html">ContinuousSwatchView</a></li><li><a href="LayerLegendView.html">LayerLegendView</a></li><li><a href="LegendContainerView.html">LegendContainerView</a></li><li class='category-heading' data-category='Views/Maps/Viewfinder'>Views/Maps/Viewfinder</li><li><a href="ExpansionPanelView.html">ExpansionPanelView</a></li><li><a href="ZoomPresetView.html">ZoomPresetView</a></li><li><a href="ZoomPresetsListView.html">ZoomPresetsListView</a></li><li class='category-heading' data-category='Views/Metadata'>Views/Metadata</li><li><a href="AutofillAttributesView.html">AutofillAttributesView</a></li><li><a href="EML211EditorView.html">EML211EditorView</a></li><li><a href="EMLAttributeView.html">EMLAttributeView</a></li><li><a href="EMLAttributesView.html">EMLAttributesView</a></li><li><a href="EMLEntityView.html">EMLEntityView</a></li><li><a href="EMLMeasurementScaleView.html">EMLMeasurementScaleView</a></li><li><a href="EMLMeasurementTypeView.html">EMLMeasurementTypeView</a></li><li><a href="EMLMethodsView.html">EMLMethodsView</a></li><li><a href="EMLMissingValueCodeView.html">EMLMissingValueCodeView</a></li><li><a href="EMLMissingValueCodesView.html">EMLMissingValueCodesView</a></li><li><a href="EMLOtherEntityView.html">EMLOtherEntityView</a></li><li><a href="EMLPartyView.html">EMLPartyView</a></li><li><a href="EMLTempCoverageView.html">EMLTempCoverageView</a></li><li><a href="EMLView.html">EMLView</a></li><li><a href="EMlGeoCoverageView_.html">EMlGeoCoverageView</a></li><li><a href="ScienceMetadataView.html">ScienceMetadataView</a></li><li class='category-heading' data-category='Views/Ontologies'>Views/Ontologies</li><li><a href="BioontologyBrowser.html">BioontologyBrowser</a></li><li class='category-heading' data-category='Views/Portals'>Views/Portals</li><li><a href="PortalDataView.html">PortalDataView</a></li><li><a href="PortalHeaderView.html">PortalHeaderView</a></li><li><a href="PortalListView.html">PortalListView</a></li><li><a href="PortalLogosView.html">PortalLogosView</a></li><li><a href="PortalMembersView.html">PortalMembersView</a></li><li><a href="PortalSectionView.html">PortalSectionView</a></li><li><a href="PortalUsagesView.html">PortalUsagesView</a></li><li><a href="PortalView.html">PortalView</a></li><li><a href="PortalVisualizationsView.html">PortalVisualizationsView</a></li><li><a href="PortalsSearchView.html">PortalsSearchView</a></li><li class='category-heading' data-category='Views/Portals/Editor'>Views/Portals/Editor</li><li><a href="PortEditorDataView.html">PortEditorDataView</a></li><li><a href="PortEditorImageView.html">PortEditorImageView</a></li><li><a href="PortEditorLogosView.html">PortEditorLogosView</a></li><li><a href="PortEditorMdSectionView.html">PortEditorMdSectionView</a></li><li><a href="PortEditorSectionView.html">PortEditorSectionView</a></li><li><a href="PortEditorSectionsView.html">PortEditorSectionsView</a></li><li><a href="PortEditorSettingsView.html">PortEditorSettingsView</a></li><li><a href="PortalEditorView.html">PortalEditorView</a></li><li class='category-heading' data-category='Views/Projects'>Views/Projects</li><li><a href="ProjectView.html">ProjectView</a></li><li class='category-heading' data-category='Views/QueryBuilder'>Views/QueryBuilder</li><li><a href="QueryBuilderView.html">QueryBuilderView</a></li><li><a href="QueryRuleView.html">QueryRuleView</a></li><li class='category-heading' data-category='Views/Search'>Views/Search</li><li><a href="SearchResultsPagerView.html">SearchResultsPagerView</a></li><li><a href="SearchResultsView.html">SearchResultsView</a></li><li><a href="SorterView.html">SorterView</a></li><li class='category-heading' data-category='Views/SearchSelect'>Views/SearchSelect</li><li><a href="AccountSelectView.html">AccountSelectView</a></li><li><a href="AnnotationFilter.html">AnnotationFilter</a></li><li><a href="BioontologySelectView.html">BioontologySelectView</a></li><li><a href="NodeSelect.html">NodeSelect</a></li><li><a href="ObjectFormatSelect.html">ObjectFormatSelect</a></li><li><a href="QueryFieldSelectView.html">QueryFieldSelectView</a></li><li><a href="SearchSelectView.html">SearchSelectView</a></li><li><a href="SeparatorView.html">SeparatorView</a></li><li><a href="EMLTaxonView.html">EMLTaxonView</a></li><li class='category-heading' data-category='Deprecated'>Deprecated</li><li><a href="AnnotatorView.html">AnnotatorView</a></li><li><a href="ExternalView.html">ExternalView</a></li><li><a href="LogsSearch.html">LogsSearch</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addClassesFromResponse">addClassesFromResponse</a></li><li><a href="global.html#addFields">addFields</a></li><li><a href="global.html#addSelected">addSelected</a></li><li><a href="global.html#adjustDescriptionLength">adjustDescriptionLength</a></li><li><a href="global.html#appConfigPath">appConfigPath</a></li><li><a href="global.html#buildChildrenUrl">buildChildrenUrl</a></li><li><a href="global.html#buildSearchUrl">buildSearchUrl</a></li><li><a href="global.html#canChangeSeparator">canChangeSeparator</a></li><li><a href="global.html#changeSubmenuOnSearch">changeSubmenuOnSearch</a></li><li><a href="global.html#couldBeLatLong">couldBeLatLong</a></li><li><a href="global.html#createBatchPayload">createBatchPayload</a></li><li><a href="global.html#createHeaders">createHeaders</a></li><li><a href="global.html#defaults">defaults</a></li><li><a href="global.html#encodeIfPresent">encodeIfPresent</a></li><li><a href="global.html#excludeFields">excludeFields</a></li><li><a href="global.html#fetchClasses">fetchClasses</a></li><li><a href="global.html#fetchClassesFromOntology">fetchClassesFromOntology</a></li><li><a href="global.html#fetchFromOntologies">fetchFromOntologies</a></li><li><a href="global.html#fetchQueryFields">fetchQueryFields</a></li><li><a href="global.html#fieldToOption">fieldToOption</a></li><li><a href="global.html#filterClassesToFetch">filterClassesToFetch</a></li><li><a href="global.html#finalizeFetch">finalizeFetch</a></li><li><a href="global.html#formatResult">formatResult</a></li><li><a href="global.html#formatResults">formatResults</a></li><li><a href="global.html#generateGeoJSONPoint">generateGeoJSONPoint</a></li><li><a href="global.html#generateGeoJSONPolygon">generateGeoJSONPolygon</a></li><li><a href="global.html#generateGeoJSONString">generateGeoJSONString</a></li><li><a href="global.html#generateIdentifier">generateIdentifier</a></li><li><a href="global.html#generateSpatialCoverage">generateSpatialCoverage</a></li><li><a href="global.html#getAccountDetails">getAccountDetails</a></li><li><a href="global.html#getCachedClasses">getCachedClasses</a></li><li><a href="global.html#getCategoryNames">getCategoryNames</a></li><li><a href="global.html#getChildren">getChildren</a></li><li><a href="global.html#getClasses">getClasses</a></li><li><a href="global.html#getDOIURL">getDOIURL</a></li><li><a href="global.html#getIncludeParam">getIncludeParam</a></li><li><a href="global.html#getNextPage">getNextPage</a></li><li><a href="global.html#getNextSeparator">getNextSeparator</a></li><li><a href="global.html#getOptionByLabelOrValue">getOptionByLabelOrValue</a></li><li><a href="global.html#getOptionsByCategory">getOptionsByCategory</a></li><li><a href="global.html#getQueryFieldOptions">getQueryFieldOptions</a></li><li><a href="global.html#getSelectedModels">getSelectedModels</a></li><li><a href="global.html#hasInvalidSelections">hasInvalidSelections</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#initializeFetch">initializeFetch</a></li><li><a href="global.html#isValidValue">isValidValue</a></li><li><a href="global.html#model">model</a></li><li><a href="global.html#moveClassesToNotFound">moveClassesToNotFound</a></li><li><a href="global.html#optionsAsJSON">optionsAsJSON</a></li><li><a href="global.html#padDescription">padDescription</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#recordError">recordError</a></li><li><a href="global.html#removeSelected">removeSelected</a></li><li><a href="global.html#renameCategory">renameCategory</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetPageInfo">resetPageInfo</a></li><li><a href="global.html#responseAsync">responseAsync</a></li><li><a href="global.html#separatorRequired">separatorRequired</a></li><li><a href="global.html#serialize">serialize</a></li><li><a href="global.html#setAddedFieldDetails">setAddedFieldDetails</a></li><li><a href="global.html#setDataCatalogSchema">setDataCatalogSchema</a></li><li><a href="global.html#setDatasetSchema">setDatasetSchema</a></li><li><a href="global.html#setNextSeparator">setNextSeparator</a></li><li><a href="global.html#setOptionsForPreselected">setOptionsForPreselected</a></li><li><a href="global.html#setSchema">setSchema</a></li><li><a href="global.html#setSchemaFromTemplate">setSchemaFromTemplate</a></li><li><a href="global.html#setSelected">setSelected</a></li><li><a href="global.html#sortByProp">sortByProp</a></li><li><a href="global.html#sortFields">sortFields</a></li><li><a href="global.html#toAccordionItem">toAccordionItem</a></li><li><a href="global.html#toJSON">toJSON</a></li><li><a href="global.html#toSearchSelectOption">toSearchSelectOption</a></li><li><a href="global.html#truncateDescription">truncateDescription</a></li><li><a href="global.html#updateOptions">updateOptions</a></li><li><a href="global.html#url">url</a></li><li><a href="global.html#waitForFetchComplete">waitForFetchComplete</a></li></ul>
</nav>

<div id="main">

    <h1 class="page-title">Source: src/js/models/metadata/eml211/EML211.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>define([
  "jquery",
  "underscore",
  "backbone",
  "uuid",
  "collections/Units",
  "collections/metadata/eml/EMLEntities",
  "models/metadata/ScienceMetadata",
  "models/DataONEObject",
  "models/metadata/eml211/EMLGeoCoverage",
  "models/metadata/eml211/EMLKeywordSet",
  "models/metadata/eml211/EMLTaxonCoverage",
  "models/metadata/eml211/EMLTemporalCoverage",
  "models/metadata/eml211/EMLDistribution",
  "models/metadata/eml211/EMLParty",
  "models/metadata/eml211/EMLProject",
  "models/metadata/eml211/EMLText",
  "models/metadata/eml211/EMLMethods",
  "collections/metadata/eml/EMLAnnotations",
  "models/metadata/eml211/EMLAnnotation",
], (
  $,
  _,
  Backbone,
  uuid,
  Units,
  EMLEntities,
  ScienceMetadata,
  DataONEObject,
  EMLGeoCoverage,
  EMLKeywordSet,
  EMLTaxonCoverage,
  EMLTemporalCoverage,
  EMLDistribution,
  EMLParty,
  EMLProject,
  EMLText,
  EMLMethods,
  EMLAnnotations,
  EMLAnnotation,
) => {
  /**
   * @class EML211
   * @classdesc An EML211 object represents an Ecological Metadata Language
   * document, version 2.1.1
   * @classcategory Models/Metadata/EML211
   * @augments ScienceMetadata
   */
  const EML211 = ScienceMetadata.extend(
    /** @lends EML211.prototype */ {
      type: "EML",

      defaults() {
        return _.extend(ScienceMetadata.prototype.defaults(), {
          id: `urn:uuid:${uuid.v4()}`,
          formatId: "https://eml.ecoinformatics.org/eml-2.2.0",
          objectXML: null,
          isEditable: false,
          alternateIdentifier: [],
          shortName: null,
          title: [],
          creator: [], // array of EMLParty objects
          metadataProvider: [], // array of EMLParty objects
          associatedParty: [], // array of EMLParty objects
          contact: [], // array of EMLParty objects
          publisher: [], // array of EMLParty objects
          pubDate: null,
          language: null,
          series: null,
          abstract: [], // array of EMLText objects
          keywordSets: [], // array of EMLKeywordSet objects
          additionalInfo: [],
          intellectualRights:
            "This work is dedicated to the public domain under the Creative Commons Universal 1.0 Public Domain Dedication. To view a copy of this dedication, visit https://creativecommons.org/publicdomain/zero/1.0/.",
          distribution: [], // array of EMLDistribution objects
          geoCoverage: [], // an array for EMLGeoCoverages
          temporalCoverage: [], // an array of EMLTempCoverage models
          taxonCoverage: [], // an array of EMLTaxonCoverages
          purpose: [],
          entities: new EMLEntities(),
          pubplace: null,
          methods: new EMLMethods(), // An EMLMethods objects
          project: null, // An EMLProject object,
          annotations: null, // Dataset-level annotations
          canonicalDataset: null,
          dataSensitivityPropertyURI:
            "http://purl.dataone.org/odo/SENSO_00000005",
          nodeOrder: [
            "alternateidentifier",
            "shortname",
            "title",
            "creator",
            "metadataprovider",
            "associatedparty",
            "pubdate",
            "language",
            "series",
            "abstract",
            "keywordset",
            "additionalinfo",
            "intellectualrights",
            "licensed",
            "distribution",
            "coverage",
            "annotation",
            "purpose",
            "introduction",
            "gettingstarted",
            "acknowledgements",
            "maintenance",
            "contact",
            "publisher",
            "pubplace",
            "methods",
            "project",
            "datatable",
            "spatialraster",
            "spatialvector",
            "storedprocedure",
            "view",
            "otherentity",
            "referencepublications",
            "usagecitations",
            "literaturecited",
          ],
        });
      },

      units: new Units(),

      initialize(attributes) {
        // Call initialize for the super class
        ScienceMetadata.prototype.initialize.call(this, attributes);

        // EML211-specific init goes here this.set("objectXML",
        // this.createXML());
        this.parse(this.createXML());

        this.on("sync", function () {
          this.set("synced", true);
        });

        this.stopListening(this, "change:canonicalDataset");
        this.listenTo(
          this,
          "change:canonicalDataset",
          this.updateCanonicalDataset,
        );

        this.listenTo(this, "change:entities", () => {
          this.trickleUpChange();
          this.listenTo(this.get("entities"), "update", () => {
            this.trickleUpChange();
          });
        });

        // Create a Unit collection
        if (!this.units.length) this.createUnits();
      },

      url(options) {
        let identifier;
        if (options &amp;&amp; options.update) {
          identifier = this.get("oldPid") || this.get("seriesid");
        } else {
          identifier = this.get("id") || this.get("seriesid");
        }
        return (
          MetacatUI.appModel.get("objectServiceUrl") +
          encodeURIComponent(identifier)
        );
      },

      /**
       * Update the canonoical dataset URI in the annotations collection to
       * match the canonicalDataset value on this model.
       */
      updateCanonicalDataset() {
        let uri = this.get("canonicalDataset");
        if (uri &amp;&amp; Array.isArray(uri) &amp;&amp; uri.length) {
          [uri] = uri;
        }
        let annotations = this.get("annotations");
        if (!annotations) {
          annotations = new EMLAnnotations();
          this.set("annotations", annotations);
        }
        annotations.updateCanonicalDataset(uri);
      },

      /*
       * Maps the lower-case EML node names (valid in HTML DOM) to the
       * camel-cased EML node names (valid in EML). Used during parse() and
       * serialize()
       */
      nodeNameMap() {
        return _.extend(
          this.constructor.__super__.nodeNameMap(),
          EMLDistribution.prototype.nodeNameMap(),
          EMLGeoCoverage.prototype.nodeNameMap(),
          EMLKeywordSet.prototype.nodeNameMap(),
          EMLParty.prototype.nodeNameMap(),
          EMLProject.prototype.nodeNameMap(),
          EMLTaxonCoverage.prototype.nodeNameMap(),
          EMLTemporalCoverage.prototype.nodeNameMap(),
          EMLMethods.prototype.nodeNameMap(),
          {
            accuracyreport: "accuracyReport",
            actionlist: "actionList",
            additionalclassifications: "additionalClassifications",
            additionalinfo: "additionalInfo",
            additionallinks: "additionalLinks",
            additionalmetadata: "additionalMetadata",
            allowfirst: "allowFirst",
            alternateidentifier: "alternateIdentifier",
            altitudedatumname: "altitudeDatumName",
            altitudedistanceunits: "altitudeDistanceUnits",
            altituderesolution: "altitudeResolution",
            altitudeencodingmethod: "altitudeEncodingMethod",
            altitudesysdef: "altitudeSysDef",
            asneeded: "asNeeded",
            associatedparty: "associatedParty",
            attributeaccuracyexplanation: "attributeAccuracyExplanation",
            attributeaccuracyreport: "attributeAccuracyReport",
            attributeaccuracyvalue: "attributeAccuracyValue",
            attributedefinition: "attributeDefinition",
            attributelabel: "attributeLabel",
            attributelist: "attributeList",
            attributename: "attributeName",
            attributeorientation: "attributeOrientation",
            attributereference: "attributeReference",
            awardnumber: "awardNumber",
            awardurl: "awardUrl",
            audiovisual: "audioVisual",
            authsystem: "authSystem",
            banddescription: "bandDescription",
            bilinearfit: "bilinearFit",
            binaryrasterformat: "binaryRasterFormat",
            blockedmembernode: "blockedMemberNode",
            booktitle: "bookTitle",
            cameracalibrationinformationavailability:
              "cameraCalibrationInformationAvailability",
            casesensitive: "caseSensitive",
            cellgeometry: "cellGeometry",
            cellsizexdirection: "cellSizeXDirection",
            cellsizeydirection: "cellSizeYDirection",
            changehistory: "changeHistory",
            changedate: "changeDate",
            changescope: "changeScope",
            chapternumber: "chapterNumber",
            characterencoding: "characterEncoding",
            checkcondition: "checkCondition",
            checkconstraint: "checkConstraint",
            childoccurences: "childOccurences",
            citableclassificationsystem: "citableClassificationSystem",
            cloudcoverpercentage: "cloudCoverPercentage",
            codedefinition: "codeDefinition",
            codeexplanation: "codeExplanation",
            codesetname: "codesetName",
            codeseturl: "codesetURL",
            collapsedelimiters: "collapseDelimiters",
            communicationtype: "communicationType",
            compressiongenerationquality: "compressionGenerationQuality",
            compressionmethod: "compressionMethod",
            conferencedate: "conferenceDate",
            conferencelocation: "conferenceLocation",
            conferencename: "conferenceName",
            conferenceproceedings: "conferenceProceedings",
            constraintdescription: "constraintDescription",
            constraintname: "constraintName",
            constanttosi: "constantToSI",
            controlpoint: "controlPoint",
            cornerpoint: "cornerPoint",
            customunit: "customUnit",
            dataformat: "dataFormat",
            datasetgpolygon: "datasetGPolygon",
            datasetgpolygonoutergring: "datasetGPolygonOuterGRing",
            datasetgpolygonexclusiongring: "datasetGPolygonExclusionGRing",
            datatable: "dataTable",
            datatype: "dataType",
            datetime: "dateTime",
            datetimedomain: "dateTimeDomain",
            datetimeprecision: "dateTimePrecision",
            defaultvalue: "defaultValue",
            definitionattributereference: "definitionAttributeReference",
            denomflatratio: "denomFlatRatio",
            depthsysdef: "depthSysDef",
            depthdatumname: "depthDatumName",
            depthdistanceunits: "depthDistanceUnits",
            depthencodingmethod: "depthEncodingMethod",
            depthresolution: "depthResolution",
            descriptorvalue: "descriptorValue",
            dictref: "dictRef",
            diskusage: "diskUsage",
            domainDescription: "domainDescription",
            editedbook: "editedBook",
            encodingmethod: "encodingMethod",
            endcondition: "endCondition",
            entitycodelist: "entityCodeList",
            entitydescription: "entityDescription",
            entityname: "entityName",
            entityreference: "entityReference",
            entitytype: "entityType",
            enumerateddomain: "enumeratedDomain",
            errorbasis: "errorBasis",
            errorvalues: "errorValues",
            externalcodeset: "externalCodeSet",
            externallydefinedformat: "externallyDefinedFormat",
            fielddelimiter: "fieldDelimiter",
            fieldstartcolumn: "fieldStartColumn",
            fieldwidth: "fieldWidth",
            filmdistortioninformationavailability:
              "filmDistortionInformationAvailability",
            foreignkey: "foreignKey",
            formatname: "formatName",
            formatstring: "formatString",
            formatversion: "formatVersion",
            fractiondigits: "fractionDigits",
            fundername: "funderName",
            funderidentifier: "funderIdentifier",
            gettingstarted: "gettingStarted",
            gring: "gRing",
            gringpoint: "gRingPoint",
            gringlatitude: "gRingLatitude",
            gringlongitude: "gRingLongitude",
            geogcoordsys: "geogCoordSys",
            geometricobjectcount: "geometricObjectCount",
            georeferenceinfo: "georeferenceInfo",
            highwavelength: "highWavelength",
            horizontalaccuracy: "horizontalAccuracy",
            horizcoordsysdef: "horizCoordSysDef",
            horizcoordsysname: "horizCoordSysName",
            identifiername: "identifierName",
            illuminationazimuthangle: "illuminationAzimuthAngle",
            illuminationelevationangle: "illuminationElevationAngle",
            imagingcondition: "imagingCondition",
            imagequalitycode: "imageQualityCode",
            imageorientationangle: "imageOrientationAngle",
            intellectualrights: "intellectualRights",
            imagedescription: "imageDescription",
            isbn: "ISBN",
            issn: "ISSN",
            joincondition: "joinCondition",
            keywordtype: "keywordType",
            languagevalue: "LanguageValue",
            languagecodestandard: "LanguageCodeStandard",
            lensdistortioninformationavailability:
              "lensDistortionInformationAvailability",
            licensename: "licenseName",
            licenseurl: "licenseURL",
            linenumber: "lineNumber",
            literalcharacter: "literalCharacter",
            literallayout: "literalLayout",
            literaturecited: "literatureCited",
            lowwavelength: "lowWaveLength",
            machineprocessor: "machineProcessor",
            maintenanceupdatefrequency: "maintenanceUpdateFrequency",
            matrixtype: "matrixType",
            maxexclusive: "maxExclusive",
            maxinclusive: "maxInclusive",
            maxlength: "maxLength",
            maxrecordlength: "maxRecordLength",
            maxvalues: "maxValues",
            measurementscale: "measurementScale",
            metadatalist: "metadataList",
            methodstep: "methodStep",
            minexclusive: "minExclusive",
            mininclusive: "minInclusive",
            minlength: "minLength",
            minvalues: "minValues",
            missingvaluecode: "missingValueCode",
            moduledocs: "moduleDocs",
            modulename: "moduleName",
            moduledescription: "moduleDescription",
            multiband: "multiBand",
            multipliertosi: "multiplierToSI",
            nonnumericdomain: "nonNumericDomain",
            notnullconstraint: "notNullConstraint",
            notplanned: "notPlanned",
            numberofbands: "numberOfBands",
            numbertype: "numberType",
            numericdomain: "numericDomain",
            numfooterlines: "numFooterLines",
            numheaderlines: "numHeaderLines",
            numberofrecords: "numberOfRecords",
            numberofvolumes: "numberOfVolumes",
            numphysicallinesperrecord: "numPhysicalLinesPerRecord",
            objectname: "objectName",
            oldvalue: "oldValue",
            operatingsystem: "operatingSystem",
            orderattributereference: "orderAttributeReference",
            originalpublication: "originalPublication",
            otherentity: "otherEntity",
            othermaintenanceperiod: "otherMaintenancePeriod",
            parameterdefinition: "parameterDefinition",
            packageid: "packageId",
            pagerange: "pageRange",
            parentoccurences: "parentOccurences",
            parentsi: "parentSI",
            peakresponse: "peakResponse",
            personalcommunication: "personalCommunication",
            physicallinedelimiter: "physicalLineDelimiter",
            pointinpixel: "pointInPixel",
            preferredmembernode: "preferredMemberNode",
            preprocessingtypecode: "preProcessingTypeCode",
            primarykey: "primaryKey",
            primemeridian: "primeMeridian",
            proceduralstep: "proceduralStep",
            programminglanguage: "programmingLanguage",
            projcoordsys: "projCoordSys",
            projectionlist: "projectionList",
            propertyuri: "propertyURI",
            pubdate: "pubDate",
            pubplace: "pubPlace",
            publicationplace: "publicationPlace",
            quantitativeaccuracyreport: "quantitativeAccuracyReport",
            quantitativeaccuracyvalue: "quantitativeAccuracyValue",
            quantitativeaccuracymethod: "quantitativeAccuracyMethod",
            quantitativeattributeaccuracyassessment:
              "quantitativeAttributeAccuracyAssessment",
            querystatement: "queryStatement",
            quotecharacter: "quoteCharacter",
            radiometricdataavailability: "radiometricDataAvailability",
            rasterorigin: "rasterOrigin",
            recommendedunits: "recommendedUnits",
            recommendedusage: "recommendedUsage",
            referencedkey: "referencedKey",
            referencetype: "referenceType",
            relatedentry: "relatedEntry",
            relationshiptype: "relationshipType",
            reportnumber: "reportNumber",
            reprintedition: "reprintEdition",
            researchproject: "researchProject",
            researchtopic: "researchTopic",
            recorddelimiter: "recordDelimiter",
            referencepublication: "referencePublication",
            revieweditem: "reviewedItem",
            rowcolumnorientation: "rowColumnOrientation",
            runtimememoryusage: "runtimeMemoryUsage",
            samplingdescription: "samplingDescription",
            scalefactor: "scaleFactor",
            sequenceidentifier: "sequenceIdentifier",
            semiaxismajor: "semiAxisMajor",
            shortname: "shortName",
            simpledelimited: "simpleDelimited",
            spatialraster: "spatialRaster",
            spatialreference: "spatialReference",
            spatialvector: "spatialVector",
            standalone: "standAlone",
            standardunit: "standardUnit",
            startcondition: "startCondition",
            studyareadescription: "studyAreaDescription",
            storagetype: "storageType",
            studyextent: "studyExtent",
            studytype: "studyType",
            textdelimited: "textDelimited",
            textdomain: "textDomain",
            textfixed: "textFixed",
            textformat: "textFormat",
            topologylevel: "topologyLevel",
            tonegradation: "toneGradation",
            totaldigits: "totalDigits",
            totalfigures: "totalFigures",
            totalpages: "totalPages",
            totaltables: "totalTables",
            triangulationindicator: "triangulationIndicator",
            typesystem: "typeSystem",
            uniquekey: "uniqueKey",
            unittype: "unitType",
            unitlist: "unitList",
            usagecitation: "usageCitation",
            valueuri: "valueURI",
            valueattributereference: "valueAttributeReference",
            verticalaccuracy: "verticalAccuracy",
            vertcoordsys: "vertCoordSys",
            virtualmachine: "virtualMachine",
            wavelengthunits: "waveLengthUnits",
            whitespace: "whiteSpace",
            xintercept: "xIntercept",
            xcoordinate: "xCoordinate",
            "xsi:schemalocation": "xsi:schemaLocation",
            xslope: "xSlope",
            ycoordinate: "yCoordinate",
            yintercept: "yIntercept",
            yslope: "ySlope",
          },
        );
      },

      /**
       * Fetch the EML from the MN object service
       * @param {object} [options] - A set of options for this fetch()
       * @property {boolean} [options.systemMetadataOnly=false] - If true, only
       * the system metadata will be fetched. If false, the system metadata AND
       * EML document will be fetched.
       */
      fetch(options) {
        if (!options) var options = {};

        // Add the authorization header and other AJAX settings
        _.extend(options, MetacatUI.appUserModel.createAjaxSettings(), {
          dataType: "text",
        });

        // Merge the system metadata into the object first
        _.extend(options, { merge: true });
        this.fetchSystemMetadata(options);

        // If we are retrieving system metadata only, then exit now
        if (options.systemMetadataOnly) return;

        // Call Backbone.Model.fetch to retrieve the info
        return Backbone.Model.prototype.fetch.call(this, options);
      },

      /*
         Deserialize an EML 2.1.1 XML document
        */
      parse(response) {
        // Save a reference to this model for use in setting the parentModel
        // inside anonymous functions
        const model = this;

        // If the response is XML
        if (typeof response === "string" &amp;&amp; response.indexOf("&lt;") == 0) {
          // Look for a system metadata tag and call DataONEObject parse instead
          if (response.indexOf("systemMetadata>") > -1)
            return DataONEObject.prototype.parse.call(this, response);

          response = this.cleanUpXML(response);
          response = this.dereference(response);
          this.set("objectXML", response);
          var emlElement = $($.parseHTML(response)).filter("eml\\:eml");
        }

        let datasetEl;
        if (emlElement[0]) datasetEl = $(emlElement[0]).find("dataset");

        if (!datasetEl || !datasetEl.length) return {};

        const emlParties = [
          "metadataprovider",
          "associatedparty",
          "creator",
          "contact",
          "publisher",
        ];
        const emlDistribution = ["distribution"];
        const emlText = ["abstract", "additionalinfo"];
        const emlMethods = ["methods"];

        const nodes = datasetEl.children();
        const modelJSON = {};

        for (let i = 0; i &lt; nodes.length; i++) {
          const thisNode = nodes[i];
          const convertedName =
            this.nodeNameMap()[thisNode.localName] || thisNode.localName;

          // EML Party modules are stored in EMLParty models
          if (_.contains(emlParties, thisNode.localName)) {
            if (thisNode.localName == "metadataprovider")
              var attributeName = "metadataProvider";
            else if (thisNode.localName == "associatedparty")
              var attributeName = "associatedParty";
            else var attributeName = thisNode.localName;

            if (typeof modelJSON[attributeName] === "undefined")
              modelJSON[attributeName] = [];

            modelJSON[attributeName].push(
              new EMLParty({
                objectDOM: thisNode,
                parentModel: model,
                type: attributeName,
              }),
            );
          }
          // EML Distribution modules are stored in EMLDistribution models
          else if (_.contains(emlDistribution, thisNode.localName)) {
            if (typeof modelJSON[thisNode.localName] === "undefined")
              modelJSON[thisNode.localName] = [];

            modelJSON[thisNode.localName].push(
              new EMLDistribution(
                {
                  objectDOM: thisNode,
                  parentModel: model,
                },
                { parse: true },
              ),
            );
          }
          // The EML Project is stored in the EMLProject model
          else if (thisNode.localName == "project") {
            modelJSON.project = new EMLProject({
              objectDOM: thisNode,
              parentModel: model,
            });
          }
          // EML Temporal, Taxonomic, and Geographic Coverage modules are stored
          // in their own models
          else if (thisNode.localName == "coverage") {
            const temporal = $(thisNode).children("temporalcoverage");
            const geo = $(thisNode).children("geographiccoverage");
            const taxon = $(thisNode).children("taxonomiccoverage");

            if (temporal.length) {
              modelJSON.temporalCoverage = [];

              _.each(temporal, (t) => {
                modelJSON.temporalCoverage.push(
                  new EMLTemporalCoverage({
                    objectDOM: t,
                    parentModel: model,
                  }),
                );
              });
            }

            if (geo.length) {
              modelJSON.geoCoverage = [];
              _.each(geo, (g) => {
                modelJSON.geoCoverage.push(
                  new EMLGeoCoverage({
                    objectDOM: g,
                    parentModel: model,
                  }),
                );
              });
            }

            if (taxon.length) {
              modelJSON.taxonCoverage = [];
              _.each(taxon, (t) => {
                modelJSON.taxonCoverage.push(
                  new EMLTaxonCoverage({
                    objectDOM: t,
                    parentModel: model,
                  }),
                );
              });
            }
          }
          // Parse EMLText modules
          else if (_.contains(emlText, thisNode.localName)) {
            if (typeof modelJSON[convertedName] === "undefined")
              modelJSON[convertedName] = [];

            modelJSON[convertedName].push(
              new EMLText({
                objectDOM: thisNode,
                parentModel: model,
              }),
            );
          } else if (_.contains(emlMethods, thisNode.localName)) {
            if (typeof modelJSON[thisNode.localName] === "undefined")
              modelJSON[thisNode.localName] = [];

            modelJSON[thisNode.localName] = new EMLMethods({
              objectDOM: thisNode,
              parentModel: model,
            });
          }
          // Parse keywords
          else if (thisNode.localName == "keywordset") {
            // Start an array of keyword sets
            if (typeof modelJSON.keywordSets === "undefined")
              modelJSON.keywordSets = [];

            modelJSON.keywordSets.push(
              new EMLKeywordSet({
                objectDOM: thisNode,
                parentModel: model,
              }),
            );
          }
          // Parse intellectual rights
          else if (thisNode.localName == "intellectualrights") {
            let value = "";

            if ($(thisNode).children("para").length == 1)
              value = $(thisNode).children("para").first().text().trim();
            else $(thisNode).text().trim();

            // If the value is one of our pre-defined options, then add it to
            // the model if(_.contains(this.get("intellRightsOptions"), value))
            modelJSON.intellectualRights = value;
          }
          // Parse dataset-level annotations
          else if (thisNode.localName === "annotation") {
            if (!modelJSON.annotations) {
              modelJSON.annotations = new EMLAnnotations();
            }

            const annotationModel = new EMLAnnotation(
              {
                objectDOM: thisNode,
              },
              { parse: true },
            );

            modelJSON.annotations.add(annotationModel);
          } else {
            // Is this a multi-valued field in EML?
            if (Array.isArray(this.get(convertedName))) {
              // If we already have a value for this field, then add this value
              // to the array
              if (Array.isArray(modelJSON[convertedName]))
                modelJSON[convertedName].push(this.toJson(thisNode));
              // If it's the first value for this field, then create a new array
              else modelJSON[convertedName] = [this.toJson(thisNode)];
            } else modelJSON[convertedName] = this.toJson(thisNode);
          }
        }

        // Find &amp; parse all of the entities in the dataset
        modelJSON.entities = new EMLEntities(
          { parentModel: model, datasetNode: datasetEl.get(0) },
          { parse: true },
        );

        // Once all the nodes have been parsed, check if any of the annotations
        // make up a canonical dataset reference
        const { annotations } = modelJSON;
        if (annotations) {
          const canonicalDataset = annotations.getCanonicalURI();
          if (canonicalDataset) {
            modelJSON.canonicalDataset = canonicalDataset;
          }
        }

        return modelJSON;
      },

      /*
       * Retireves the model attributes and serializes into EML XML, to produce
       * the new or modified EML document. Returns the EML XML as a string.
       */
      serialize() {
        // Get the EML document
        const xmlString = this.get("objectXML");
        const html = $.parseHTML(xmlString);
        let eml = $(html).filter("eml\\:eml");
        const datasetNode = $(eml).find("dataset");

        // Update the packageId on the eml node with the EML id
        $(eml).attr("packageId", this.get("id"));

        // Set id attribute on dataset node if needed
        if (this.get("xmlID")) {
          $(datasetNode).attr("id", this.get("xmlID"));
        }

        // Set schema version
        $(eml).attr(
          "xmlns:eml",
          MetacatUI.appModel.get("editorSerializationFormat") ||
            "https://eml.ecoinformatics.org/eml-2.2.0",
        );

        // Set formatID
        this.set(
          "formatId",
          MetacatUI.appModel.get("editorSerializationFormat") ||
            "https://eml.ecoinformatics.org/eml-2.2.0",
        );

        // Ensure xsi:schemaLocation has a value for the current format
        eml = this.setSchemaLocation(eml);

        const nodeNameMap = this.nodeNameMap();

        // Serialize the basic text fields
        const basicText = ["alternateIdentifier", "title", "shortName"];
        _.each(
          basicText,
          function (fieldName) {
            let basicTextValues = this.get(fieldName);

            if (!Array.isArray(basicTextValues))
              basicTextValues = [basicTextValues];

            // Remove existing nodes
            datasetNode.children(fieldName.toLowerCase()).remove();

            // Create new nodes
            const nodes = _.map(basicTextValues, (value) => {
              if (value) {
                const node = document.createElement(fieldName.toLowerCase());
                $(node).text(value);
                return node;
              }
              return "";
            });

            const insertAfter = this.getEMLPosition(
              eml,
              fieldName.toLowerCase(),
            );

            if (insertAfter) {
              insertAfter.after(nodes);
            } else {
              datasetNode.prepend(nodes);
            }
          },
          this,
        );

        // Serialize pubDate This one is special because it has a default
        // behavior, unlike the others: When no pubDate is set, it should be set
        // to the current year
        const pubDate = this.get("pubDate");

        datasetNode.find("pubdate").remove();

        if (pubDate != null &amp;&amp; pubDate.length > 0) {
          const pubDateEl = document.createElement("pubdate");

          $(pubDateEl).text(pubDate);

          this.getEMLPosition(eml, "pubdate").after(pubDateEl);
        }

        // Serialize the parts of EML that are eml-text modules
        const textFields = ["abstract", "additionalInfo"];

        _.each(
          textFields,
          function (field) {
            const fieldName = this.nodeNameMap()[field] || field;

            // Get the EMLText model
            const emlTextModels = Array.isArray(this.get(field))
              ? this.get(field)
              : [this.get(field)];
            if (!emlTextModels.length) return;

            // Get the node from the EML doc
            const nodes = datasetNode.find(fieldName);

            // Update the DOMs for each model
            _.each(
              emlTextModels,
              function (thisTextModel, i) {
                // Don't serialize falsey values
                if (!thisTextModel) return;

                let node;

                // Get the existing node or create a new one
                if (nodes.length &lt; i + 1) {
                  node = document.createElement(fieldName);
                  this.getEMLPosition(eml, fieldName).after(node);
                } else {
                  node = nodes[i];
                }

                $(node).html($(thisTextModel.updateDOM()).html());
              },
              this,
            );

            // Remove the extra nodes
            this.removeExtraNodes(nodes, emlTextModels);
          },
          this,
        );

        // Create a &lt;coverage> XML node if there isn't one
        if (datasetNode.children("coverage").length === 0) {
          var coverageNode = $(document.createElement("coverage"));
          const coveragePosition = this.getEMLPosition(eml, "coverage");

          if (coveragePosition) coveragePosition.after(coverageNode);
          else datasetNode.append(coverageNode);
        } else {
          var coverageNode = datasetNode.children("coverage").first();
        }

        // Serialize the geographic coverage
        if (
          typeof this.get("geoCoverage") !== "undefined" &amp;&amp;
          this.get("geoCoverage").length > 0
        ) {
          // Don't serialize if geoCoverage is invalid
          const validCoverages = _.filter(this.get("geoCoverage"), (cov) =>
            cov.isValid(),
          );

          // Get the existing geo coverage nodes from the EML
          const existingGeoCov = datasetNode.find("geographiccoverage");

          // Update the DOM of each model
          _.each(
            validCoverages,
            (cov, position) => {
              // Update the existing node if it exists
              if (existingGeoCov.length - 1 >= position) {
                $(existingGeoCov[position]).replaceWith(cov.updateDOM());
              }
              // Or, append new nodes
              else {
                const insertAfter = existingGeoCov.length
                  ? datasetNode.find("geographiccoverage").last()
                  : null;

                if (insertAfter) insertAfter.after(cov.updateDOM());
                else coverageNode.append(cov.updateDOM());
              }
            },
            this,
          );

          // Remove existing taxon coverage nodes that don't have an
          // accompanying model
          this.removeExtraNodes(
            datasetNode.find("geographiccoverage"),
            validCoverages,
          );
        } else {
          // If there are no geographic coverages, remove the nodes
          coverageNode.children("geographiccoverage").remove();
        }

        // Serialize the taxonomic coverage
        if (
          typeof this.get("taxonCoverage") !== "undefined" &amp;&amp;
          this.get("taxonCoverage").length > 0
        ) {
          // Group the taxonomic coverage models into empty and non-empty
          const sortedTaxonModels = _.groupBy(
            this.get("taxonCoverage"),
            (t) => {
              if (_.flatten(t.get("taxonomicClassification")).length > 0) {
                return "notEmpty";
              }
              return "empty";
            },
          );

          // Get the existing taxon coverage nodes from the EML
          const existingTaxonCov = coverageNode.children("taxonomiccoverage");

          // Iterate over each taxon coverage and update it's DOM
          if (
            sortedTaxonModels.notEmpty &amp;&amp;
            sortedTaxonModels.notEmpty.length > 0
          ) {
            // Update the DOM of each model
            _.each(sortedTaxonModels.notEmpty, (taxonCoverage, position) => {
              // Update the existing taxonCoverage node if it exists
              if (existingTaxonCov.length - 1 >= position) {
                $(existingTaxonCov[position]).replaceWith(
                  taxonCoverage.updateDOM(),
                );
              }
              // Or, append new nodes
              else {
                coverageNode.append(taxonCoverage.updateDOM());
              }
            });

            // Remove existing taxon coverage nodes that don't have an
            // accompanying model
            this.removeExtraNodes(existingTaxonCov, this.get("taxonCoverage"));
          }
          // If all the taxon coverages are empty, remove the parent
          // taxonomicCoverage node
          else if (
            !sortedTaxonModels.notEmpty ||
            sortedTaxonModels.notEmpty.length == 0
          ) {
            existingTaxonCov.remove();
          }
        }

        // Serialize the temporal coverage
        const existingTemporalCoverages = datasetNode.find("temporalcoverage");

        // Update the DOM of each model
        _.each(this.get("temporalCoverage"), (temporalCoverage, position) => {
          // Update the existing temporalCoverage node if it exists
          if (existingTemporalCoverages.length - 1 >= position) {
            $(existingTemporalCoverages[position]).replaceWith(
              temporalCoverage.updateDOM(),
            );
          }
          // Or, append new nodes
          else {
            coverageNode.append(temporalCoverage.updateDOM());
          }
        });

        // Remove existing taxon coverage nodes that don't have an accompanying
        // model
        this.removeExtraNodes(
          existingTemporalCoverages,
          this.get("temporalCoverage"),
        );

        // Remove the temporal coverage if it is empty
        if (!coverageNode.children("temporalcoverage").children().length) {
          coverageNode.children("temporalcoverage").remove();
        }

        // Remove the &lt;coverage> node if it's empty
        if (coverageNode.children().length == 0) {
          coverageNode.remove();
        }

        // Dataset-level annotations
        datasetNode.children("annotation").remove();

        if (this.get("annotations")) {
          this.get("annotations").each(function (annotation) {
            if (annotation.isEmpty()) {
              return;
            }

            const after = this.getEMLPosition(eml, "annotation");

            $(after).after(annotation.updateDOM());
          }, this);

          // Since there is at least one annotation, the dataset node needs to
          // have an id attribute.
          datasetNode.attr("id", this.getUniqueEntityId(this));
        }

        // If there is no creator, create one from the user
        if (!this.get("creator").length) {
          const party = new EMLParty({ parentModel: this, type: "creator" });

          party.createFromUser();

          this.set("creator", [party]);
        }

        // Serialize the creators
        this.serializeParties(eml, "creator");

        // Serialize the metadata providers
        this.serializeParties(eml, "metadataProvider");

        // Serialize the associated parties
        this.serializeParties(eml, "associatedParty");

        // Serialize the contacts
        this.serializeParties(eml, "contact");

        // Serialize the publishers
        this.serializeParties(eml, "publisher");

        // Serialize methods
        if (this.get("methods")) {
          // If the methods model is empty, remove it from the EML
          if (this.get("methods").isEmpty())
            datasetNode.find("methods").remove();
          else {
            // Serialize the methods model
            const methodsEl = this.get("methods").updateDOM();

            // If the methodsEl is an empty string or other falsey value, then
            // remove the methods node
            if (!methodsEl || !$(methodsEl).children().length) {
              datasetNode.find("methods").remove();
            } else {
              // Add the &lt;methods> node to the EML
              datasetNode.find("methods").detach();

              const insertAfter = this.getEMLPosition(eml, "methods");

              if (insertAfter) insertAfter.after(methodsEl);
              else datasetNode.append(methodsEl);
            }
          }
        }
        // If there are no methods, then remove the methods nodes
        else if (datasetNode.find("methods").length > 0) {
          datasetNode.find("methods").remove();
        }

        // Serialize the keywords
        this.serializeKeywords(eml, "keywordSets");

        // Serialize the intellectual rights
        if (this.get("intellectualRights")) {
          if (datasetNode.find("intellectualRights").length)
            datasetNode
              .find("intellectualRights")
              .html(`&lt;para>${this.get("intellectualRights")}&lt;/para>`);
          else {
            this.getEMLPosition(eml, "intellectualrights").after(
              $(document.createElement("intellectualRights")).html(
                `&lt;para>${this.get("intellectualRights")}&lt;/para>`,
              ),
            );
          }
        }

        // Serialize the distribution
        const distributions = this.get("distribution");
        if (distributions &amp;&amp; distributions.length > 0) {
          // Remove existing nodes
          datasetNode.children("distribution").remove();
          // Get the updated DOMs
          const distributionDOMs = distributions.map((d) => d.updateDOM());
          // Insert the updated DOMs in their correct positions
          distributionDOMs.forEach((dom, i) => {
            const insertAfter = this.getEMLPosition(eml, "distribution");
            if (insertAfter) {
              insertAfter.after(dom);
            } else {
              datasetNode.append(dom);
            }
          });
        }

        // Detach the project elements from the DOM
        if (datasetNode.find("project").length) {
          datasetNode.find("project").detach();
        }

        // If there is an EMLProject, update its DOM
        if (this.get("project")) {
          this.getEMLPosition(eml, "project").after(
            this.get("project").updateDOM(),
          );
        }

        // Serialize the entities
        this.get("entities").updateDatasetDOM(
          datasetNode.get(0), // Expects a DOM node not a jQuery object
          eml,
        );

        // Do a final check to make sure there are no duplicate ids in the EML
        const elementsWithIDs = $(eml).find("[id]");
        // Get an array of all the ids in this EML doc
        const allIDs = _.map(elementsWithIDs, (el) => $(el).attr("id"));

        // If there is at least one id in the EML...
        if (allIDs &amp;&amp; allIDs.length) {
          // Boil the array down to just the unique values
          const uniqueIDs = _.uniq(allIDs);

          // If the unique array is shorter than the array of all ids, then
          // there is a duplicate somewhere
          if (uniqueIDs.length &lt; allIDs.length) {
            // For each element in the EML that has an id,
            _.each(elementsWithIDs, (el) => {
              // Get the id for this element
              const id = $(el).attr("id");

              // If there is more than one element in the EML with this id,
              if ($(eml).find(`[id='${id}']`).length > 1) {
                // And if it is not a unit node, which we don't want to change,
                if (!$(el).is("unit"))
                  // Then change the id attribute to a random uuid
                  $(el).attr("id", `urn-uuid-${uuid.v4()}`);
              }
            });
          }
        }

        // Camel-case the XML
        let emlString = "";
        _.each(
          html,
          function (rootEMLNode) {
            emlString += this.formatXML(rootEMLNode);
          },
          this,
        );

        return emlString;
      },

      /*
       * Given an EML DOM and party type, this function updated and/or adds the
       * EMLParties to the EML
       */
      serializeParties(eml, type) {
        // Remove the nodes from the EML for this party type
        $(eml).children("dataset").children(type.toLowerCase()).remove();

        // Serialize each party of this type
        _.each(
          this.get(type),
          function (party, i) {
            // Get the last node of this type to insert after
            let insertAfter = $(eml)
              .children("dataset")
              .children(type.toLowerCase())
              .last();

            // If there isn't a node found, find the EML position to insert
            // after
            if (!insertAfter.length) {
              insertAfter = this.getEMLPosition(eml, type);
            }

            // Update the DOM of the EMLParty
            const emlPartyDOM = party.updateDOM();

            // Make sure we don't insert empty EMLParty nodes into the EML
            if ($(emlPartyDOM).children().length) {
              // Insert the party DOM at the insert position
              if (insertAfter &amp;&amp; insertAfter.length)
                insertAfter.after(emlPartyDOM);
              // If an insert position still hasn't been found, then just append
              // to the dataset node
              else $(eml).find("dataset").append(emlPartyDOM);
            }
          },
          this,
        );

        // Create a certain parties from the current app user if none is given
        if (type == "contact" &amp;&amp; !this.get("contact").length) {
          // Get the creators
          const creators = this.get("creator");
          const contacts = [];

          _.each(
            creators,
            function (creator) {
              // Clone the creator model and add it to the contacts array
              const newModel = new EMLParty({ parentModel: this });
              newModel.set(creator.toJSON());
              newModel.set("type", type);

              contacts.push(newModel);
            },
            this,
          );

          this.set(type, contacts);

          // Call this function again to serialize the new models
          this.serializeParties(eml, type);
        }
      },

      serializeKeywords(eml) {
        // Remove all existing keywordSets before appending
        $(eml).find("dataset").find("keywordset").remove();

        if (this.get("keywordSets").length == 0) return;

        // Create the new keywordSets nodes
        const nodes = _.map(this.get("keywordSets"), (kwd) => kwd.updateDOM());

        this.getEMLPosition(eml, "keywordset").after(nodes);
      },

      /*
       * Remoes nodes from the EML that do not have an accompanying model (Were
       * probably removed from the EML by the user during editing)
       */
      removeExtraNodes(nodes, models) {
        // Remove the extra nodes
        const extraNodes = nodes.length - models.length;
        if (extraNodes > 0) {
          for (let i = models.length; i &lt; nodes.length; i++) {
            $(nodes[i]).remove();
          }
        }
      },

      /*
       * Saves the EML document to the server using the DataONE API
       */
      save(attributes, options) {
        // Validate before we try anything else
        if (!this.isValid()) {
          this.trigger("invalid");
          this.trigger("cancelSave");
          return false;
        }
        this.trigger("valid");

        this.setFileName();

        // Set the upload transfer as in progress
        this.set("uploadStatus", "p");

        // Reset the draftSaved attribute
        this.set("draftSaved", false);

        // Create the creator from the current user if none is provided
        if (!this.get("creator").length) {
          var party = new EMLParty({ parentModel: this, type: "creator" });

          party.createFromUser();

          this.set("creator", [party]);
        }

        // Create the contact from the current user if none is provided
        if (!this.get("contact").length) {
          var party = new EMLParty({ parentModel: this, type: "contact" });

          party.createFromUser();

          this.set("contact", [party]);
        }

        // If this is an existing object and there is no system metadata,
        // retrieve it
        if (!this.isNew() &amp;&amp; !this.get("sysMetaXML")) {
          var model = this;

          // When the system metadata is fetched, try saving again
          const fetchOptions = {
            success(response) {
              model.set(DataONEObject.prototype.parse.call(model, response));
              model.save(attributes, options);
            },
          };

          // Fetch the system metadata now
          this.fetchSystemMetadata(fetchOptions);

          return;
        }

        // Create a FormData object to send data with our XHR
        const formData = new FormData();

        try {
          // Add the identifier to the XHR data
          if (this.isNew()) {
            formData.append("pid", this.get("id"));
          } else {
            // Create a new ID
            this.updateID();

            // Add the ids to the form data
            formData.append("newPid", this.get("id"));
            formData.append("pid", this.get("oldPid"));
          }

          // Serialize the EML XML
          const xml = this.serialize();
          const xmlBlob = new Blob([xml], { type: "application/xml" });

          // Get the size of the new EML XML
          this.set("size", xmlBlob.size);

          // Get the new checksum of the EML XML
          const checksum = md5(xml);
          this.set("checksum", checksum);
          this.set("checksumAlgorithm", "MD5");

          // Create the system metadata XML
          const sysMetaXML = this.serializeSysMeta();

          // Send the system metadata as a Blob
          const sysMetaXMLBlob = new Blob([sysMetaXML], {
            type: "application/xml",
          });

          // Add the object XML and System Metadata XML to the form data Append
          // the system metadata first, so we can take advantage of Metacat's
          // streaming multipart handler
          formData.append("sysmeta", sysMetaXMLBlob, "sysmeta");
          formData.append("object", xmlBlob);
        } catch (error) {
          // Reset the identifier since we didn't actually update the object
          this.resetID();

          this.set("uploadStatus", "e");
          this.trigger("error");
          this.trigger("cancelSave");
          return false;
        }

        var model = this;
        const saveOptions = options || {};
        _.extend(
          saveOptions,
          {
            data: formData,
            cache: false,
            contentType: false,
            dataType: "text",
            processData: false,
            parse: false,
            // Use the URL function to determine the URL
            url: this.isNew() ? this.url() : this.url({ update: true }),
            xhr() {
              const xhr = new window.XMLHttpRequest();

              // Upload progress
              xhr.upload.addEventListener(
                "progress",
                (evt) => {
                  if (evt.lengthComputable) {
                    const percentComplete = (evt.loaded / evt.total) * 100;

                    model.set("uploadProgress", percentComplete);
                  }
                },
                false,
              );

              return xhr;
            },
            success(model, response, xhr) {
              model.set("numSaveAttempts", 0);
              model.set("uploadStatus", "c");
              model.set("sysMetaXML", model.serializeSysMeta());
              model.set("oldPid", null);
              model.fetch({ merge: true, systemMetadataOnly: true });
              model.trigger("successSaving", model);
            },
            error(model, response, xhr) {
              model.set("numSaveAttempts", model.get("numSaveAttempts") + 1);
              const numSaveAttempts = model.get("numSaveAttempts");

              // Reset the identifier changes
              model.resetID();

              if (
                numSaveAttempts &lt; 3 &amp;&amp;
                (response.status == 408 || response.status == 0)
              ) {
                // Try saving again in 10, 40, and 90 seconds
                setTimeout(
                  () => {
                    model.save.call(model);
                  },
                  numSaveAttempts * numSaveAttempts * 10000,
                );
              } else {
                model.set("numSaveAttempts", 0);

                // Get the error error information
                const errorDOM = $($.parseHTML(response.responseText));
                const errorContainer = errorDOM.filter("error");
                const msgContainer = errorContainer.length
                  ? errorContainer.find("description")
                  : errorDOM.not("style, title");
                let errorMsg = msgContainer.length
                  ? msgContainer.text()
                  : errorDOM;

                // When there is no network connection (status == 0), there will
                // be no response text
                if (!errorMsg || response.status == 408 || response.status == 0)
                  errorMsg =
                    "There was a network issue that prevented your metadata from uploading. " +
                    "Make sure you are connected to a reliable internet connection.";

                // Save the error message in the model
                model.set("errorMessage", errorMsg);

                // Set the model status as e for error
                model.set("uploadStatus", "e");

                // Save the EML as a plain text file, until drafts are a
                // supported feature
                const copy = model.createTextCopy();

                // If the EML copy successfully saved, let the user know that
                // there is a copy saved behind the scenes
                model.listenToOnce(copy, "successSaving", () => {
                  model.set("draftSaved", true);

                  // Trigger the errorSaving event so other parts of the app
                  // know that the model failed to save And send the error
                  // message with it
                  model.trigger("errorSaving", errorMsg);
                });

                // If the EML copy fails to save too, then just display the
                // usual error message
                model.listenToOnce(copy, "errorSaving", () => {
                  // Trigger the errorSaving event so other parts of the app
                  // know that the model failed to save And send the error
                  // message with it
                  model.trigger("errorSaving", errorMsg);
                });

                // Save the EML plain text copy
                copy.save();

                // Track the error
                MetacatUI.analytics?.trackException(
                  `EML save error: ${errorMsg}, EML draft: ${copy.get("id")}`,
                  model.get("id"),
                  true,
                );
              }
            },
          },
          MetacatUI.appUserModel.createAjaxSettings(),
        );

        return Backbone.Model.prototype.save.call(
          this,
          attributes,
          saveOptions,
        );
      },

      /*
       * Checks if this EML model has all the required values necessary to save
       * to the server
       */
      validate() {
        let errors = {};

        // A title is always required by EML
        if (!this.get("title").length || !this.get("title")[0]) {
          errors.title = "A title is required";
        }

        // Validate the publication date
        if (this.get("pubDate") != null) {
          if (!this.isValidYearDate(this.get("pubDate"))) {
            errors.pubDate = [
              `The value entered for publication date, '${this.get(
                "pubDate",
              )}' is not a valid value for this field. Enter with a year (e.g. 2017) or a date in the format YYYY-MM-DD.`,
            ];
          }
        }

        // Validate the temporal coverage
        errors.temporalCoverage = [];

        // If temporal coverage is required and there aren't any, return an
        // error
        if (
          MetacatUI.appModel.get("emlEditorRequiredFields").temporalCoverage &amp;&amp;
          !this.get("temporalCoverage").length
        ) {
          errors.temporalCoverage = [{ beginDate: "Provide a begin date." }];
        }
        // If temporal coverage is required and they are all empty, return an
        // error
        else if (
          MetacatUI.appModel.get("emlEditorRequiredFields").temporalCoverage &amp;&amp;
          _.every(this.get("temporalCoverage"), (tc) => tc.isEmpty())
        ) {
          errors.temporalCoverage = [{ beginDate: "Provide a begin date." }];
        }
        // If temporal coverage is not required, validate each one
        else if (
          this.get("temporalCoverage").length ||
          (MetacatUI.appModel.get("emlEditorRequiredFields").temporalCoverage &amp;&amp;
            _.every(this.get("temporalCoverage"), (tc) => tc.isEmpty()))
        ) {
          // Iterate over each temporal coverage and add it's validation errors
          _.each(this.get("temporalCoverage"), (temporalCoverage) => {
            if (!temporalCoverage.isValid() &amp;&amp; !temporalCoverage.isEmpty()) {
              errors.temporalCoverage.push(temporalCoverage.validationError);
            }
          });
        }

        // Remove the temporalCoverage attribute if no errors were found
        if (errors.temporalCoverage.length == 0) {
          delete errors.temporalCoverage;
        }

        // Validate the EMLParty models
        const partyTypes = [
          "associatedParty",
          "contact",
          "creator",
          "metadataProvider",
          "publisher",
        ];
        _.each(
          partyTypes,
          function (type) {
            const people = this.get(type);
            _.each(
              people,
              (person, i) => {
                if (!person.isValid()) {
                  if (!errors[type]) errors[type] = [person.validationError];
                  else errors[type].push(person.validationError);
                }
              },
              this,
            );
          },
          this,
        );

        // Validate the EMLGeoCoverage models
        _.each(
          this.get("geoCoverage"),
          (geoCoverageModel, i) => {
            if (!geoCoverageModel.isValid()) {
              if (!errors.geoCoverage)
                errors.geoCoverage = [geoCoverageModel.validationError];
              else errors.geoCoverage.push(geoCoverageModel.validationError);
            }
          },
          this,
        );

        // Validate the EMLTaxonCoverage model
        const taxonModel = this.get("taxonCoverage")[0];

        if (!taxonModel.isEmpty() &amp;&amp; !taxonModel.isValid()) {
          errors = _.extend(errors, taxonModel.validationError);
        } else if (
          taxonModel.isEmpty() &amp;&amp;
          this.get("taxonCoverage").length == 1 &amp;&amp;
          MetacatUI.appModel.get("emlEditorRequiredFields").taxonCoverage
        ) {
          taxonModel.isValid();
          errors = _.extend(errors, taxonModel.validationError);
        }

        const entityErrors = this.get("entities")?.validate();
        if (entityErrors?.length) {
          errors.entities = entityErrors;
        }

        // Validate the EML Methods
        const emlMethods = this.get("methods");
        if (emlMethods) {
          if (!emlMethods.isValid()) {
            errors.methods = emlMethods.validationError;
          }
        }

        // Validate the EMLAnnotation models, checking for the canonical dataset
        const annotations = this.get("annotations");
        const annotationErrors = annotations ? annotations.validate() : [];

        if (annotationErrors?.length) {
          errors.annotations = annotationErrors.filter(
            (e) => e.attr !== "canonicalDataset",
          );
          const canonicalError = annotationErrors.find(
            (e) => e.attr === "canonicalDataset",
          );
          if (canonicalError) {
            errors.canonicalDataset = canonicalError.message;
          }
        }

        // Check the required fields for this MetacatUI configuration
        for ([field, isRequired] of Object.entries(
          MetacatUI.appModel.get("emlEditorRequiredFields"),
        )) {
          // If it's not required, then go to the next field
          if (!isRequired) continue;

          if (field == "alternateIdentifier") {
            if (
              !this.get("alternateIdentifier").length ||
              _.every(
                this.get("alternateIdentifier"),
                (altId) => altId.trim() == "",
              )
            )
              errors.alternateIdentifier =
                "At least one alternate identifier is required.";
          } else if (field == "generalTaxonomicCoverage") {
            if (
              !this.get("taxonCoverage").length ||
              !this.get("taxonCoverage")[0].get("generalTaxonomicCoverage")
            )
              errors.generalTaxonomicCoverage =
                "Provide a description of the general taxonomic coverage of this data set.";
          } else if (field == "geoCoverage") {
            if (!this.get("geoCoverage").length)
              errors.geoCoverage = "At least one location is required.";
          } else if (field == "intellectualRights") {
            if (!this.get("intellectualRights"))
              errors.intellectualRights =
                "Select usage rights for this data set.";
          } else if (field == "studyExtentDescription") {
            if (
              !this.get("methods") ||
              !this.get("methods").get("studyExtentDescription")
            )
              errors.studyExtentDescription =
                "Provide a study extent description.";
          } else if (field == "samplingDescription") {
            if (
              !this.get("methods") ||
              !this.get("methods").get("samplingDescription")
            )
              errors.samplingDescription = "Provide a sampling description.";
          } else if (field == "temporalCoverage") {
            if (!this.get("temporalCoverage").length)
              errors.temporalCoverage =
                "Provide the date(s) for this data set.";
          } else if (field == "taxonCoverage") {
            if (!this.get("taxonCoverage").length)
              errors.taxonCoverage =
                "At least one taxa rank and value is required.";
          } else if (field == "keywordSets") {
            if (!this.get("keywordSets").length)
              errors.keywordSets = "Provide at least one keyword.";
          }
          // The EMLMethods model will validate itself for required fields, but
          // this is a rudimentary check to make sure the EMLMethods model was
          // created in the first place
          else if (field == "methods") {
            if (!this.get("methods"))
              errors.methods = "At least one method step is required.";
          } else if (field == "funding") {
            // Note: Checks for either the funding or award element. award
            // element is checked by the project's objectDOM for now until
            // EMLProject fully supports the award element
            if (
              !this.get("project") ||
              !(
                this.get("project").get("funding").length ||
                (this.get("project").get("objectDOM") &amp;&amp;
                  this.get("project").get("objectDOM").querySelectorAll &amp;&amp;
                  this.get("project").get("objectDOM").querySelectorAll("award")
                    .length > 0)
              )
            )
              errors.funding =
                "Provide at least one project funding number or name.";
          } else if (field == "abstract") {
            if (!this.get("abstract").length)
              errors.abstract = "Provide an abstract.";
          } else if (field == "dataSensitivity") {
            if (!this.getDataSensitivity()) {
              errors.dataSensitivity =
                "Pick the category that best describes the level of sensitivity or restriction of the data.";
            }
          }
          // If this is an EMLParty type, check that there is a party of this
          // type in the model
          else if (
            EMLParty.prototype.partyTypes
              .map((t) => t.dataCategory)
              .includes(field)
          ) {
            // If this is an associatedParty role
            if (EMLParty.prototype.defaults().roleOptions?.includes(field)) {
              if (
                !this.get("associatedParty")
                  ?.map((p) => p.get("roles"))
                  .flat()
                  .includes(field)
              ) {
                errors[field] =
                  `Provide information about the people or organization(s) in the role: ${
                    EMLParty.prototype.partyTypes.find(
                      (t) => t.dataCategory == field,
                    )?.label
                  }`;
              }
            } else if (!this.get(field)?.length) {
              errors[field] =
                `Provide information about the people or organization(s) in the role: ${
                  EMLParty.prototype.partyTypes.find(
                    (t) => t.dataCategory == field,
                  )?.label
                }`;
            }
          } else if (!this.get(field) || !this.get(field)?.length) {
            errors[field] = `Provide a ${field}.`;
          }
        }

        if (Object.keys(errors).length) return errors;
      },

      /* Returns a boolean for whether the argument 'value' is a valid value for
      EML's yearDate type which is used in a few places.

      Note that this method considers a zero-length String to be valid because
      the EML211.serialize() method will properly handle a null or zero-length
      String by serializing out the current year. */
      isValidYearDate(value) {
        return (
          value === "" ||
          /^\d{4}$/.test(value) ||
          /^\d{4}-\d{2}-\d{2}$/.test(value)
        );
      },

      /**
       * Sends an AJAX request to fetch the system metadata for this EML object.
       * Will not trigger a sync event since it does not use
       * Backbone.Model.fetch. Triggers a custom "sysMetaUpdated" event instead.
       * @param {object} options - options for the AJAX request
       * @param {Function} options.success - The success callback function
       * @param {Function} options.error - The error callback function
       * @since 2.32.1
       */
      fetchSystemMetadata(options = {}) {
        const model = this;
        const requestOptions = { ...options };
        const metaUrl = MetacatUI.appModel.get("metaServiceUrl");
        const id = encodeURIComponent(this.get("id"));
        const ajaxSettings = MetacatUI.appUserModel.createAjaxSettings();
        const { success, error } = requestOptions;

        // If there are callbacks in the options, merge them with the success
        // and error callbacks required for this function
        requestOptions.success = (response) => {
          this.set(DataONEObject.prototype.parse.call(this, response));
          model.trigger("sysMetaUpdated");
          if (typeof success === "function") success();
        };
        requestOptions.error = () => {
          this.trigger("error");
          if (typeof error === "function") error();
        };

        // Make the AJAX request
        const fetchOptions = {
          ...requestOptions,
          ...ajaxSettings,
          url: `${metaUrl}${id}`,
          dataType: "text",
        };

        $.ajax(fetchOptions);
      },

      /*
       * Returns the nofde in the given EML document that the given node type
       * should be inserted after
       *
       * Returns false if either the node is not found in the and this should be
       * handled by the caller.
       */
      getEMLPosition(eml, nodeName) {
        const nodeOrder = this.get("nodeOrder");
        const position = _.indexOf(nodeOrder, nodeName.toLowerCase());

        if (position == -1) {
          return false;
        }

        // Go through each node in the node list and find the position where
        // this node will be inserted after
        for (let i = position - 1; i >= 0; i--) {
          if ($(eml).find("dataset").children(nodeOrder[i]).length) {
            return $(eml).find("dataset").children(nodeOrder[i]).last();
          }
        }

        return false;
      },

      /*
       * Checks if this model has updates that need to be synced with the
       * server.
       */
      hasUpdates() {
        if (this.constructor.__super__.hasUpdates.call(this)) return true;

        // If nothing else has been changed, then this object hasn't had any
        // updates
        return false;
      },

      /**
       * Add an entity into the entities collection
       * @param {EMLOtherEntity | object} emlEntity The entity to add
       * @param {number} [position] The position to add the entity at in the
       * entities array. If not provided, the entity will be added to the end.
       */
      addEntity(emlEntity, position) {
        if (!emlEntity) return;
        // If no position, or if negative, add to the end.
        const entities = this.get("entities");
        const positionCorrected =
          position &lt; 0 ? entities.length : position || entities.length;
        entities.add(emlEntity, { at: positionCorrected });
      },

      /**
       * Remove an entity from the entities collection
       * @param {EMLOtherEntity} emlEntity The entity to remove
       */
      removeEntity(emlEntity) {
        if (!emlEntity) return;
        this.get("entities").remove(emlEntity);
      },

      /**
       * Find the entity model for a given DataONEObject model
       * @param {DataONEObject} dataONEObj - The DataONEObject model to find an
       * entity for
       * @returns {EMLOtherEntity|false} The entity model for the given
       * DataONEObject model or false if not found
       */
      getEntity(dataONEObj) {
        return this.get("entities").getByDataONEObject(
          dataONEObj,
          this.get("collections")?.[0],
        );
      },

      /**
       * Create an entity model for a given DataONEObject model and add it to the
       * entities collection
       * @param {DataONEObject} dataONEObject - The DataONEObject model to create
       * an entity for
       * @returns {EMLOtherEntity} The entity model created
       */
      createEntity(dataONEObject) {
        return this.get("entities").addFromDataONEObject(dataONEObject, {
          parentModel: this,
        });
      },

      /**
       * Creates an XML-safe identifier that is unique to this EML document,
       * based on the given DataONEObject model. It is intended for EML entity
       * nodes in particular.
       * @param {DataONEObject} dataONEObject - a DataONEObject model that this
       * EML documents
       * @returns {string} - an identifier string unique to this EML document
       */
      getUniqueEntityId(dataONEObject) {
        let uniqueId = "";

        uniqueId = dataONEObject.getXMLSafeID();

        // Get the EML string, if there is one, to check if this id already
        // exists
        const emlString = this.get("objectXML");

        // If this id already exists in the EML...
        if (emlString &amp;&amp; emlString.indexOf(` id="${uniqueId}"`)) {
          // Create a random uuid to use instead
          uniqueId = `urn-uuid-${uuid.v4()}`;
        }

        return uniqueId;
      },

      /*
       * removeParty - removes the given EMLParty model from this EML211 model's
       * attributes
       */
      removeParty(partyModel) {
        // The list of attributes this EMLParty might be stored in
        const possibleAttr = [
          "creator",
          "contact",
          "metadataProvider",
          "publisher",
          "associatedParty",
        ];

        // Iterate over each possible attribute
        _.each(
          possibleAttr,
          function (attr) {
            if (_.contains(this.get(attr), partyModel)) {
              this.set(attr, _.without(this.get(attr), partyModel));
            }
          },
          this,
        );
      },

      /**
       * Attempt to move a party one index forward within its sibling models
       * @param {EMLParty} partyModel: The EMLParty model we're moving
       * @param partyModel
       */
      movePartyUp(partyModel) {
        const possibleAttr = [
          "creator",
          "contact",
          "metadataProvider",
          "publisher",
          "associatedParty",
        ];

        // Iterate over each possible attribute
        _.each(
          possibleAttr,
          function (attr) {
            if (!_.contains(this.get(attr), partyModel)) {
              return;
            }
            // Make a clone because we're going to use splice
            const models = _.clone(this.get(attr));

            // Find the index of the model we're moving
            const index = _.findIndex(models, (m) => m === partyModel);

            if (index === 0) {
              // Already first
              return;
            }

            if (index === -1) {
              // Couldn't find the model
              return;
            }

            // Do the move using splice and update the model
            models.splice(index - 1, 0, models.splice(index, 1)[0]);
            this.set(attr, models);
            this.trigger(`change:${attr}`);
          },
          this,
        );
      },

      /**
       * Attempt to move a party one index forward within its sibling models
       * @param {EMLParty} partyModel: The EMLParty model we're moving
       * @param partyModel
       */
      movePartyDown(partyModel) {
        const possibleAttr = [
          "creator",
          "contact",
          "metadataProvider",
          "publisher",
          "associatedParty",
        ];

        // Iterate over each possible attribute
        _.each(
          possibleAttr,
          function (attr) {
            if (!_.contains(this.get(attr), partyModel)) {
              return;
            }
            // Make a clone because we're going to use splice
            const models = _.clone(this.get(attr));

            // Find the index of the model we're moving
            const index = _.findIndex(models, (m) => m === partyModel);

            if (index === -1) {
              // Couldn't find the model
              return;
            }

            // Figure out where to put the new model Leave it in the same place
            //   if the next index doesn't exist Move one forward if it does
            const newIndex = models.length &lt;= index + 1 ? index : index + 1;

            // Do the move using splice and update the model
            models.splice(newIndex, 0, models.splice(index, 1)[0]);
            this.set(attr, models);
            this.trigger(`change:${attr}`);
          },
          this,
        );
      },

      /*
       * Adds the given EMLParty model to this EML211 model in the appropriate
       * role array in the given position
       *
       * @param {EMLParty} - The EMLParty model to add @param {number} - The
       * position in the role array in which to insert this EMLParty @return
       * {boolean} - Returns true if the EMLParty was successfully added, false
       * if it was cancelled
       */
      addParty(partyModel, position) {
        // If the EMLParty model is empty, don't add it to the EML211 model
        if (partyModel.isEmpty()) return false;

        // Get the role of this EMLParty
        const role = partyModel.get("type") || "associatedParty";

        // If this model already contains this EMLParty, then exit
        if (_.contains(this.get(role), partyModel)) return false;

        if (typeof position === "undefined") {
          this.get(role).push(partyModel);
        } else {
          this.get(role).splice(position, 0, partyModel);
        }

        this.trigger(`change:${role}`);

        return true;
      },

      /**
       * getPartiesByType - Gets an array of EMLParty members that have a
       * particular party type or role.
       * @param {string} partyType - A string that represents either the role or
       * the party type. For example, "contact", "creator",
       * "principalInvestigator", etc.
       * @since 2.15.0
       */
      getPartiesByType(partyType) {
        try {
          if (!partyType) {
            return false;
          }
          const associatedPartyTypes = new EMLParty().get("roleOptions");
          const isAssociatedParty = associatedPartyTypes.includes(partyType);
          let parties = [];
          // For "contact", "creator", "metadataProvider", "publisher", each
          // party type has it's own array in the EML model
          if (!isAssociatedParty) {
            parties = this.get(partyType);
            // For "custodianSteward", "principalInvestigator",
            // "collaboratingPrincipalInvestigator", etc., party members are
            // listed in the EML model's associated parties array. Each
            // associated party's party type is indicated in the role attribute.
          } else {
            parties = _.filter(this.get("associatedParty"), (associatedParty) =>
              associatedParty.get("roles").includes(partyType),
            );
          }

          return parties;
        } catch (error) {
          console.log(
            `Error trying to find a list of party members in an EML model by type. Error details: ${error}`,
          );
        }
      },

      createUnits() {
        this.units.fetch();
      },

      /* Initialize the object XML for brand spankin' new EML objects */
      createXML() {
        let emlSystem = MetacatUI.appModel.get("emlSystem");
        emlSystem =
          !emlSystem || typeof emlSystem !== "string" ? "knb" : emlSystem;

        const xml =
          '&lt;eml:eml xmlns:eml="https://eml.ecoinformatics.org/eml-2.2.0">&lt;/eml:eml>';
        const eml = $($.parseHTML(xml));

        // Set base attributes
        eml.attr("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
        eml.attr("xmlns:stmml", "http://www.xml-cml.org/schema/stmml-1.1");
        eml.attr(
          "xsi:schemaLocation",
          "https://eml.ecoinformatics.org/eml-2.2.0 https://eml.ecoinformatics.org/eml-2.2.0/eml.xsd",
        );
        eml.attr("packageId", this.get("id"));
        eml.attr("system", emlSystem);

        // Add the dataset
        eml.append(document.createElement("dataset"));
        eml.find("dataset").append(document.createElement("title"));

        const emlString = $(document.createElement("div"))
          .append(eml.clone())
          .html();

        return emlString;
      },

      /*
          Replace elements named "source" with "sourced" due to limitations with
          using $.parseHTML() rather than $.parseXML()

          @param xmlString  The XML string to make the replacement in
      */
      cleanUpXML(xmlString) {
        xmlString.replace("&lt;source>", "&lt;sourced>");
        xmlString.replace("&lt;/source>", "&lt;/sourced>");

        return xmlString;
      },

      createTextCopy() {
        let emlDraftText = `EML draft for ${this.get("id")}(${this.get(
          "title",
        )}) by ${MetacatUI.appUserModel.get(
          "firstName",
        )} ${MetacatUI.appUserModel.get("lastName")}`;

        if (this.get("uploadStatus") == "e" &amp;&amp; this.get("errorMessage")) {
          emlDraftText += `. This EML had the following save error: \`${this.get(
            "errorMessage",
          )}\`   `;
        } else {
          emlDraftText += ":   ";
        }

        emlDraftText += this.serialize();

        const plainTextEML = new DataONEObject({
          formatId: "text/plain",
          fileName: `eml_draft_${
            MetacatUI.appUserModel.get("lastName") || ""
          }.txt`,
          uploadFile: new Blob([emlDraftText], { type: "plain/text" }),
          synced: true,
        });

        return plainTextEML;
      },

      /*
       * Cleans up the given text so that it is XML-valid by escaping reserved
       * characters, trimming white space, etc.
       *
       * @param {string} textString - The string to clean up @return {string} -
       * The cleaned up string
       */
      cleanXMLText(textString) {
        if (typeof textString !== "string") return;

        textString = textString.trim();

        // Check for XML/HTML elements
        _.each(textString.match(/&lt;\s*[^>]*>/g), (xmlNode) => {
          // Encode &lt;, >, and &lt;/ substrings
          let tagName = xmlNode.replace(/>/g, "&amp;gt;");
          tagName = tagName.replace(/&lt;/g, "&amp;lt;");

          // Replace the xmlNode in the full text string
          textString = textString.replace(xmlNode, tagName);
        });

        // Remove Unicode characters that are not valid XML characters Create a
        // regular expression that matches any character that is not a valid XML
        // character (see https://www.w3.org/TR/xml/#charsets)
        const invalidCharsRegEx =
          /[^\u0009\u000a\u000d\u0020-\uD7FF\uE000-\uFFFD]/g;
        textString = textString.replace(invalidCharsRegEx, "");

        return textString;
      },

      /*
          Dereference "reference" elements and replace them with a cloned copy
          of the referenced content

          @param xmlString  The XML string with reference elements to transform
      */
      dereference(xmlString) {
        let referencesList; // the array of references elements in the document
        let referencedID; // The id of the referenced element
        let referencesParentEl; // The parent of the given references element
        let referencedEl; // The referenced DOM to be copied

        const xmlDOM = $.parseXML(xmlString);
        referencesList = xmlDOM.getElementsByTagName("references");

        if (referencesList.length) {
          // Process each references elements
          _.each(
            referencesList,
            (referencesEl, index, referencesList) => {
              // Can't rely on the passed referencesEl since the list length
              // changes because of the remove() below. Reuse referencesList[0]
              // for every item: referencedID = $(referencesEl).text(); //
              // doesn't work
              referencesEl = referencesList[0];
              referencedID = $(referencesEl).text();
              referencesParentEl = $(referencesEl).parent()[0];
              if (typeof referencedID !== "undefined" &amp;&amp; referencedID != "") {
                referencedEl = xmlDOM.getElementById(referencedID);
                if (typeof referencedEl !== "undefined") {
                  // Clone the referenced element and replace the references
                  // element
                  const referencedClone = $(referencedEl).clone()[0];
                  $(referencesParentEl)
                    .children(referencesEl.localName)
                    .replaceWith($(referencedClone).children());
                  // $(referencesParentEl).append($(referencedClone).children());
                  $(referencesParentEl).attr("id", DataONEObject.generateId());
                }
              }
            },
            xmlDOM,
          );
        }
        return new XMLSerializer().serializeToString(xmlDOM);
      },

      /*
       * Uses the EML `title` to set the `fileName` attribute on this model.
       */
      setFileName() {
        let title = "";

        // Get the title from the metadata
        if (Array.isArray(this.get("title"))) {
          title = this.get("title")[0];
        } else if (typeof this.get("title") === "string") {
          title = this.get("title");
        }

        // Max title length
        const maxLength = 50;

        // trim the string to the maximum length
        let trimmedTitle = title.trim().substr(0, maxLength);

        // re-trim if we are in the middle of a word
        if (trimmedTitle.indexOf(" ") > -1) {
          trimmedTitle = trimmedTitle.substr(
            0,
            Math.min(trimmedTitle.length, trimmedTitle.lastIndexOf(" ")),
          );
        }

        // Replace all non alphanumeric characters with underscores and make
        // sure there isn't more than one underscore in a row
        trimmedTitle = trimmedTitle
          .replace(/[^a-zA-Z0-9]/g, "_")
          .replace(/_{2,}/g, "_");

        // Set the fileName on the model
        this.set("fileName", `${trimmedTitle}.xml`);
      },

      trickleUpChange() {
        if (
          !MetacatUI.rootDataPackage ||
          !MetacatUI.rootDataPackage.packageModel
        )
          return;

        // Mark the package as changed
        MetacatUI.rootDataPackage.packageModel.set("changed", true);
      },

      /**
       * Sets the xsi:schemaLocation attribute on the passed-in Element
       * depending on the application configuration.
       * @param {Element} eml: The root eml:eml element to modify
       * @param eml
       * @returns {Element} The element, possibly modified
       */
      setSchemaLocation(eml) {
        if (!MetacatUI || !MetacatUI.appModel) {
          return eml;
        }

        const current = $(eml).attr("xsi:schemaLocation");
        const format = MetacatUI.appModel.get("editorSerializationFormat");
        const location = MetacatUI.appModel.get("editorSchemaLocation");

        // Return now if we can't do anything anyway
        if (!format || !location) {
          return eml;
        }

        // Simply add if the attribute isn't present to begin with
        if (!current || typeof current !== "string") {
          $(eml).attr("xsi:schemaLocation", `${format} ${location}`);

          return eml;
        }

        // Don't append if it's already present
        if (current.indexOf(format) >= 0) {
          return eml;
        }

        $(eml).attr("xsi:schemaLocation", `${current} ${location}`);

        return eml;
      },

      createID() {
        this.set("xmlID", uuid.v4());
      },

      /**
       * Creates and adds an {@link EMLAnnotation} to this EML211 model with the
         given annotation data in JSON form.
       * @param {object} annotationData The attribute data to set on the new
         {@link EMLAnnotation}. See {@link EMLAnnotation#defaults} for
       * details on what attributes can be passed to the EMLAnnotation. In
         addition, there is an `elementName` property.
       * @property {string} [annotationData.elementName] The name of the EML
         Element that this annotation should be applied to. e.g. dataset,
         entity, attribute. Defaults to `dataset`. NOTE: Right now only dataset
         annotations are supported until more annotation editing is added to the
         EML Editor.
       * @property {boolean} [annotationData.allowDuplicates] If false, this
         annotation will replace all annotations already set with the same
         propertyURI.
       * By default, more than one annotation with a given propertyURI can be
         added (defaults to true)
       */
      addAnnotation(annotationData) {
        try {
          if (!annotationData || typeof annotationData !== "object") {
            return;
          }

          // If no element name is provided, default to the dataset element.
          let elementName = "";
          if (!annotationData.elementName) {
            elementName = "dataset";
          } else {
            elementName = annotationData.elementName;
          }
          // Remove the elementName property so it isn't set on the
          // EMLAnnotation model later.
          delete annotationData.elementName;

          // Check if duplicates are allowed
          const { allowDuplicates } = annotationData;
          delete annotationData.allowDuplicates;

          // Create a new EMLAnnotation model
          const annotation = new EMLAnnotation(annotationData);

          // Update annotations set on the dataset element
          if (elementName == "dataset") {
            let annotations = this.get("annotations");

            // If the current annotations set on the EML model are not in Array
            // form, change it to an array
            if (!annotations) {
              annotations = new EMLAnnotations();
            }

            if (allowDuplicates === false) {
              // Add the EMLAnnotation to the collection, making sure to remove
              // duplicates first
              annotations.replaceDuplicateWith(annotation);
            } else {
              annotations.add(annotation);
            }

            // Set the annotations and force the change to be recognized by the
            // model
            this.set("annotations", annotations, { silent: true });
            this.handleChange(this, { force: true });
          } else {
            /** @todo Add annotation support for other EML Elements */
          }
        } catch (e) {
          console.error("Could not add Annotation to the EML: ", e);
        }
      },

      /**
       * Finds annotations that are of the `data sensitivity` property from the
       * NCEAS SENSO ontology. Returns undefined if none are found. This
       * function returns EMLAnnotation models because the data sensitivity is
       * stored in the EML Model as EMLAnnotations and added to EML as semantic
       * annotations.
       * @returns {EMLAnnotation[]|undefined}
       */
      getDataSensitivity() {
        try {
          const annotations = this.get("annotations");
          if (annotations) {
            const found = annotations.where({
              propertyURI: this.get("dataSensitivityPropertyURI"),
            });
            if (found?.length) {
              return found;
            }
          }
          return undefined;
        } catch (e) {
          console.error("Failed to get Data Sensitivity from EML model: ", e);
          return undefined;
        }
      },

      /**
       * Checks if there is at least one taxon coverage model in the EML model
       * @returns {boolean} - True if there is at least one taxon coverage model
       * in the EML model
       * @since 2.33.0
       */
      hasTaxonomicCoverage() {
        const taxonCoverage = this.get("taxonCoverage");
        return (
          Array.isArray(taxonCoverage) &amp;&amp;
          taxonCoverage?.length > 0 &amp;&amp;
          taxonCoverage[0] instanceof EMLTaxonCoverage
        );
      },

      /**
       * Create a new taxon coverage model and add it to the EML model within an
       * array on the taxonCoverage attribute. If there is already a non-empty
       * array of taxon coverage models, this function will not add a new one
       * and will return false instead.
       * @param {boolean} [silent] - Whether to suppress the change event when
       * adding the taxon coverage model to the EML model
       * @returns {EMLTaxonCoverage[] | false} - The new EMLTaxonCoverage model
       * that was added to the EML model, or false if a new model was not added
       * @since 2.33.0
       */
      addTaxonomicCoverage(silent = false) {
        if (this.hasTaxonomicCoverage()) return false;
        const taxonCov = [
          new EMLTaxonCoverage({
            parentModel: this,
          }),
        ];
        this.set("taxonCoverage", taxonCov, { silent });
        return taxonCov;
      },
    },
  );

  return EML211;
});
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
