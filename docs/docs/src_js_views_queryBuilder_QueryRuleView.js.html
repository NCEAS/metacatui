<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>MetacatUI Dev Docs: Source: src/js/views/queryBuilder/QueryRuleView.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="/metacatui/assets/css/styles.css">
    <link type="text/css" rel="stylesheet" href="styles/style.css">
</head>

<body>

<nav id="nav">
    <a href="/">
      <div class="logo">
<svg class="cat" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="cat" class="svg-inline--fa fa-cat fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M290.59 192c-20.18 0-106.82 1.98-162.59 85.95V192c0-52.94-43.06-96-96-96-17.67 0-32 14.33-32 32s14.33 32 32 32c17.64 0 32 14.36 32 32v256c0 35.3 28.7 64 64 64h176c8.84 0 16-7.16 16-16v-16c0-17.67-14.33-32-32-32h-32l128-96v144c0 8.84 7.16 16 16 16h32c8.84 0 16-7.16 16-16V289.86c-10.29 2.67-20.89 4.54-32 4.54-61.81 0-113.52-44.05-125.41-102.4zM448 96h-64l-64-64v134.4c0 53.02 42.98 96 96 96s96-42.98 96-96V32l-64 64zm-72 80c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16zm80 0c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16z"></path></svg>

<svg width="459px" height="53px" viewBox="0 0 459 53" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="metacatui" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M16.492,52 C17.212,52 17.812,51.748 18.292,51.244 C18.772,50.74 19.012,50.128 19.012,49.408 L19.012,49.408 L18.94,22.912 L30.82,37.816 C31.204,38.344 31.72,38.764 32.368,39.076 C33.016,39.388 33.7,39.544 34.42,39.544 C35.908,39.544 37.132,38.896 38.092,37.6 L38.092,37.6 L49.684,22.912 L49.684,49.408 C49.684,50.128 49.96,50.74 50.512,51.244 C51.064,51.748 51.7,52 52.42,52 L52.42,52 L62.068,52 C62.788,52 63.388,51.748 63.868,51.244 C64.348,50.74 64.588,50.128 64.588,49.408 L64.588,49.408 L64.588,4.12 C64.588,3.448 64.336,2.86 63.832,2.356 C63.328,1.852 62.74,1.6 62.068,1.6 L62.068,1.6 L52.348,1.6 C51.388,1.6 50.56,1.648 49.864,1.744 C49.168,1.84 48.532,2.152 47.956,2.68 L47.956,2.68 L33.916,17.296 L20.524,2.608 C20.332,2.368 19.972,2.14 19.444,1.924 C18.916,1.708 18.412,1.6 17.932,1.6 L17.932,1.6 L6.772,1.6 C6.052,1.6 5.44,1.852 4.936,2.356 C4.432,2.86 4.18,3.448 4.18,4.12 L4.18,4.12 L4.18,49.408 C4.18,50.08 4.432,50.68 4.936,51.208 C5.44,51.736 6.052,52 6.772,52 L6.772,52 L16.492,52 Z M110.74,52 C111.556,52 112.264,51.676 112.864,51.028 C113.464,50.38 113.764,49.624 113.764,48.76 L113.764,48.76 L113.764,42.568 C113.764,41.608 113.464,40.828 112.864,40.228 C112.264,39.628 111.556,39.328 110.74,39.328 L110.74,39.328 L89.428,39.328 L89.428,32.92 L109.732,32.92 C110.5,32.92 111.184,32.596 111.784,31.948 C112.384,31.3 112.684,30.568 112.684,29.752 L112.684,29.752 L112.684,23.488 C112.684,22.576 112.384,21.82 111.784,21.22 C111.184,20.62 110.5,20.32 109.732,20.32 L109.732,20.32 L89.428,20.32 L89.428,14.488 L110.74,14.488 C111.508,14.488 112.204,14.164 112.828,13.516 C113.452,12.868 113.764,12.136 113.764,11.32 L113.764,11.32 L113.764,5.056 C113.764,4.144 113.464,3.388 112.864,2.788 C112.264,2.188 111.556,1.888 110.74,1.888 L110.74,1.888 L76.756,1.888 C75.94,1.888 75.232,2.188 74.632,2.788 C74.032,3.388 73.732,4.144 73.732,5.056 L73.732,5.056 L73.732,48.76 C73.732,49.624 74.032,50.38 74.632,51.028 C75.232,51.676 75.94,52 76.756,52 L76.756,52 L110.74,52 Z M147.604,52 C148.42,52 149.104,51.688 149.656,51.064 C150.208,50.44 150.484,49.672 150.484,48.76 L150.484,48.76 L150.484,16.216 L161.86,16.216 C162.676,16.216 163.396,15.904 164.02,15.28 C164.644,14.656 164.956,13.936 164.956,13.12 L164.956,13.12 L164.956,4.768 C164.956,4 164.644,3.316 164.02,2.716 C163.396,2.116 162.676,1.816 161.86,1.816 L161.86,1.816 L124.132,1.816 C123.22,1.816 122.464,2.104 121.864,2.68 C121.264,3.256 120.964,3.952 120.964,4.768 L120.964,4.768 L120.964,13.12 C120.964,13.936 121.264,14.656 121.864,15.28 C122.464,15.904 123.22,16.216 124.132,16.216 L124.132,16.216 L135.652,16.216 L135.148,48.832 C135.148,49.744 135.424,50.5 135.976,51.1 C136.528,51.7 137.212,52 138.028,52 L138.028,52 L147.604,52 Z M175.828,52 C176.836,52 177.676,51.82 178.348,51.46 C179.02,51.1 179.452,50.584 179.644,49.912 L179.644,49.912 L181.876,42.712 L197.932,42.712 L200.164,49.912 C200.356,50.584 200.8,51.1 201.496,51.46 C202.192,51.82 203.044,52 204.052,52 L204.052,52 L213.916,52 C215.836,51.712 216.796,50.704 216.796,48.976 C216.796,48.304 216.676,47.596 216.436,46.852 C216.196,46.108 216.052,45.616 216.004,45.376 L216.004,45.376 L199.876,4.84 C199.588,3.976 199.036,3.232 198.22,2.608 C197.404,1.984 196.372,1.648 195.124,1.6 L195.124,1.6 L184.756,1.6 C183.604,1.648 182.608,1.948 181.768,2.5 C180.928,3.052 180.292,3.832 179.86,4.84 L179.86,4.84 L163.876,45.376 C163.828,45.472 163.672,45.916 163.408,46.708 C163.144,47.5 163.012,48.304 163.012,49.12 C163.012,50.752 163.948,51.712 165.82,52 L165.82,52 L175.828,52 Z M195.34,30.544 L184.036,30.544 L189.652,13.624 L195.34,30.544 Z M245.38,53.08 C250.612,53.08 255.652,51.544 260.5,48.472 C261.22,47.944 261.58,47.296 261.58,46.528 C261.58,45.808 261.292,45.16 260.716,44.584 L260.716,44.584 L252.796,36.808 C252.364,36.376 251.836,36.16 251.212,36.16 C250.78,36.16 250.372,36.256 249.988,36.448 C248.356,37.12 246.796,37.456 245.308,37.456 C243.244,37.456 241.348,36.952 239.62,35.944 C237.892,34.936 236.512,33.58 235.48,31.876 C234.448,30.172 233.932,28.336 233.932,26.368 C233.932,24.352 234.436,22.504 235.444,20.824 C236.452,19.144 237.832,17.812 239.584,16.828 C241.336,15.844 243.244,15.352 245.308,15.352 C246.892,15.352 248.332,15.64 249.628,16.216 C250.012,16.408 250.444,16.504 250.924,16.504 C251.548,16.504 252.1,16.264 252.58,15.784 L252.58,15.784 L259.636,8.008 C260.164,7.384 260.428,6.76 260.428,6.136 C260.428,5.224 259.996,4.528 259.132,4.048 C254.86,1.552 250.276,0.304 245.38,0.304 C240.532,0.304 236.032,1.492 231.88,3.868 C227.728,6.244 224.44,9.448 222.016,13.48 C219.592,17.512 218.38,21.904 218.38,26.656 C218.38,31.408 219.592,35.812 222.016,39.868 C224.44,43.924 227.728,47.14 231.88,49.516 C236.032,51.892 240.532,53.08 245.38,53.08 Z M279.796,52 C280.804,52 281.644,51.82 282.316,51.46 C282.988,51.1 283.42,50.584 283.612,49.912 L283.612,49.912 L285.844,42.712 L301.9,42.712 L304.132,49.912 C304.324,50.584 304.768,51.1 305.464,51.46 C306.16,51.82 307.012,52 308.02,52 L308.02,52 L317.884,52 C319.804,51.712 320.764,50.704 320.764,48.976 C320.764,48.304 320.644,47.596 320.404,46.852 C320.164,46.108 320.02,45.616 319.972,45.376 L319.972,45.376 L303.844,4.84 C303.556,3.976 303.004,3.232 302.188,2.608 C301.372,1.984 300.34,1.648 299.092,1.6 L299.092,1.6 L288.724,1.6 C287.572,1.648 286.576,1.948 285.736,2.5 C284.896,3.052 284.26,3.832 283.828,4.84 L283.828,4.84 L267.844,45.376 C267.796,45.472 267.64,45.916 267.376,46.708 C267.112,47.5 266.98,48.304 266.98,49.12 C266.98,50.752 267.916,51.712 269.788,52 L269.788,52 L279.796,52 Z M299.308,30.544 L288.004,30.544 L293.62,13.624 L299.308,30.544 Z M352.588,52 C353.404,52 354.088,51.688 354.64,51.064 C355.192,50.44 355.468,49.672 355.468,48.76 L355.468,48.76 L355.468,16.216 L366.844,16.216 C367.66,16.216 368.38,15.904 369.004,15.28 C369.628,14.656 369.94,13.936 369.94,13.12 L369.94,13.12 L369.94,4.768 C369.94,4 369.628,3.316 369.004,2.716 C368.38,2.116 367.66,1.816 366.844,1.816 L366.844,1.816 L329.116,1.816 C328.204,1.816 327.448,2.104 326.848,2.68 C326.248,3.256 325.948,3.952 325.948,4.768 L325.948,4.768 L325.948,13.12 C325.948,13.936 326.248,14.656 326.848,15.28 C327.448,15.904 328.204,16.216 329.116,16.216 L329.116,16.216 L340.636,16.216 L340.132,48.832 C340.132,49.744 340.408,50.5 340.96,51.1 C341.512,51.7 342.196,52 343.012,52 L343.012,52 L352.588,52 Z M402.052,52.792 C408.1,52.792 412.912,51.628 416.488,49.3 C420.064,46.972 422.536,44.068 423.904,40.588 C425.272,37.108 425.932,33.424 425.884,29.536 C425.884,29.5309474 425.883967,29.5237673 425.8839,29.5144598 L425.883102,29.4330859 C425.879911,29.1480111 425.868211,28.3183158 425.848,26.944 C425.8294,25.6792 425.818008,22.91524 425.813823,18.65212 L425.813103,17.80828 C425.812997,17.66452 425.8129,17.5192 425.81281,17.37232 L425.812,3.904 C425.86,3.184 425.632,2.62 425.128,2.212 C424.624,1.804 423.916,1.6 423.004,1.6 L423.004,1.6 L413.428,1.6 C412.612,1.6 411.904,1.828 411.304,2.284 C410.704,2.74 410.404,3.28 410.404,3.904 L410.404,3.904 L410.26,27.808 C410.26,34.144 407.476,37.312 401.908,37.312 C399.076,37.312 396.832,36.412 395.176,34.612 C393.52,32.812 392.668,30.352 392.62,27.232 L392.62,27.232 L392.332,3.76 C392.332,3.088 392.068,2.56 391.54,2.176 C391.012,1.792 390.268,1.6 389.308,1.6 L389.308,1.6 L379.876,1.6 C378.244,1.6 377.428,2.32 377.428,3.76 L377.428,3.76 L377.5,28.816 C377.5,33.04 378.376,36.964 380.128,40.588 C381.88,44.212 384.592,47.152 388.264,49.408 C391.936,51.664 396.532,52.792 402.052,52.792 Z M449.284,52.144 C450.148,52.144 450.88,51.844 451.48,51.244 C452.08,50.644 452.38,49.84 452.38,48.832 L452.38,48.832 L452.38,4.912 C452.38,4 452.08,3.22 451.48,2.572 C450.88,1.924 450.148,1.6 449.284,1.6 L449.284,1.6 L439.42,1.6 C438.46,1.6 437.692,1.924 437.116,2.572 C436.54,3.22 436.252,4 436.252,4.912 L436.252,4.912 L436.252,48.832 C436.252,49.84 436.54,50.644 437.116,51.244 C437.692,51.844 438.46,52.144 439.42,52.144 L439.42,52.144 L449.284,52.144 Z" id="metacatui" fill="#FCBF49" fill-rule="nonzero"></path>
    </g>
</svg>
</logo>

    </a>
    <h3>Namespaces</h3><ul><li><a href="AppConfig.html">AppConfig</a></li><li><a href="MetacatUI.html">MetacatUI</a></li><li><a href="Utilities.html">Utilities</a></li></ul><h3>Classes</h3><ul><li class='category-heading' data-category='Collections'>Collections</li><li><a href="AccessPolicy.html">AccessPolicy</a></li><li><a href="Citations.html">Citations</a></li><li><a href="DataPackage.html">DataPackage</a></li><li><a href="Filters.html">Filters</a></li><li><a href="ObjectFormats.html">ObjectFormats</a></li><li><a href="QualityReport.html">QualityReport</a></li><li><a href="SolrResults.html">SolrResults</a></li><li><a href="Units.html">Units</a></li><li><a href="UserGroup.html">UserGroup</a></li><li class='category-heading' data-category='Collections/Bookkeeper'>Collections/Bookkeeper</li><li><a href="Quotas.html">Quotas</a></li><li><a href="Usages.html">Usages</a></li><li class='category-heading' data-category='Collections/QueryFields'>Collections/QueryFields</li><li><a href="QueryFields.html">QueryFields</a></li><li class='category-heading' data-category='Models'>Models</li><li><a href="AccessRule.html">AccessRule</a></li><li><a href="AppModel.html">AppModel</a></li><li><a href="Citation.html">Citation</a></li><li><a href="CollectionModel.html">CollectionModel</a></li><li><a href="DataONEObject.html">DataONEObject</a></li><li><a href="LookupModel.html">LookupModel</a></li><li><a href="Map.html">Map</a></li><li><a href="Metrics.html">Metrics</a></li><li><a href="QualityCheck.html">QualityCheck</a></li><li><a href="Search.html">Search</a></li><li><a href="SolrResult.html">SolrResult</a></li><li><a href="Stats.html">Stats</a></li><li class='category-heading' data-category='Models/Bookkeeper'>Models/Bookkeeper</li><li><a href="Quota.html">Quota</a></li><li><a href="Subscription.html">Subscription</a></li><li><a href="Usage.html">Usage</a></li><li class='category-heading' data-category='Models/Filters'>Models/Filters</li><li><a href="BooleanFilter.html">BooleanFilter</a></li><li><a href="ChoiceFilter.html">ChoiceFilter</a></li><li><a href="DateFilter.html">DateFilter</a></li><li><a href="Filter.html">Filter</a></li><li><a href="FilterGroup.html">FilterGroup</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="SpatialFilter.html">SpatialFilter</a></li><li><a href="ToggleFilter.html">ToggleFilter</a></li><li class='category-heading' data-category='Models/Formats'>Models/Formats</li><li><a href="ObjectFormat.html">ObjectFormat</a></li><li class='category-heading' data-category='Models/Metadata'>Models/Metadata</li><li><a href="ScienceMetadata.html">ScienceMetadata</a></li><li class='category-heading' data-category='Models/Metadata/EML211'>Models/Metadata/EML211</li><li><a href="EML211.html">EML211</a></li><li><a href="EMLAttribute.html">EMLAttribute</a></li><li><a href="EMLDataTable.html">EMLDataTable</a></li><li><a href="EMLEntity.html">EMLEntity</a></li><li><a href="EMLGeoCoverage.html">EMLGeoCoverage</a></li><li><a href="EMLMeasurementScale.html">EMLMeasurementScale</a></li><li><a href="EMLNonNumericDomain.html">EMLNonNumericDomain</a></li><li><a href="EMLNumericDomain.html">EMLNumericDomain</a></li><li><a href="EMLOtherEntity.html">EMLOtherEntity</a></li><li><a href="EMLParty.html">EMLParty</a></li><li><a href="EMLTemporalCoverage.html">EMLTemporalCoverage</a></li><li><a href="EMLUnit.html">EMLUnit</a></li><li class='category-heading' data-category='Models/Metadata/EML220'>Models/Metadata/EML220</li><li><a href="EMLText.html">EMLText</a></li><li class='category-heading' data-category='Models/Portals'>Models/Portals</li><li><a href="PortalImage.html">PortalImage</a></li><li><a href="PortalModel.html">PortalModel</a></li><li><a href="PortalSectionModel.html">PortalSectionModel</a></li><li class='category-heading' data-category='Models/QueryFields'>Models/QueryFields</li><li><a href="QueryField.html">QueryField</a></li><li class='category-heading' data-category='Router'>Router</li><li><a href="UIRouter.html">UIRouter</a></li><li class='category-heading' data-category='Views'>Views</li><li><a href="AccessPolicyView.html">AccessPolicyView</a></li><li><a href="AccessRuleView.html">AccessRuleView</a></li><li><a href="AppView.html">AppView</a></li><li><a href="CitationListView.html">CitationListView</a></li><li><a href="ColorPaletteView.html">ColorPaletteView</a></li><li><a href="DataCatalogViewWithFilters.html">DataCatalogViewWithFilters</a></li><li><a href="DataItemView.html">DataItemView</a></li><li><a href="DataPackageView.html">DataPackageView</a></li><li><a href="DraftsView.html">DraftsView</a></li><li><a href="EditCollectionView.html">EditCollectionView</a></li><li><a href="EditorView.html">EditorView</a></li><li><a href="GroupListView.html">GroupListView</a></li><li><a href="ImageUploaderView.html">ImageUploaderView</a></li><li><a href="MarkdownEditorView.html">MarkdownEditorView</a></li><li><a href="MarkdownView.html">MarkdownView</a></li><li><a href="MdqRunView.html">MdqRunView</a></li><li><a href="MetadataView.html">MetadataView</a></li><li><a href="MetricModalView.html">MetricModalView</a></li><li><a href="MetricsChartView.html">MetricsChartView</a></li><li><a href="MetricView.html">MetricView</a></li><li><a href="NavbarView.html">NavbarView</a></li><li><a href="RegisterCitationView.html">RegisterCitationView</a></li><li><a href="SignInView.html">SignInView</a></li><li><a href="TableEditorView.html">TableEditorView</a></li><li><a href="TOCView.html">TOCView</a></li><li><a href="UserView.html">UserView</a></li><li class='category-heading' data-category='Views/Filters'>Views/Filters</li><li><a href="BooleanFilterView.html">BooleanFilterView</a></li><li><a href="ChoiceFilterView.html">ChoiceFilterView</a></li><li><a href="DateFilterView.html">DateFilterView</a></li><li><a href="FilterGroupsView.html">FilterGroupsView</a></li><li><a href="FilterGroupView.html">FilterGroupView</a></li><li><a href="FilterView.html">FilterView</a></li><li><a href="NumericFilterView.html">NumericFilterView</a></li><li><a href="ToggleFilterView.html">ToggleFilterView</a></li><li class='category-heading' data-category='Views/Metadata'>Views/Metadata</li><li><a href="EML211EditorView.html">EML211EditorView</a></li><li><a href="EMLAttributeView.html">EMLAttributeView</a></li><li><a href="EMLEntityView.html">EMLEntityView</a></li><li><a href="EMlGeoCoverageView.html">EMlGeoCoverageView</a></li><li><a href="EMLMeasurementScaleView.html">EMLMeasurementScaleView</a></li><li><a href="EMLMethodsView.html">EMLMethodsView</a></li><li><a href="EMLOtherEntityView.html">EMLOtherEntityView</a></li><li><a href="EMLPartyView.html">EMLPartyView</a></li><li><a href="EMLTempCoverageView.html">EMLTempCoverageView</a></li><li><a href="EMLView.html">EMLView</a></li><li><a href="ScienceMetadataView.html">ScienceMetadataView</a></li><li class='category-heading' data-category='Views/Portals'>Views/Portals</li><li><a href="PortalDataView.html">PortalDataView</a></li><li><a href="PortalHeaderView.html">PortalHeaderView</a></li><li><a href="PortalListView.html">PortalListView</a></li><li><a href="PortalLogosView.html">PortalLogosView</a></li><li><a href="PortalMembersView.html">PortalMembersView</a></li><li><a href="PortalSectionView.html">PortalSectionView</a></li><li><a href="PortalsSearchView.html">PortalsSearchView</a></li><li><a href="PortalUsagesView.html">PortalUsagesView</a></li><li><a href="PortalView.html">PortalView</a></li><li><a href="PortalVisualizationsView.html">PortalVisualizationsView</a></li><li class='category-heading' data-category='Views/Portals/Editor'>Views/Portals/Editor</li><li><a href="PortalEditorView.html">PortalEditorView</a></li><li><a href="PortEditorDataView.html">PortEditorDataView</a></li><li><a href="PortEditorImageView.html">PortEditorImageView</a></li><li><a href="PortEditorLogosView.html">PortEditorLogosView</a></li><li><a href="PortEditorMdSectionView.html">PortEditorMdSectionView</a></li><li><a href="PortEditorSectionsView.html">PortEditorSectionsView</a></li><li><a href="PortEditorSectionView.html">PortEditorSectionView</a></li><li><a href="PortEditorSettingsView.html">PortEditorSettingsView</a></li><li class='category-heading' data-category='Views/QueryBuilder'>Views/QueryBuilder</li><li><a href="QueryBuilderView.html">QueryBuilderView</a></li><li><a href="QueryRuleView.html">QueryRuleView</a></li><li class='category-heading' data-category='Views/SearchSelect'>Views/SearchSelect</li><li><a href="AccountSelectView.html">AccountSelectView</a></li><li><a href="AnnotationFilter.html">AnnotationFilter</a></li><li><a href="NodeSelect.html">NodeSelect</a></li><li><a href="ObjectFormatSelect.html">ObjectFormatSelect</a></li><li><a href="QueryFieldSelectView.html">QueryFieldSelectView</a></li><li><a href="SearchableSelectView.html">SearchableSelectView</a></li><li class='category-heading' data-category='Deprecated'>Deprecated</li><li><a href="ExternalView.html">ExternalView</a></li><li><a href="LogsSearch.html">LogsSearch</a></li></ul><h3>Global</h3><ul><li><a href="global.html#appConfigPath">appConfigPath</a></li></ul>
</nav>

<div id="main">

    <h1 class="page-title">Source: src/js/views/queryBuilder/QueryRuleView.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>define([
  "jquery",
  "underscore",
  "backbone",
  "views/searchSelect/SearchableSelectView",
  "views/searchSelect/QueryFieldSelectView",
  "views/searchSelect/NodeSelectView",
  "views/searchSelect/AccountSelectView",
  "views/filters/NumericFilterView",
  "views/filters/DateFilterView",
  "views/searchSelect/ObjectFormatSelectView",
  "views/searchSelect/AnnotationFilterView",
  "models/filters/Filter",
  "models/filters/BooleanFilter",
  "models/filters/NumericFilter",
  "models/filters/DateFilter"
],
  function (
    $, _, Backbone, SearchableSelect, QueryFieldSelect, NodeSelect, AccountSelect,
    NumericFilterView, DateFilterView, ObjectFormatSelect, AnnotationFilter, Filter, BooleanFilter,
    NumericFilter, DateFilter
  ) {

    /**
     * @class QueryRuleView
     * @classdesc A view that provides an UI for a user to construct a single filter that
     * is part of a complex query
     * @classcategory Views/QueryBuilder
     * @screenshot views/QueryRuleView.png
     * @extends Backbone.View
     * @constructor
     * @since 2.14.0
     */
    return Backbone.View.extend(
      /** @lends QueryRuleView.prototype */
      {
        /**
         * The type of View this is
         * @type {string}
         */
        type: "QueryRule",

        /**
         * The HTML class names for this view element
         * @type {string}
         */
        className: "query-rule",

        /**
         * The class to add to the rule number and other information on the left
         * @type {string}
         */
        ruleInfoClass: "rule-info",

        /**
         * The class to add to the field select element
         * @type {string}
         */
        fieldsClass: "field",

        /**
         * The class to add to the operator select element
         * @type {string}
         */
        operatorClass: "operator",

        /**
         * The class to add to the value select element
         * @type {string}
         */
        valuesClass: "value",

        /**
         * The class to add to the button that a user clicks to remove a rule
         * @type {string}
         */
        removeClass: "remove-rule",

        /**
         * The class to add to the view when a user hovers over the remove button
         * @type {string}
         */
        removePreviewClass: "remove-rule-preview",

        /**
         * An array of hex color codes used to help distinguish between different rules
         * @type {string[]}
         */
        ruleColorPalette: ["#44AA99", "#137733", "#c9a538", "#CC6677", "#882355",
          "#AA4499", "#332288"],

        /**
         * Search index fields to exclude in the metadata field selector
         * @type {string[]}
         */
        excludeFields: [],

        /**
         * A single Filter model that is part of a Filters collection, such as the
         * definition filters for a Collection or Portal or the filters for a Search
         * model. The Filter model must be part of a Filters collection (i.e. there must
         * be a model.collection property)
         * @type {Filter|BooleanFilter|NumericFilter|DateFilter}
         */
        model: undefined,

        /**
         * A function that creates and returns the Backbone events object.
         * @return {Object} Returns a Backbone events object
         */
        events: function () {
          var events = {};
          events["click ." + this.removeClass] = "removeSelf";
          events["mouseover ." + this.removeClass] = "previewRemove";
          events["mouseout ." + this.removeClass] = "previewRemove";
          return events
        },

        /**
         * A list of additional fields which are not retrieved from the query API, but
         * which should be added to the list of options. This can be used to add
         * abstracted fields which are a combination of multiple query fields, or to add a
         * duplicate field that has a different label. These special fields are passed on
         * to {@link QueryFieldSelectView#addFields}.
         *
         * @type {SpecialField[]}
         *
         * @since 2.15.0
         */
        specialFields: [
          {
            name: "documents-special-field",
            fields: ["documents"],
            label: "Contains Data Files",
            description: "Limit results to packages that include data files. Without" +
              " this rule, results may include packages with metadata but no data.",
            category: "General",
            values: ["*"]
          },
          {
            name: "year-data-collection",
            fields: ["beginDate", "endDate"],
            label: "Year of Data Collection",
            description: "The temporal range of content described by the metadata",
            category: "Dates"
          }
        ],

        /**
         * An operator option is an object that lists the properties of one of the
         * operators that will be displayed to the user in the Query Rule "operator"
         * dropdown list. The operator properties are used to pre-select the correct
         * operator based on attributes in the associated
         * {@link Filter#defaults Filter model}, as well as to update the Filter model
         * when a user selects a new operator. Operators can set the exclude and
         * matchSubstring properties of the model, and sometimes the values as well.
         * Either the types property OR the fields property must be set, not both.
         *
         * @typedef {Object} OperatorOption
         * @property {string} label - The label to display to the user
         * @property {string} icon - An icon that represents the operator
         * @property {boolean} matchSubstring - Whether the matchSubstring attribute is
         * true or false in the filter model that matches this operator
         * @property {boolean} exclude - Whether the exclude attribute is true or false in
         * the filter model that matches this operator
         * @property {boolean} hasMax - Whether the filter model that matches this
         * operator must have a max attribute
         * @property {boolean} hasMin - Whether the filter model that matches this
         * operator must have a min attribute
         * @property {string[]} values - For this operator to work as desired, the values
         * that should be set in the filter (e.g. ["true"] for the operator "is true")
         * @property {string[]} [types] - The node names of the filters that this operator
         * is used for (e.g. "filter", "booleanFilter")
         * @property {string[]} [fields] - The query field names of the filters that this
         * operator is used for. If this is used for a
         * {@link QueryRuleView#specialFields special field}, then list the special field
         * name (id), and not the real query field names. If this fields property is set,
         * then the types property will be ignored. (i.e. fields is more specific than
         * types.)
         */

        /**
         * The list of operators that will be available in the dropdown list that connects
         * the query fields to the values. Each operator must be unique.
         *
         * @type {OperatorOption[]}
         */
        operatorOptions: [
          {
            label: "is true",
            description: "The data package includes data files (and not only metadata)",
            icon: "ok-circle",
            matchSubstring: false,
            exclude: false,
            values: ["*"],
            fields: ["documents-special-field"]
          },
          {
            label: "is false",
            description: "The data package only contains metadata; it contains no data files.",
            icon: "ban-circle",
            matchSubstring: false,
            exclude: true,
            values: ["*"],
            fields: ["documents-special-field"]
          },
          {
            label: "equals",
            description: "The text in the metadata field is an exact match to the" +
              " selected value",
            icon: "equal",
            matchSubstring: false,
            exclude: false,
            types: ["filter"]
          },
          {
            label: "does not equal",
            description: "The text in the metadata field is anything except an exact" +
              " match to the selected value",
            icon: "not-equal",
            matchSubstring: false,
            exclude: true,
            types: ["filter"]
          },
          {
            label: "contains",
            description: "The text in the metadata field matches or contains the words" +
              " or phrase selected",
            icon: "ok-circle",
            matchSubstring: true,
            exclude: false,
            types: ["filter"]
          },
          {
            label: "does not contain",
            description: "The words or phrase selected are not contained within the" +
              " metadata field",
            icon: "ban-circle",
            matchSubstring: true,
            exclude: true,
            types: ["filter"]
          },
          {
            label: "is empty",
            description: "The metadata field contains no text or value",
            icon: "circle-blank",
            matchSubstring: false,
            exclude: true,
            values: ["*"],
            types: ["filter"]
          },
          {
            label: "is not empty",
            description: "The metadata field is filled in with any text at all",
            icon: "circle",
            matchSubstring: false,
            exclude: false,
            values: ["*"],
            types: ["filter"]
          },
          {
            label: "is true",
            description: "The metadata field is set to true",
            icon: "ok-circle",
            matchSubstring: false,
            exclude: false,
            values: [true],
            types: ["booleanFilter"]
          },
          {
            label: "is false",
            description: "The metadata field is set to false",
            icon: "ban-circle",
            matchSubstring: false,
            exclude: false,
            values: [false],
            types: ["booleanFilter"]
          },
          {
            label: "is between",
            description: "The metadata field is a value between the range selected" +
              " (inclusive of both values)",
            icon: "resize-horizontal",
            matchSubstring: false,
            exclude: false,
            hasMin: true,
            hasMax: true,
            types: ["numericFilter", "dateFilter"]
          },
          {
            label: "is less than or equal to",
            description: "The metadata field is a number less than the value selected",
            icon: "less-than-or-eq",
            matchSubstring: false,
            exclude: false,
            hasMin: false,
            hasMax: true,
            types: ["numericFilter"]
          },
          {
            label: "is greater than or equal to",
            description: "The metadata field is a number greater than the value selected",
            icon: "greater-than-or-eq",
            matchSubstring: false,
            exclude: false,
            hasMin: true,
            hasMax: false,
            types: ["numericFilter"]
          },
          {
            label: "is exactly",
            description: "The metadata field exactly equals the value selected",
            icon: "equal",
            matchSubstring: false,
            exclude: false,
            hasMin: false,
            hasMax: false,
            types: ["numericFilter"]
          },
          // TODO: The dateFilter model &amp; view need to be updated for these to work:
          // {
          //   label: "is during or before", icon: "less-than-or-eq", matchSubstring:
          //   false, exclude: false, hasMin: false, hasMax: true, types: ["dateFilter"]
          // },
          // {
          //   label: "is during or after", icon: "greater-than", matchSubstring: false,
          //   exclude: false, hasMin: true, hasMax: false, types: ["dateFilter"]
          // },
          // {
          //   label: "is in the year", icon: "equal", matchSubstring: false, exclude:
          //   false, hasMin: false, hasMax: false, types: ["dateFilter"]
          // }
        ],


        /**
         * The third input in each query rule is where the user enters a value, minimum,
         * or maximum for the filter model. Different types of values are appropriate for
         * different solr query fields, and so we display different interfaces depending
         * on the type and category of the selected query fields. A Value Input Option
         * object defines a of interface to show for a given type and category.
         *
         * @typedef {Object} ValueInputOption
         * @property {string[]} filterTypes - An array of one or more filter types that
         * are allowed for this interface.  If none are provided then any filter type is
         * allowed.
         * @property {string[]} categories - An array of one or more categories that are
         * allowed for this interface. These strings must exactly match the categories
         * provided in QueryField.categoriesMap(). If none are provided then any category
         * is allowed.
         * @property {string[]} queryFields - Specific names of fields that are allowed in
         * this interface. If none are provided, then any query fields are allowed that
         * match the other properties. If this value select should be used for a
         * {@link QueryRuleView#specialFields special field}, then use the name (id) of
         * the special field, not the actual query fields that it represents.
         * @property {string} label - If the interface does not include a label (e.g.
         * number filter), include a string to display here.
         * @property {function} uiFunction - A function that returns the UI view to use
         * with all appropriate options set. The function will be called with this view as
         * the context.
         */

        /**
         * This list defines which type of value input to show depending on filter type,
         * category, and query fields. The value input options are ordered from *most*
         * specific to *least*, since the first match will be selected. The filter model
         * must match either the queryFields, or both the filterTypes AND the categories
         * for a UI to be selected.
         * @type {ValueInputOption[]}
         */
        valueSelectUImap: [
          // serviceCoupling field
          {
            queryFields: ["serviceCoupling"],
            uiFunction: function () {
              return new SearchableSelect({
                options: [
                  {
                    label: "tight",
                    description: "Tight coupled service work only on the data described" +
                      " by this metadata document."
                  },
                  {
                    label: "mixed",
                    description: "Mixed coupling means service works on data described" +
                    " by this metadata document but may work on other data."
                  },
                  {
                    label: "loose",
                    description: "Loose coupling means service works on any data."
                  }
                ],
                allowMulti: true,
                allowAdditions: false,
                inputLabel: "Select a coupling",
                selected: this.model.get("values"),
                separatorText: this.model.get("operator")
              })
            }
          },
          // Metadata format IDs
          {
            queryFields: ["formatId"],
            uiFunction: function () {
              return new ObjectFormatSelect({
                selected: this.model.get("values"),
                separatorText: this.model.get("operator")
              })
            }
          },
          // Semantic annotation picker
          {
            queryFields: ["sem_annotation"],
            uiFunction: function () {
              // A bioportalAPIKey is required for the Annotation Filter UI
              if (MetacatUI.appModel.get("bioportalAPIKey")) {
                return new AnnotationFilter({
                  selected: this.model.get("values"),
                  separatorText: this.model.get("operator"),
                  multiselect: true
                });
                // If there's no API key, render the default UI (the last in this list)
              } else {
                return this.valueSelectUImap.slice(-1)[0].uiFunction.call(this);
              }
            }
          },
          // User/Organization account ID lookup
          {
            queryFields: ["writePermission", "readPermission", "changePermission", "rightsHolder", "submitter"],
            uiFunction: function () {
              return new AccountSelect({
                selected: this.model.get("values"),
                separatorText: this.model.get("operator")
              });
            },
          },
          // Repository picker for fields that need a member node ID
          {
            filterTypes: ["filter"],
            queryFields: ["blockedReplicationMN", "preferredReplicationMN", "replicaMN",
              "authoritativeMN", "datasource"],
            uiFunction: function () {
              return new NodeSelect({
                selected: this.model.get("values"),
                separatorText: this.model.get("operator")
              })
            }
          },
          // Any numeric fields don't fit one of the above options
          {
            filterTypes: ["numericFilter"],
            label: "Choose a value",
            uiFunction: function () {
              return new NumericFilterView({
                model: this.model,
                showButton: false,
                separatorText: this.model.get("operator")
              })
            }
          },
          // Any date fields that don't fit one of the above options
          {
            filterTypes: ["dateFilter"],
            label: "Choose a year",
            uiFunction: function () {
              return new DateFilterView({
                model: this.model,
                separatorText: this.model.get("operator")
              })
            }
          },
          // The last is the default value selection UI
          {
            uiFunction: function () {
              return new SearchableSelect({
                options: [],
                allowMulti: true,
                allowAdditions: true,
                inputLabel: "Type a value",
                selected: this.model.get("values"),
                separatorText: this.model.get("operator")
              })
            }
          }
        ],

        /**
         * Creates a new QueryRuleView
         * @param {Object} options - A literal object with options to pass to the view
         */
        initialize: function (options) {
          try {

            // Get all the options and apply them to this view
            if (typeof options == "object") {
              var optionKeys = Object.keys(options);
              _.each(optionKeys, function (key, i) {
                this[key] = options[key];
              }, this);
            }

            // If no model is provided in the options, we cannot render this view. A
            // filter model cannot be created, because it must be part of a collection.
            if (!this.model || !this.model.collection) {
              console.error("error: A Filter model that's part of a Filters collection"
                + " is required to initialize a Query Rule view.")
              return
            }

            // The model may be removed during the save process if it's empty. Remove this
            // Rule Group view when that happens.
            this.stopListening(this.model, "remove");
            this.listenTo(this.model, "remove", function () {
              this.removeSelf();
            });

          } catch (e) {
            console.log("Failed to initialize a Query Builder View, error message:", e);
          }
        },

        /**
         * render - Render the view
         *
         * @return {QueryRule}  Returns the view
         */
        render: function () {

          try {

            // TODO: How to indicate whether multiple fields/values are AND'ed or OR'ed
            // together?

            // Add the Rule number.
            // TODO: Also add the number of datasets related to rule
            this.addRuleInfo();
            this.stopListening(this.model.collection, "remove");
            this.listenTo(this.model.collection, "remove", this.updateRuleInfo);

            // Metadata Selector field Add a metadata selector field whether the rule is
            // new or has already been created
            this.addFieldSelect();

            // Operator field and value field Add an operator input only for already
            // existing filters (For new filters, a metadata field needs to be selected
            // first)
            if (
              this.model.get("fields") &amp;&amp;
              this.model.get("fields").length
            ) {
              this.addOperatorSelect();
              this.addValueSelect();
            }
            this.addRemoveButton();

            return this;

          } catch (e) {
            console.error("Error rendering the query Rule View, error message: ", e);
          }
        },

        /**
         * Insert container for the color-coded rule numbering.
         */
        addRuleInfo: function () {
          try {
            this.$indexEl = $(document.createElement("span"));
            this.$ruleInfoEl = $(document.createElement("div"))
              .addClass(this.ruleInfoClass);
            this.$ruleInfoEl.append(this.$indexEl);

            this.$el.append(this.$ruleInfoEl);
            this.updateRuleInfo();
          } catch (error) {
            console.log(
              "Error adding rule info container for a query rule, details: " + error
            );
          }
        },

        /**
         * Selects a color from the
         * {@link QueryRuleView#ruleColorPalette rule colour palette array}, given an
         * index. If the index is greater than the length of the palette, then the palette
         * is effectively repeated until long enough (i.e. colours will be recycled). If
         * no index in provided, the first colour in the palette will be selected.
         *
         * @param  {number} [index=0] - The position of the rule within the Filters
         * collection.
         * @param  {string} [defaultColor="#57b39c"] - A default colour to use in case
         * there is problem with this function (hex color code beginning with '#'). 
         * @return {string} - Returns a hex color code string
         */
        getPaletteColor: function (index = 0, defaultColor = "#57b39c") {
          try {
            if (!this.ruleColorPalette || !this.ruleColorPalette.length) {
              return defaultColor;
            }
            var numCols = this.ruleColorPalette.length;
            if ((index + 1) > numCols) {
              var n = Math.floor(index / numCols);
              index = index - (numCols * n);
            }
            return this.ruleColorPalette[index];
          } catch (error) {
            console.log(
              "Error getting a color for a query rule, using the default colour"
              + " instead. Error details: " + error
            );
            return defaultColor;
          }
        },

        /**
         * Adds or updates the color-coded query rule information displayed to the user.
         * This needs to be run when rules are added or removed. Rule information includes
         * the rule number, but may one day also display information such as the number of
         * results that there are for this individual rule.
         */
        updateRuleInfo: function () {
          try {
            var index = this.model.collection.visibleIndexOf(this.model);
            if (typeof index === "number") {
              this.$indexEl.text("Rule " + (index + 1));
            } else {
              this.$indexEl.text("");
              return
            }
            var color = this.getPaletteColor(index);
            if (color) {
              this.$ruleInfoEl[0].style.setProperty('--rule-color', color);
            }
          } catch (error) {
            console.log(
              "Error updating the rule numbering for a query rule. Details: " + error
            );
          }
        },

        /**
         * addRemoveButton - Create and insert the button to remove the query rule
         */
        addRemoveButton: function () {
          try {
            var removeButton = $(
              "&lt;i class='" + this.removeClass +
              " icon icon-remove' title='Remove this query rule'>&lt;/i>"
            );
            this.el.append(removeButton[0]);
          } catch (e) {
            console.error("Failed to , error message: " + e);
          }
        },
        
        /**
         * Determines whether the filter model that this rule renders matches one of the
         * {@link QueryRuleView#specialFields special fields} set on this view. If it
         * does, returns the first special field object that matches. For a filter model
         * to match to one of the special fields, it must contain all of the fields listed
         * in the special field's "fields" property. If the special field has an array set
         * for "values", then the model's values must also exactly match the special
         * field's values.
         *
         * @param  {string[]} [fields] - Optionally set a list of query fields to search
         * with. If not set, then the fields that are set on the view's filter model are
         * used.
         * @returns {SpecialField|null} - The matching special field, or null if no match
         * was found.
         *
         * @since 2.15.0
         */
        getSpecialField: function(fields){

            // Get information about the filter model (or used the fields passed to this
            // function)
            var selectedFields = fields || this.model.get("fields");
            var selectedFields = _.clone(selectedFields);
            var selectedValues = this.model.get("values");

            if(!this.specialFields || !Array.isArray(this.specialFields)){
              return null
            }
            
            var matchingSpecialField = _.find(this.specialFields, function(specialField){
              
              var fieldsMatch = false,
                  mustMatchValues = false,
                  valuesMatch = false;

              // If *all* the fields in the fields array are present in the list
              // of fields that the special field represents, then count this as a match.
              var commonFields = _.intersection(specialField.fields, selectedFields);
              if(commonFields.length === specialField.fields.length){
                fieldsMatch = true
              }
              
              // The selected value must *exactly match* if one is set in the special
              // field
              if(specialField.values){
                mustMatchValues = true;
                valuesMatch = _.isEqual(specialField.values, selectedValues)
              }

              return fieldsMatch &amp;&amp; (
                !mustMatchValues || (mustMatchValues &amp;&amp; valuesMatch)
              )
              
            }, this);

            // If this model matches one of the special fields, render it differently
            return matchingSpecialField || null
        },

        /**
         * Takes a list of query field names, checks if the model matches any of the
         * special fields, and if it does, returns the list of fields with the actual
         * field names replaced with the
         * {@link QueryRuleView#specialFields special field name}. This function is the
         * opposite of {@link QueryRuleView#convertFromSpecialFields}
         * @param  {string[]} fields - The list of field names to convert
         * @returns {string[]} - The converted list of field names. If there were no
         * special fields detected, or if there's an error, then then the field names are
         * returned unchanged.
         *
         * @param {string[]} fields - The list of fields to convert to special fields, if
         * the model matches any of the special field objects
         * @returns {string[]} - Returns the list of fields with actual query field names
         * replaced with special field names, if any match
         *
         * @since 2.15.0
         */
        convertToSpecialFields: function(fields){

          try {

            var fields = _.clone(fields);

            // Insert the special field name at the same position as the associated
            // query fields that we will remove
            var replaceWithSpecialField = function(fields, specialField){
              if(specialField){
                position = _.findIndex(fields, function(selectedField){
                  return specialField.fields.includes(selectedField);
                }, this);
                fields.splice(position, 0, specialField.name);
                fields = _.difference(fields, specialField.fields);
              }
              return fields
            }
            

            // If the user selected a special field, make sure we convert those first
            if( this.selectedSpecialFields &amp;&amp; this.selectedSpecialFields.length ){
              this.selectedSpecialFields.forEach(function(specialFiend){
                fields = replaceWithSpecialField(fields, specialFiend)
              }, this);
            }

            // Search for remaining special fields given the fields and model values
            var matchingSpecialField = this.getSpecialField(fields);

            // There may be more than one special field in the list of fields...
            while(matchingSpecialField !== null){
              fields = replaceWithSpecialField(fields, matchingSpecialField)
              // Check if there are more special fields remaining
              matchingSpecialField = this.getSpecialField(fields);

            }

            return fields;

          } catch (error) {
            console.log(
              "Error converting query field names to special field names in" +
              " a Query Rule View. Returning the list of fields unchanged." +
              " Error details : " + error
            );
            return fields
          }
          
        },

        /**
         * Takes a list of query field names and checks if it contains any of the
         * {@link QueryRuleView#specialFields special field names}. Returns the list with
         * the special field names replaced with the actual field names that those special
         * fields represent. Stores the name of each special field name removed in an
         * array set on the view's selectedSpecialFields property. selectedSpecialFields
         * is cleared each time this function runs. This function is the opposite of
         * {@link QueryRuleView#convertToSpecialFields}
         * @param  {string[]} fields] - The list of field names to convert
         * @returns {string[]} - The converted list of field names. If there were no
         * special fields detected, or if there's an error, then then the field names are
         * returned unchanged.
         *
         * @param {string[]} fields - The list of fields to convert to actual query
         * service index fields
         * @returns {string[]} - Returns the list of fields with any special field
         * replaced with real fields from the query service index
         *
         * @since 2.15.0
         */
        convertFromSpecialFields: function(fields){
          try {
            this.selectedSpecialFields = [];
            if(this.specialFields){
              this.specialFields.forEach(function(specialField){
                var index = fields.indexOf(specialField.name);
                if(index >= 0){
                  // Keep a record that the user selected a special field (useful in the
                  // case that the special field is just a duplicate of another field)
                  this.selectedSpecialFields.push(specialField);
                  fields.splice.apply(fields, [index, 1].concat(specialField.fields));
                }
              }, this);
            }
            return fields
          } catch (error) {
            console.log(
              "Error converting special query fields to query fields that" +
              " exist in the index in a Query Rule View. Returning the fields" +
              " unchanged. Error details: " + error
            );
            return fields
          }
        },

        /**
         * Create and insert an input that allows the user to select a metadata field to
         * query
         */
        addFieldSelect: function () {

          try {

            // Check whether the filter model set on this view contains query fields
            // and values that match one of the special rules. If it does,
            // convert the list of field names to special field to pass on to the
            // Query Field Select View.
            var selectedFields = _.clone(this.model.get("fields"));
            var selectedFields = this.convertToSpecialFields(selectedFields);

            this.fieldSelect = new QueryFieldSelect({
              selected: selectedFields,
              excludeFields: this.excludeFields,
              addFields: this.specialFields,
              separatorText: this.model.get("operator")
            });
            this.fieldSelect.$el.addClass(this.fieldsClass);
            this.el.append(this.fieldSelect.el);
            this.fieldSelect.render();

            // Update model when the values change
            this.stopListening(
              this.fieldSelect,
              'changeSelection'
            );
            this.listenTo(
              this.fieldSelect,
              'changeSelection',
              this.handleFieldChange
            );

          } catch (e) {
            console.error("Error adding a metadata selector input in the Query Rule"
              + " View, error message:", e);
          }
        },

        /**
         * handleFieldChange - Called when the Query Field Select View triggers a change
         * event. Updates the model with the new fields, and if required,
         * 1) converts the filter model to a different type based on the types of fields
         *    selected, 2) updates the operator select and the value select
         *
         * @param  {string[]} newFields The list of new query fields that were selected
         */
        handleFieldChange: function (newFields) {

          try {

            // Uncomment the following chunk to clear operator &amp; values when the field
            // input is cleared.
            // if(!newFields || newFields.length === 0 || newFields[0] === ""){
            //   if(this.operatorSelect){
            //     this.operatorSelect.changeSelection([""]);
            //   }
            //   this.model.set("fields", this.model.defaults().fields);
            //   return
            // }

            // Get the selected operator before the field changed
            var opBefore = this.getSelectedOperator();

            // If any of the new fields are special fields, replace them with the
            // actual query fields before setting them in the model...
            newFields = this.convertFromSpecialFields(newFields);

            // Get the current type of filter and required type given the newly selected
            // fields
            var typeBefore = this.model.get("nodeName"),
                typeAfter = this.getRequiredFilterType(newFields);

            // If the type has changed, then replace the model with one of the correct
            // type, update the value and operator inputs, and do nothing else
            if (typeBefore != typeAfter) {
              this.model = this.model.collection.replaceModel(
                this.model,
                { filterType: typeAfter, fields: newFields }
              );
              this.removeInput("value")
              this.removeInput("operator")
              this.addOperatorSelect("");
              return
            }

            // If the filter model type is the same, and the operator options are the same
            // for the selected fields, then update the model
            this.model.set("fields", newFields);

            // Get the selected operator now that we've updated the model with new fields
            var opAfter = this.getSelectedOperator();

            // Add an empty operator input field, if there isn't one
            if (!this.operatorSelect) {
              this.addOperatorSelect("");
            // If the operator options have changed, refresh the operator input
            } else if (opAfter !== opBefore){
              this.removeInput("operator");
              // Make sure that we overwrite any values that don't apply to the new options.
              this.handleOperatorChange([""]);
              this.addOperatorSelect("");
              return
            }

            // Refresh the value select in case a different value input is required for
            // the new fields
            if (this.valueSelect) {
              this.removeInput("value");
              this.addValueSelect();
            }

          } catch (e) {
            console.error("Failed to handle query field change in the Query Rule View," +
              " error message: " + e);
          }

        },

        /**
         * getRequiredFilterType - Based on an array of query (Solr) fields, get the type
         * of filter model this rule should use. For example, if the fields are type text,
         * use a regular filter model. If the fields are tdate, use a dateFilter. Also
         * decide which filter to use if the field types are mixed.
         *
         * @param  {string[]} fields The list of selected fields
         * @return {string} The nodeName of the filter model to use
         */
        getRequiredFilterType: function (fields) {
          try {
            var types = [],
              // When fields is empty or are different types
              defaultFilterType = MetacatUI.queryFields.models[0].defaults().filterType;

            if (!fields || fields.length === 0 || fields[0] === "") {
              return defaultFilterType
            }

            fields.forEach((newField, i) => {
              var fieldModel = MetacatUI.queryFields.findWhere({ name: newField });
                types.push(fieldModel.get("filterType"));
            });

            // Test of all the fields are of the same type
            var allEqual = types.every((val, i, arr) => val === arr[0]);

            if (allEqual) {
              return types[0]
            } else {
              return defaultFilterType
            }

          } catch (e) {
            console.log("Failed to detect the required filter type in the Query Rule" +
              " View, error message: " + e);
          }
        },

        /**
         * Create and insert an input field where the user can select an operator for the
         * given rule. Operators will vary depending on filter model type.
         * 
         * @param {string} selectedOperator - optional. The label of an operator to
         * pre-select. Set to an empty string to render an empty operator selector.
         */
        addOperatorSelect: function (selectedOperator) {
          try {

            var view = this;
            var operatorError = false;

            var options = this.getOperatorOptions();

            // Identify the selected operator for existing models
            if (typeof selectedOperator !== "string") {
              selectedOperator = this.getSelectedOperator();
              // If there was no operator found, then this is probably an unsupported
              // combination of exclude + matchSubstring + filterType
              if (selectedOperator === "") {
                operatorError = true;
              }
            }

            if (selectedOperator === "") {
              selectedOperator = []
            } else {
              selectedOperator = [selectedOperator]
            }

            this.operatorSelect = new SearchableSelect({
              options: options,
              allowMulti: false,
              inputLabel: "Select an operator",
              clearable: false,
              placeholderText: "Select an operator",
              selected: selectedOperator
            });
            this.operatorSelect.$el.addClass(this.operatorClass);
            this.el.append(this.operatorSelect.el);

            if (operatorError) {
              view.listenToOnce(view.operatorSelect, "postRender", function () {
                view.operatorSelect.showMessage(
                  "Please select a valid operator",
                  "error",
                  true
                )
              })
            }

            this.operatorSelect.render();

            // Update model when the values change
            this.stopListening(
              this.operatorSelect,
              'changeSelection'
            );
            this.listenTo(
              this.operatorSelect,
              'changeSelection',
              this.handleOperatorChange
            );

          } catch (e) {
            console.error("Error adding an operator selector input in the Query Rule " +
              "View, error message:", e);
          }
        },

        /**
         * handleOperatorChange - When the operator selection is changed, update the model
         * and re-set the value UI when required
         *
         * @param  {string[]} newOperatorLabel The new operator label within an array,
         * e.g. ["is greater than"]
         */
        handleOperatorChange: function (newOperatorLabel) {

          try {

            var view = this;

            if (!newOperatorLabel || newOperatorLabel[0] == "") {
              var modelDefaults = this.model.defaults();
              this.model.set({
                min: modelDefaults.min,
                max: modelDefaults.max,
                values: modelDefaults.values
              })
              this.removeInput("value");
              return;
            }

            // Get the properties of the newly selected operator. The newOperatorLabel
            // will be an array with one value.
            var operator = _.findWhere(
              this.operatorOptions,
              { label: newOperatorLabel[0] }
            );

            // Gather  information about which values are currently set on the model, and
            // which are required
            var // Type
              type = view.model.get("nodeName"),
              isNumeric = ["dateFilter", "numericFilter"].includes(type),
              isRange = operator.hasMin &amp;&amp; operator.hasMax,

              // Values
              modelValues = this.model.get("values"),
              modelHasValues = modelValues ? modelValues &amp;&amp; modelValues.length : false,
              modelFirstValue = modelHasValues ? modelValues[0] : null,
              modelValueInt = parseInt(modelFirstValue) ? parseInt(modelFirstValue) : null,
              needsValue = isNumeric &amp;&amp; !modelValueInt &amp;&amp; !operator.hasMin &amp;&amp; !operator.hasMax,

              // Min
              modelMin = this.model.get("min"),
              modelHasMin = modelMin === 0 || modelMin,
              needsMin = operator.hasMin &amp;&amp; !modelHasMin,

              // Max
              modelMax = this.model.get("max"),
              modelHasMax = modelMax === 0 || modelMax,
              needsMax = operator.hasMax &amp;&amp; !modelHasMax;

            // Some operator options include a specific value to be set on the model. For
            // example, "is not empty", should set the model value to the "*" wildcard.
            // For operators with these specific value requirements, update the filter
            // model value and remove the value select input.
            if (operator.values &amp;&amp; operator.values.length) {
              this.removeInput("value");
              this.model.set("values", operator.values);
              // If the operator does not have a default value, then ensure that there is
              // a value select available.
            } else {
              if (!this.valueSelect) {
                this.model.set("values", view.model.defaults().values);
                this.addValueSelect();
              }
            }

            // Update the model with true or false for matchSubstring and exclude
            ["matchSubstring", "exclude"].forEach((prop, i) => {
              if (typeof operator[prop] !== "undefined") {
                view.model.set(prop, operator[prop]);
              } else {
                view.model.set(prop, view.model.defaults()[prop]);
              }
            });

            // Set min &amp; max values as required by the operator
            // TODO - test this strategy with dates...

            // Add a minimum value if one is needed
            if (needsMin) {
              // Search for the min in the values, then in the max
              if (modelValueInt || modelValueInt === 0) {
                this.model.set("min", modelValueInt)
              } else if (modelHasMax) {
                this.model.set("min", modelMax)
              } else {
                this.model.set("min", 0)
              }
            }

            // Add a maximum value if one is needed
            if (needsMax) {
              // Search for the min in the values, then in the max
              if (modelValueInt || modelValueInt === 0) {
                this.model.set("max", modelValueInt)
              } else if (modelHasMin) {
                this.model.set("max", modelMin)
              } else {
                this.model.set("max", 0)
              }
            }

            // Add a value if one is needed
            if (needsValue) {
              if (modelHasMin) {
                this.model.set("values", [modelMin])
              } else if (modelHasMax) {
                this.model.set("values", [modelMax])
              } else {
                this.model.set("values", [0])
              }
            }

            // Remove the minimum and max if they should not be included in the filter
            if (modelHasMax &amp;&amp; !operator.hasMax) {
              this.model.set("max", this.model.defaults().max)
            }
            if (modelHasMin &amp;&amp; !operator.hasMin) {
              this.model.set("min", this.model.defaults().min)
            }

            if (isRange) {
              this.model.set("range", true)
            } else {
              if (isNumeric) {
                this.model.set("range", false)
              } else {
                this.model.unset("range")
              }
            }

            // If the operator changed for a numeric or date field, reset the value
            // select. This way it can change from a range to a single value input if
            // needed.
            if (isNumeric) {
              this.removeInput("value");
              this.addValueSelect();
            }
          } catch (e) {
            console.error("Failed to handle the operator selection in a query rule " +
              "view, error message: " + e);
          }
        },

        /**
         * Get a list of {@link QueryRuleView#operatorOptions operatorOptions} that are
         * allowed for this view's filter model
         *
         * @param  {string[]} [fields] - Optional list of fields to use instead of the
         * fields set on this view's Filter model
         *
         * @since 2.15.0
         */
        getOperatorOptions: function(fields){

          try {
            // Check which type of rule this is (boolean, numeric, text, date)
            var type = this.model.get("nodeName");

            // If this rule contains a special field, replace the real query field names
            // with the special field names for the purpose of selecting operator options
            var fields = fields || this.model.get("fields");
            var fields = _.clone(fields);
            var fields = this.convertToSpecialFields(fields);

            // Get the list of options for a user to select from based on field name.
            // All of the rule's fields must be contained within the operator option's
            // list of allowed fields for it to be a match.
            var options = _.filter(this.operatorOptions, function (option) {
              if(option.fields){
                return _.every(fields, function(fieldName){
                  return option.fields.includes(fieldName)
                })
              }
            });

            // Get the list of options for a user to select from based on type, if there
            // were none that matched based on field names
            if(!options || !options.length){
              options = _.filter(this.operatorOptions, function (option) {
                if(option.types){
                  return option.types.includes(type)
                }
              }, this);
            }

            return options
          } catch (error) {
            console.log("Error getting operator options in a Query Rule View, " +
            "Error details: " + error);
          }
        },

        /**
         * getSelectedOperator - Based on values set on the model, get the label to show
         * in the "operator" filed of the Query Rule
         *
         * @return {string} The operator label
         */
        getSelectedOperator: function () {

          try {

            // This view
            var view = this,
              // The options that we will filter down
              options = this.operatorOptions,
              // The user-facing operator label that we will return
              selectedOperator = "";

            // --- Filter 1 - Filter options by type --- //

            // Reduce list of options to only  those that apply to the current filter type
            var type = view.model.get("nodeName");
            var options = this.getOperatorOptions();

            // --- Filter 2 - filter by 'matchSubstring', 'exclude', 'min', 'max' --- //

            // Create the conditions based on the model
            var conditions = _.pick(
              this.model.attributes,
              'matchSubstring', 'exclude', 'min', 'max'
            );

            var isNumeric = ["dateFilter", "numericFilter"].includes(type);

            if (!conditions.min &amp;&amp; conditions.min !== 0) {
              if (isNumeric) {
                conditions.hasMin = false
              }
            } else if (isNumeric) {
              conditions.hasMin = true
            }
            if (!conditions.max &amp;&amp; conditions.max !== 0) {
              if (isNumeric) {
                conditions.hasMax = false
              }
            } else if (isNumeric) {
              conditions.hasMax = true
            }

            delete conditions.min
            delete conditions.max

            var options = _.where(options, conditions);

            // --- Filter 3 - filter based on the value, if there's > 1 option --- //

            if (options.length > 1) {
              // Model values that determine the user-facing operator eg ["*"], [true],
              // [false]
              var specialValues = _.compact(
                _.pluck(this.operatorOptions, "values")
              ),
                specialValues = specialValues.map(val => JSON.stringify(val)),
                specialValues = _.uniq(specialValues);

              options = options.filter(function (option) {
                var modelValsStringified = JSON.stringify(view.model.get("values"));
                if (specialValues.includes(modelValsStringified)) {
                  if (JSON.stringify(option.values) === modelValsStringified) {
                    return true
                  }
                } else {
                  if (!option.values) {
                    return true
                  }
                }
              })
            }
            // --- Return value --- //

            if (options.length === 1) {
              selectedOperator = options[0].label
            }

            return selectedOperator
          } catch (e) {
            console.error("Failed to select an operator in the Query Rule View, error" +
              " message: " + e);
          }
        },

        /**
         * getCategory - Given an array of query fields, get the user-facing category that
         * these fields belong to. If there are fields from multiple categories, then a
         * default "Text" category is returned.
         *
         * @param  {string[]} fields An array of query (Solr) fields
         * @return {string} The label for the category that the given fields belong to
         */
        getCategory: function (fields) {

          try {
            var categories = [],
              // When fields is empty or are different types
              defaultCategory = "Text";

            if (!fields || fields.length === 0 || fields[0] === "") {
              return defaultCategory
            }

            fields.forEach((field, i) => {
              // Get the category of the field from the matching filter model in the Query
              // Fields Collection
              var fieldModel = MetacatUI.queryFields.findWhere({ name: field });
              categories.push(fieldModel.get("category"))
            });

            // Test of all the fields are of the same type
            var allEqual = categories.every((val, i, arr) => val === arr[0]);

            if (allEqual) {
              return categories[0]
            } else {
              return defaultCategory
            }

          } catch (e) {
            console.log("Failed to detect the category for a group of filters in the" +
              " Query Rule View, error message: " + e);
          }

        },

        /**
         * Create and insert an input field where the user can provide a search value
         */
        addValueSelect: function () {
          try {

            var view = this
              fields = this.model.get("fields"),
              filterType = this.getRequiredFilterType(fields),
              category = this.getCategory(fields),
              interfaces = this.valueSelectUImap,
              label = "";

            // To help guide users to create valid queries, the type of value field will
            // vary based on the type of field (i.e. filter nodeName), and the operator
            // selected.

            // Some user-facing operators (e.g. "is true") don't require a value to be set
            var selectedOperator = _.findWhere(
              this.operatorOptions,
              { label: this.getSelectedOperator() }
            );
            if (selectedOperator) {
              if (selectedOperator.values &amp;&amp; selectedOperator.values.length) {
                return
              }
            }

            // Find the appropriate UI to use the the value select field. Find the first
            // match in the valueSelectUImap according to the filter type and the
            // categories associated with the metadata field.
            var interfaceProperties = _.find(interfaces, function (thisInterface) {
              var typesMatch = true,
                categoriesMatch = true,
                namesMatch = true;
              if (thisInterface.queryFields &amp;&amp; thisInterface.queryFields.length) {
                fields.forEach((field, i) => {
                  if (thisInterface.queryFields.includes(field) === false) {
                    namesMatch = false;
                  }
                });
              }
              if (thisInterface.filterTypes &amp;&amp; thisInterface.filterTypes.length) {
                typesMatch = thisInterface.filterTypes.includes(filterType)
              }
              if (thisInterface.categories &amp;&amp; thisInterface.categories.length) {
                categoriesMatch = thisInterface.categories.includes(category)
              }
              return typesMatch &amp;&amp; categoriesMatch &amp;&amp; namesMatch
            });

            this.valueSelect = interfaceProperties.uiFunction.call(this);
            if (interfaceProperties.label &amp;&amp; interfaceProperties.label.length) {
              label = $(
                "&lt;p class='subtle searchable-select-label'>" +
                interfaceProperties.label + "&lt;/p>"
              );
            }

            // Append and render the chosen value selector
            this.el.append(view.valueSelect.el);
            this.valueSelect.$el.addClass(this.valuesClass);
            view.valueSelect.render();
            if (label) {
              view.valueSelect.$el.prepend(label)
            }

            // Make sure the listeners set below are not set multiple times
            this.stopListening( view.valueSelect, 'changeSelection inputFocus' );

            // Update model when the values change - note that the date &amp; numeric filter
            // views do not trigger a 'changeSelection' event, (because they are not based
            // on a SearchSelect View) but update the models directly
            this.listenTo(
              view.valueSelect,
              'changeSelection',
              this.handleValueChange
            );

            // Show a message that reminds the user that capitalization matters when they
            // are typing a value for a field that is case-sensitive.
            this.listenTo(
              view.valueSelect,
              'inputFocus',
              function(event){
                var fields = this.model.get("fields");
                var isCaseSensitive = _.some(fields, function(field){
                  return MetacatUI.queryFields.findWhere({
                    name: field,
                    caseSensitive: true
                  });
                })
                if(isCaseSensitive){
                  var fieldsText = "The field"
                  if(fields.length > 1){
                    fieldsText = "At least one of the fields"
                  }
                  var message = "&lt;i class='icon-lightbulb icon-on-left'>&lt;/i> &lt;b>Hint:&lt;/b> " +
                        fieldsText +
                        " you selected is case-sensitive. Capitalization matters here."
                  view.valueSelect.showMessage(message, type = "info", removeOnChange = false)
                } else {
                  view.valueSelect.removeMessages()
                }
              }
            )

            // Set the value to the value provided if there was one. Then validateValue()
          } catch (e) {
            console.error("Error adding a search value input in the Query Rule View," +
              " error message:", e);
          }
        },

        /**
         * handleValueChange - Called when the select values for rule are changed. Updates
         * the model.
         *
         * @param  {string[]} newValues The new values that were selected
         */
        handleValueChange: function (newValues) {

          try {
            // TODO:
            //  - validate values first?
            //  - how to update the model when values is empty?

            // Don't add empty values to the model
            newValues = _.reject(newValues, function (val) { return val === "" });
            this.model.set("values", newValues);
          } catch (e) {
            console.error("Failed to handle a change in select values in the Query Ryle" +
              " View, error message: " + e);
          }
        },

        // /**
        //  * Ensure the value entered is valid, given the metadata field selected.
        //  * If it's not, show an error. If it is, remove the error if there was one.
        //  *
        //  * @return {type}  description
        //    */
        // validateValue: function() {// TODO
        // },

        /**
         * Remove one of the three input fields from the rule
         *
         * @param  {string} inputType Which of the inputs to remove? "field", "operator",
         * or "value"
         */
        removeInput: function (inputType) {
          try {
            // TODO - what, if any, model updates should happen here?
            switch (inputType) {
              case "value":
                if (this.valueSelect) {
                  this.stopListening( this.valueSelect, 'changeSelection inputFocus' );
                  this.valueSelect.remove();
                  this.valueSelect = null;
                }
                break;
              case "operator":
                if (this.operatorSelect) {
                  this.stopListening(this.operatorSelect, 'changeSelection');
                  this.operatorSelect.remove();
                  this.operatorSelect = null;
                }
                break;
              case "field":
                if (this.fieldSelect) {
                  this.stopListening(this.fieldSelect, 'changeSelection');
                  this.fieldSelect.remove();
                  this.fieldSelect = null;
                }
                break;
              default:
                console.error("Must specify either value, operator, or field in the" +
                  " removeInput function in the Query Rule View")
            }
          } catch (e) {
            console.error("Error removing an input from the Query Rule View, error" +
              " message:", e);
          }
        },

        /**
         * Indicate to the user that the rule will be removed when they hover over the
         * remove button.
         */
        previewRemove: function () {
          try {
            this.$el.toggleClass(this.removePreviewClass);
          } catch (error) {
            console.log("Error showing a preview of the removal of a Query Rule View," +
              " details: " + error);
          }
        },

        /**
         * removeSelf - When the delete button is clicked, remove this entire View and
         * associated model
         */
        removeSelf: function () {
          try {
            $("body .popover").remove();
            $("body .tooltip").remove();
            if (this.model &amp;&amp; this.model.collection) {
              this.model.collection.remove(this.model);
            }
            this.remove();
          } catch (error) {
            console.log("Error removing a Query Rule View, details: " + error);
          }
        },

      });
  });
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
