<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>MetacatUI Dev Docs: Source: src/js/views/queryBuilder/QueryRuleView.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="/metacatui/assets/css/styles.css">
    <link type="text/css" rel="stylesheet" href="styles/style.css">
</head>

<body>

<nav id="nav">
    <a href="/">
      <div class="logo">
<svg class="cat" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="cat" class="svg-inline--fa fa-cat fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M290.59 192c-20.18 0-106.82 1.98-162.59 85.95V192c0-52.94-43.06-96-96-96-17.67 0-32 14.33-32 32s14.33 32 32 32c17.64 0 32 14.36 32 32v256c0 35.3 28.7 64 64 64h176c8.84 0 16-7.16 16-16v-16c0-17.67-14.33-32-32-32h-32l128-96v144c0 8.84 7.16 16 16 16h32c8.84 0 16-7.16 16-16V289.86c-10.29 2.67-20.89 4.54-32 4.54-61.81 0-113.52-44.05-125.41-102.4zM448 96h-64l-64-64v134.4c0 53.02 42.98 96 96 96s96-42.98 96-96V32l-64 64zm-72 80c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16zm80 0c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16z"></path></svg>

<svg width="459px" height="53px" viewBox="0 0 459 53" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="metacatui" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M16.492,52 C17.212,52 17.812,51.748 18.292,51.244 C18.772,50.74 19.012,50.128 19.012,49.408 L19.012,49.408 L18.94,22.912 L30.82,37.816 C31.204,38.344 31.72,38.764 32.368,39.076 C33.016,39.388 33.7,39.544 34.42,39.544 C35.908,39.544 37.132,38.896 38.092,37.6 L38.092,37.6 L49.684,22.912 L49.684,49.408 C49.684,50.128 49.96,50.74 50.512,51.244 C51.064,51.748 51.7,52 52.42,52 L52.42,52 L62.068,52 C62.788,52 63.388,51.748 63.868,51.244 C64.348,50.74 64.588,50.128 64.588,49.408 L64.588,49.408 L64.588,4.12 C64.588,3.448 64.336,2.86 63.832,2.356 C63.328,1.852 62.74,1.6 62.068,1.6 L62.068,1.6 L52.348,1.6 C51.388,1.6 50.56,1.648 49.864,1.744 C49.168,1.84 48.532,2.152 47.956,2.68 L47.956,2.68 L33.916,17.296 L20.524,2.608 C20.332,2.368 19.972,2.14 19.444,1.924 C18.916,1.708 18.412,1.6 17.932,1.6 L17.932,1.6 L6.772,1.6 C6.052,1.6 5.44,1.852 4.936,2.356 C4.432,2.86 4.18,3.448 4.18,4.12 L4.18,4.12 L4.18,49.408 C4.18,50.08 4.432,50.68 4.936,51.208 C5.44,51.736 6.052,52 6.772,52 L6.772,52 L16.492,52 Z M110.74,52 C111.556,52 112.264,51.676 112.864,51.028 C113.464,50.38 113.764,49.624 113.764,48.76 L113.764,48.76 L113.764,42.568 C113.764,41.608 113.464,40.828 112.864,40.228 C112.264,39.628 111.556,39.328 110.74,39.328 L110.74,39.328 L89.428,39.328 L89.428,32.92 L109.732,32.92 C110.5,32.92 111.184,32.596 111.784,31.948 C112.384,31.3 112.684,30.568 112.684,29.752 L112.684,29.752 L112.684,23.488 C112.684,22.576 112.384,21.82 111.784,21.22 C111.184,20.62 110.5,20.32 109.732,20.32 L109.732,20.32 L89.428,20.32 L89.428,14.488 L110.74,14.488 C111.508,14.488 112.204,14.164 112.828,13.516 C113.452,12.868 113.764,12.136 113.764,11.32 L113.764,11.32 L113.764,5.056 C113.764,4.144 113.464,3.388 112.864,2.788 C112.264,2.188 111.556,1.888 110.74,1.888 L110.74,1.888 L76.756,1.888 C75.94,1.888 75.232,2.188 74.632,2.788 C74.032,3.388 73.732,4.144 73.732,5.056 L73.732,5.056 L73.732,48.76 C73.732,49.624 74.032,50.38 74.632,51.028 C75.232,51.676 75.94,52 76.756,52 L76.756,52 L110.74,52 Z M147.604,52 C148.42,52 149.104,51.688 149.656,51.064 C150.208,50.44 150.484,49.672 150.484,48.76 L150.484,48.76 L150.484,16.216 L161.86,16.216 C162.676,16.216 163.396,15.904 164.02,15.28 C164.644,14.656 164.956,13.936 164.956,13.12 L164.956,13.12 L164.956,4.768 C164.956,4 164.644,3.316 164.02,2.716 C163.396,2.116 162.676,1.816 161.86,1.816 L161.86,1.816 L124.132,1.816 C123.22,1.816 122.464,2.104 121.864,2.68 C121.264,3.256 120.964,3.952 120.964,4.768 L120.964,4.768 L120.964,13.12 C120.964,13.936 121.264,14.656 121.864,15.28 C122.464,15.904 123.22,16.216 124.132,16.216 L124.132,16.216 L135.652,16.216 L135.148,48.832 C135.148,49.744 135.424,50.5 135.976,51.1 C136.528,51.7 137.212,52 138.028,52 L138.028,52 L147.604,52 Z M175.828,52 C176.836,52 177.676,51.82 178.348,51.46 C179.02,51.1 179.452,50.584 179.644,49.912 L179.644,49.912 L181.876,42.712 L197.932,42.712 L200.164,49.912 C200.356,50.584 200.8,51.1 201.496,51.46 C202.192,51.82 203.044,52 204.052,52 L204.052,52 L213.916,52 C215.836,51.712 216.796,50.704 216.796,48.976 C216.796,48.304 216.676,47.596 216.436,46.852 C216.196,46.108 216.052,45.616 216.004,45.376 L216.004,45.376 L199.876,4.84 C199.588,3.976 199.036,3.232 198.22,2.608 C197.404,1.984 196.372,1.648 195.124,1.6 L195.124,1.6 L184.756,1.6 C183.604,1.648 182.608,1.948 181.768,2.5 C180.928,3.052 180.292,3.832 179.86,4.84 L179.86,4.84 L163.876,45.376 C163.828,45.472 163.672,45.916 163.408,46.708 C163.144,47.5 163.012,48.304 163.012,49.12 C163.012,50.752 163.948,51.712 165.82,52 L165.82,52 L175.828,52 Z M195.34,30.544 L184.036,30.544 L189.652,13.624 L195.34,30.544 Z M245.38,53.08 C250.612,53.08 255.652,51.544 260.5,48.472 C261.22,47.944 261.58,47.296 261.58,46.528 C261.58,45.808 261.292,45.16 260.716,44.584 L260.716,44.584 L252.796,36.808 C252.364,36.376 251.836,36.16 251.212,36.16 C250.78,36.16 250.372,36.256 249.988,36.448 C248.356,37.12 246.796,37.456 245.308,37.456 C243.244,37.456 241.348,36.952 239.62,35.944 C237.892,34.936 236.512,33.58 235.48,31.876 C234.448,30.172 233.932,28.336 233.932,26.368 C233.932,24.352 234.436,22.504 235.444,20.824 C236.452,19.144 237.832,17.812 239.584,16.828 C241.336,15.844 243.244,15.352 245.308,15.352 C246.892,15.352 248.332,15.64 249.628,16.216 C250.012,16.408 250.444,16.504 250.924,16.504 C251.548,16.504 252.1,16.264 252.58,15.784 L252.58,15.784 L259.636,8.008 C260.164,7.384 260.428,6.76 260.428,6.136 C260.428,5.224 259.996,4.528 259.132,4.048 C254.86,1.552 250.276,0.304 245.38,0.304 C240.532,0.304 236.032,1.492 231.88,3.868 C227.728,6.244 224.44,9.448 222.016,13.48 C219.592,17.512 218.38,21.904 218.38,26.656 C218.38,31.408 219.592,35.812 222.016,39.868 C224.44,43.924 227.728,47.14 231.88,49.516 C236.032,51.892 240.532,53.08 245.38,53.08 Z M279.796,52 C280.804,52 281.644,51.82 282.316,51.46 C282.988,51.1 283.42,50.584 283.612,49.912 L283.612,49.912 L285.844,42.712 L301.9,42.712 L304.132,49.912 C304.324,50.584 304.768,51.1 305.464,51.46 C306.16,51.82 307.012,52 308.02,52 L308.02,52 L317.884,52 C319.804,51.712 320.764,50.704 320.764,48.976 C320.764,48.304 320.644,47.596 320.404,46.852 C320.164,46.108 320.02,45.616 319.972,45.376 L319.972,45.376 L303.844,4.84 C303.556,3.976 303.004,3.232 302.188,2.608 C301.372,1.984 300.34,1.648 299.092,1.6 L299.092,1.6 L288.724,1.6 C287.572,1.648 286.576,1.948 285.736,2.5 C284.896,3.052 284.26,3.832 283.828,4.84 L283.828,4.84 L267.844,45.376 C267.796,45.472 267.64,45.916 267.376,46.708 C267.112,47.5 266.98,48.304 266.98,49.12 C266.98,50.752 267.916,51.712 269.788,52 L269.788,52 L279.796,52 Z M299.308,30.544 L288.004,30.544 L293.62,13.624 L299.308,30.544 Z M352.588,52 C353.404,52 354.088,51.688 354.64,51.064 C355.192,50.44 355.468,49.672 355.468,48.76 L355.468,48.76 L355.468,16.216 L366.844,16.216 C367.66,16.216 368.38,15.904 369.004,15.28 C369.628,14.656 369.94,13.936 369.94,13.12 L369.94,13.12 L369.94,4.768 C369.94,4 369.628,3.316 369.004,2.716 C368.38,2.116 367.66,1.816 366.844,1.816 L366.844,1.816 L329.116,1.816 C328.204,1.816 327.448,2.104 326.848,2.68 C326.248,3.256 325.948,3.952 325.948,4.768 L325.948,4.768 L325.948,13.12 C325.948,13.936 326.248,14.656 326.848,15.28 C327.448,15.904 328.204,16.216 329.116,16.216 L329.116,16.216 L340.636,16.216 L340.132,48.832 C340.132,49.744 340.408,50.5 340.96,51.1 C341.512,51.7 342.196,52 343.012,52 L343.012,52 L352.588,52 Z M402.052,52.792 C408.1,52.792 412.912,51.628 416.488,49.3 C420.064,46.972 422.536,44.068 423.904,40.588 C425.272,37.108 425.932,33.424 425.884,29.536 C425.884,29.5309474 425.883967,29.5237673 425.8839,29.5144598 L425.883102,29.4330859 C425.879911,29.1480111 425.868211,28.3183158 425.848,26.944 C425.8294,25.6792 425.818008,22.91524 425.813823,18.65212 L425.813103,17.80828 C425.812997,17.66452 425.8129,17.5192 425.81281,17.37232 L425.812,3.904 C425.86,3.184 425.632,2.62 425.128,2.212 C424.624,1.804 423.916,1.6 423.004,1.6 L423.004,1.6 L413.428,1.6 C412.612,1.6 411.904,1.828 411.304,2.284 C410.704,2.74 410.404,3.28 410.404,3.904 L410.404,3.904 L410.26,27.808 C410.26,34.144 407.476,37.312 401.908,37.312 C399.076,37.312 396.832,36.412 395.176,34.612 C393.52,32.812 392.668,30.352 392.62,27.232 L392.62,27.232 L392.332,3.76 C392.332,3.088 392.068,2.56 391.54,2.176 C391.012,1.792 390.268,1.6 389.308,1.6 L389.308,1.6 L379.876,1.6 C378.244,1.6 377.428,2.32 377.428,3.76 L377.428,3.76 L377.5,28.816 C377.5,33.04 378.376,36.964 380.128,40.588 C381.88,44.212 384.592,47.152 388.264,49.408 C391.936,51.664 396.532,52.792 402.052,52.792 Z M449.284,52.144 C450.148,52.144 450.88,51.844 451.48,51.244 C452.08,50.644 452.38,49.84 452.38,48.832 L452.38,48.832 L452.38,4.912 C452.38,4 452.08,3.22 451.48,2.572 C450.88,1.924 450.148,1.6 449.284,1.6 L449.284,1.6 L439.42,1.6 C438.46,1.6 437.692,1.924 437.116,2.572 C436.54,3.22 436.252,4 436.252,4.912 L436.252,4.912 L436.252,48.832 C436.252,49.84 436.54,50.644 437.116,51.244 C437.692,51.844 438.46,52.144 439.42,52.144 L439.42,52.144 L449.284,52.144 Z" id="metacatui" fill="#FCBF49" fill-rule="nonzero"></path>
    </g>
</svg>
</logo>

    </a>
    <h3>Namespaces</h3><ul><li><a href="AppConfig.html">AppConfig</a></li><li><a href="IconUtilities.html">IconUtilities</a></li><li><a href="MapConfig.html">MapConfig</a></li><li><a href="MetacatUI.html">MetacatUI</a></li><li><a href="SearchParams.html">SearchParams</a></li><li><a href="Utilities.html">Utilities</a></li></ul><h3>Classes</h3><ul><li class='category-heading' data-category='Collections'>Collections</li><li><a href="AccessPolicy.html">AccessPolicy</a></li><li><a href="Citations.html">Citations</a></li><li><a href="DataPackage.html">DataPackage</a></li><li><a href="Filters.html">Filters</a></li><li><a href="ObjectFormats.html">ObjectFormats</a></li><li><a href="ProjectList.html">ProjectList</a></li><li><a href="QualityReport.html">QualityReport</a></li><li><a href="SolrResults.html">SolrResults</a></li><li><a href="Units.html">Units</a></li><li><a href="UserGroup.html">UserGroup</a></li><li class='category-heading' data-category='Collections/Bookkeeper'>Collections/Bookkeeper</li><li><a href="Quotas.html">Quotas</a></li><li><a href="Usages.html">Usages</a></li><li class='category-heading' data-category='Collections/Geohashes'>Collections/Geohashes</li><li><a href="Geohashes.html">Geohashes</a></li><li class='category-heading' data-category='Collections/Maps'>Collections/Maps</li><li><a href="AssetCategories.html">AssetCategories</a></li><li><a href="AssetColors.html">AssetColors</a></li><li><a href="Features.html">Features</a></li><li><a href="GeoPoints.html">GeoPoints</a></li><li><a href="MapAssets.html">MapAssets</a></li><li><a href="VectorFilters.html">VectorFilters</a></li><li><a href="ZoomPresets.html">ZoomPresets</a></li><li class='category-heading' data-category='Collections/Metadata/EML'>Collections/Metadata/EML</li><li><a href="EMLAnnotations.html">EMLAnnotations</a></li><li><a href="EMLMissingValueCodes.html">EMLMissingValueCodes</a></li><li class='category-heading' data-category='Collections/Ontologies'>Collections/Ontologies</li><li><a href="BioontologyResults.html">BioontologyResults</a></li><li class='category-heading' data-category='Collections/QueryFields'>Collections/QueryFields</li><li><a href="QueryFields.html">QueryFields</a></li><li class='category-heading' data-category='Collections/SearchSelect'>Collections/SearchSelect</li><li><a href="SearchSelectOptions.html">SearchSelectOptions</a></li><li class='category-heading' data-category='Models'>Models</li><li><a href="AccessRule.html">AccessRule</a></li><li><a href="Accordion.html">Accordion</a></li><li><a href="AppModel.html">AppModel</a></li><li><a href="CitationModel.html">CitationModel</a></li><li><a href="CollectionModel.html">CollectionModel</a></li><li><a href="DataONEObject.html">DataONEObject</a></li><li><a href="LookupModel.html">LookupModel</a></li><li><a href="Map.html">Map</a></li><li><a href="Metrics.html">Metrics</a></li><li><a href="QualityCheck.html">QualityCheck</a></li><li><a href="Search.html">Search</a></li><li><a href="SolrResult.html">SolrResult</a></li><li><a href="Stats.html">Stats</a></li><li class='category-heading' data-category='Models/Accordion'>Models/Accordion</li><li><a href="AccordionItem.html">AccordionItem</a></li><li class='category-heading' data-category='Models/Analytics'>Models/Analytics</li><li><a href="Analytics.html">Analytics</a></li><li><a href="GoogleAnalytics.html">GoogleAnalytics</a></li><li class='category-heading' data-category='Models/Bookkeeper'>Models/Bookkeeper</li><li><a href="Quota.html">Quota</a></li><li><a href="Subscription.html">Subscription</a></li><li><a href="Usage.html">Usage</a></li><li class='category-heading' data-category='Models/Connectors'>Models/Connectors</li><li><a href="BioontologyAccordionSearchSelect.html">BioontologyAccordionSearchSelect</a></li><li><a href="FiltersMapConnector.html">FiltersMapConnector</a></li><li><a href="FiltersSearchConnector.html">FiltersSearchConnector</a></li><li><a href="GeoPointsCesiumConnector.html">GeoPointsCesiumConnector</a></li><li><a href="GeoPointsCesiumPointsConnector.html">GeoPointsCesiumPointsConnector</a></li><li><a href="GeoPointsCesiumPolygonConnector.html">GeoPointsCesiumPolygonConnector</a></li><li><a href="MapSearchConnector.html">MapSearchConnector</a></li><li><a href="MapSearchFiltersConnector.html">MapSearchFiltersConnector</a></li><li class='category-heading' data-category='Models/Filters'>Models/Filters</li><li><a href="BooleanFilter.html">BooleanFilter</a></li><li><a href="ChoiceFilter.html">ChoiceFilter</a></li><li><a href="DateFilter.html">DateFilter</a></li><li><a href="Filter.html">Filter</a></li><li><a href="FilterGroup.html">FilterGroup</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="SpatialFilter.html">SpatialFilter</a></li><li><a href="ToggleFilter.html">ToggleFilter</a></li><li class='category-heading' data-category='Models/Formats'>Models/Formats</li><li><a href="ObjectFormat.html">ObjectFormat</a></li><li class='category-heading' data-category='Models/Geocoder'>Models/Geocoder</li><li><a href="GeocodedLocation.html">GeocodedLocation</a></li><li><a href="GeocoderSearch.html">GeocoderSearch</a></li><li><a href="GoogleMapsAutocompleter.html">GoogleMapsAutocompleter</a></li><li><a href="GoogleMapsGeocoder.html">GoogleMapsGeocoder</a></li><li><a href="Prediction.html">Prediction</a></li><li class='category-heading' data-category='Models/Geohashes'>Models/Geohashes</li><li><a href="Geohash.html">Geohash</a></li><li class='category-heading' data-category='Models/Maps'>Models/Maps</li><li><a href="AssetCategory.html">AssetCategory</a></li><li><a href="AssetColor.html">AssetColor</a></li><li><a href="AssetColorPalette.html">AssetColorPalette</a></li><li><a href="ExpansionPanelsModel.html">ExpansionPanelsModel</a></li><li><a href="Feature.html">Feature</a></li><li><a href="GeoBoundingBox.html">GeoBoundingBox</a></li><li><a href="GeoPoint.html">GeoPoint</a></li><li><a href="GeoScale.html">GeoScale</a></li><li><a href="GeoUtilities.html">GeoUtilities</a></li><li><a href="MapInteraction.html">MapInteraction</a></li><li><a href="MapModel.html">MapModel</a></li><li><a href="VectorFilter.html">VectorFilter</a></li><li><a href="ViewfinderModel.html">ViewfinderModel</a></li><li><a href="ZoomPresetModel.html">ZoomPresetModel</a></li><li class='category-heading' data-category='Models/Maps/Assets'>Models/Maps/Assets</li><li><a href="Cesium3DTileset.html">Cesium3DTileset</a></li><li><a href="CesiumGeohash.html">CesiumGeohash</a></li><li><a href="CesiumImagery.html">CesiumImagery</a></li><li><a href="CesiumTerrain.html">CesiumTerrain</a></li><li><a href="CesiumVectorData.html">CesiumVectorData</a></li><li><a href="MapAsset.html">MapAsset</a></li><li class='category-heading' data-category='Models/Metadata'>Models/Metadata</li><li><a href="ScienceMetadata.html">ScienceMetadata</a></li><li class='category-heading' data-category='Models/Metadata/EML'>Models/Metadata/EML</li><li><a href="EMLMethodStep.html">EMLMethodStep</a></li><li><a href="EMLSpecializedText.html">EMLSpecializedText</a></li><li><a href="EMLTaxonCoverage.html">EMLTaxonCoverage</a></li><li class='category-heading' data-category='Models/Metadata/EML211'>Models/Metadata/EML211</li><li><a href="EML211.html">EML211</a></li><li><a href="EMLAnnotation.html">EMLAnnotation</a></li><li><a href="EMLAttribute.html">EMLAttribute</a></li><li><a href="EMLDataTable.html">EMLDataTable</a></li><li><a href="EMLDistribution.html">EMLDistribution</a></li><li><a href="EMLEntity.html">EMLEntity</a></li><li><a href="EMLGeoCoverage.html">EMLGeoCoverage</a></li><li><a href="EMLMeasurementScale.html">EMLMeasurementScale</a></li><li><a href="EMLMethods.html">EMLMethods</a></li><li><a href="EMLMissingValueCode.html">EMLMissingValueCode</a></li><li><a href="EMLNonNumericDomain.html">EMLNonNumericDomain</a></li><li><a href="EMLNumericDomain.html">EMLNumericDomain</a></li><li><a href="EMLOtherEntity.html">EMLOtherEntity</a></li><li><a href="EMLParty.html">EMLParty</a></li><li><a href="EMLTemporalCoverage.html">EMLTemporalCoverage</a></li><li><a href="EMLText211.html">EMLText211</a></li><li><a href="EMLUnit.html">EMLUnit</a></li><li class='category-heading' data-category='Models/Metadata/EML220'>Models/Metadata/EML220</li><li><a href="EMLText.html">EMLText</a></li><li class='category-heading' data-category='Models/Ontologies'>Models/Ontologies</li><li><a href="BioOntology.html">BioOntology</a></li><li><a href="Bioontology_.html">Bioontology</a></li><li><a href="BioontologyBatch.html">BioontologyBatch</a></li><li><a href="BioontologyClass.html">BioontologyClass</a></li><li class='category-heading' data-category='Models/Portals'>Models/Portals</li><li><a href="PortalImage.html">PortalImage</a></li><li><a href="PortalModel.html">PortalModel</a></li><li><a href="PortalSectionModel.html">PortalSectionModel</a></li><li class='category-heading' data-category='Models/Projects'>Models/Projects</li><li><a href="Project.html">Project</a></li><li class='category-heading' data-category='Models/QueryFields'>Models/QueryFields</li><li><a href="QueryField.html">QueryField</a></li><li class='category-heading' data-category='Models/SearchSelect'>Models/SearchSelect</li><li><a href="AccountSearchSelect.html">AccountSearchSelect</a></li><li><a href="QueryFieldSearchSelect.html">QueryFieldSearchSelect</a></li><li><a href="SearchSelect.html">SearchSelect</a></li><li><a href="SelectOptionModel.html">SelectOptionModel</a></li><li><a href="SolrAutocomplete.html">SolrAutocomplete</a></li><li class='category-heading' data-category='Router'>Router</li><li><a href="UIRouter.html">UIRouter</a></li><li class='category-heading' data-category='Views'>Views</li><li><a href="AccessPolicyView.html">AccessPolicyView</a></li><li><a href="AccessRuleView.html">AccessRuleView</a></li><li><a href="AnnotationView.html">AnnotationView</a></li><li><a href="AppView.html">AppView</a></li><li><a href="CatalogSearchView.html">CatalogSearchView</a></li><li><a href="CitationHeaderView.html">CitationHeaderView</a></li><li><a href="CitationListView.html">CitationListView</a></li><li><a href="CitationModalView.html">CitationModalView</a></li><li><a href="CitationView.html">CitationView</a></li><li><a href="ColorPaletteView.html">ColorPaletteView</a></li><li><a href="DataCatalogView.html">DataCatalogView</a></li><li><a href="DataCatalogViewWithFilters.html">DataCatalogViewWithFilters</a></li><li><a href="DataItemView.html">DataItemView</a></li><li><a href="DataPackageView.html">DataPackageView</a></li><li><a href="DraftsView.html">DraftsView</a></li><li><a href="EditCollectionView.html">EditCollectionView</a></li><li><a href="EditorView.html">EditorView</a></li><li><a href="FooterView.html">FooterView</a></li><li><a href="GroupListView.html">GroupListView</a></li><li><a href="ImageUploaderView.html">ImageUploaderView</a></li><li><a href="MarkdownEditorView.html">MarkdownEditorView</a></li><li><a href="MarkdownView.html">MarkdownView</a></li><li><a href="MdqRunView.html">MdqRunView</a></li><li><a href="MetadataView.html">MetadataView</a></li><li><a href="MetricModalView.html">MetricModalView</a></li><li><a href="MetricView.html">MetricView</a></li><li><a href="MetricsChartView.html">MetricsChartView</a></li><li><a href="NavbarView.html">NavbarView</a></li><li><a href="RegisterCitationView.html">RegisterCitationView</a></li><li><a href="SearchResultView.html">SearchResultView</a></li><li><a href="SignInView.html">SignInView</a></li><li><a href="TOCView.html">TOCView</a></li><li><a href="TableEditorView.html">TableEditorView</a></li><li><a href="UserGroupView.html">UserGroupView</a></li><li><a href="UserView.html">UserView</a></li><li class='category-heading' data-category='Views/Accordion'>Views/Accordion</li><li><a href="AccordionItemView.html">AccordionItemView</a></li><li><a href="AccordionView.html">AccordionView</a></li><li class='category-heading' data-category='Views/Filters'>Views/Filters</li><li><a href="BooleanFilterView.html">BooleanFilterView</a></li><li><a href="ChoiceFilterView.html">ChoiceFilterView</a></li><li><a href="DateFilterView.html">DateFilterView</a></li><li><a href="FilterEditorView.html">FilterEditorView</a></li><li><a href="FilterGroupView.html">FilterGroupView</a></li><li><a href="FilterGroupsView.html">FilterGroupsView</a></li><li><a href="FilterView.html">FilterView</a></li><li><a href="NumericFilterView.html">NumericFilterView</a></li><li><a href="SemanticFilterView.html">SemanticFilterView</a></li><li><a href="ToggleFilterView.html">ToggleFilterView</a></li><li class='category-heading' data-category='Views/Maps'>Views/Maps</li><li><a href="CesiumWidgetView.html">CesiumWidgetView</a></li><li><a href="DrawTool.html">DrawTool</a></li><li><a href="FeatureInfoView.html">FeatureInfoView</a></li><li><a href="LayerCategoryListView.html">LayerCategoryListView</a></li><li><a href="LayerDetailView.html">LayerDetailView</a></li><li><a href="LayerDetailsView.html">LayerDetailsView</a></li><li><a href="LayerInfoView.html">LayerInfoView</a></li><li><a href="LayerItemView.html">LayerItemView</a></li><li><a href="LayerListView.html">LayerListView</a></li><li><a href="LayerNavigationView.html">LayerNavigationView</a></li><li><a href="LayerOpacityView.html">LayerOpacityView</a></li><li><a href="LayersPanelView.html">LayersPanelView</a></li><li><a href="LegendView.html">LegendView</a></li><li><a href="MapHelpPanel.html">MapHelpPanel</a></li><li><a href="MapView.html">MapView</a></li><li><a href="MapWidgetContainerView.html">MapWidgetContainerView</a></li><li><a href="PredictionView.html">PredictionView</a></li><li><a href="PredictionsListView.html">PredictionsListView</a></li><li><a href="ScaleBarView.html">ScaleBarView</a></li><li><a href="SearchInputView.html">SearchInputView</a></li><li><a href="SearchView.html">SearchView</a></li><li><a href="ShareUrlView.html">ShareUrlView</a></li><li><a href="ToolbarView.html">ToolbarView</a></li><li><a href="ViewfinderView.html">ViewfinderView</a></li><li class='category-heading' data-category='Views/Maps/Legend'>Views/Maps/Legend</li><li><a href="CategoricalSwatchView.html">CategoricalSwatchView</a></li><li><a href="ContinuousSwatchView.html">ContinuousSwatchView</a></li><li><a href="LayerLegendView.html">LayerLegendView</a></li><li><a href="LegendContainerView.html">LegendContainerView</a></li><li class='category-heading' data-category='Views/Maps/Viewfinder'>Views/Maps/Viewfinder</li><li><a href="ExpansionPanelView.html">ExpansionPanelView</a></li><li><a href="ZoomPresetView.html">ZoomPresetView</a></li><li><a href="ZoomPresetsListView.html">ZoomPresetsListView</a></li><li class='category-heading' data-category='Views/Metadata'>Views/Metadata</li><li><a href="EML211EditorView.html">EML211EditorView</a></li><li><a href="EMLAttributeView.html">EMLAttributeView</a></li><li><a href="EMLEntityView.html">EMLEntityView</a></li><li><a href="EMLMeasurementScaleView.html">EMLMeasurementScaleView</a></li><li><a href="EMLMeasurementTypeView.html">EMLMeasurementTypeView</a></li><li><a href="EMLMethodsView.html">EMLMethodsView</a></li><li><a href="EMLMissingValueCodeView.html">EMLMissingValueCodeView</a></li><li><a href="EMLMissingValueCodesView.html">EMLMissingValueCodesView</a></li><li><a href="EMLOtherEntityView.html">EMLOtherEntityView</a></li><li><a href="EMLPartyView.html">EMLPartyView</a></li><li><a href="EMLTempCoverageView.html">EMLTempCoverageView</a></li><li><a href="EMLView.html">EMLView</a></li><li><a href="EMlGeoCoverageView_.html">EMlGeoCoverageView</a></li><li><a href="ScienceMetadataView.html">ScienceMetadataView</a></li><li class='category-heading' data-category='Views/Ontologies'>Views/Ontologies</li><li><a href="BioontologyBrowser.html">BioontologyBrowser</a></li><li class='category-heading' data-category='Views/Portals'>Views/Portals</li><li><a href="PortalDataView.html">PortalDataView</a></li><li><a href="PortalHeaderView.html">PortalHeaderView</a></li><li><a href="PortalListView.html">PortalListView</a></li><li><a href="PortalLogosView.html">PortalLogosView</a></li><li><a href="PortalMembersView.html">PortalMembersView</a></li><li><a href="PortalSectionView.html">PortalSectionView</a></li><li><a href="PortalUsagesView.html">PortalUsagesView</a></li><li><a href="PortalView.html">PortalView</a></li><li><a href="PortalVisualizationsView.html">PortalVisualizationsView</a></li><li><a href="PortalsSearchView.html">PortalsSearchView</a></li><li class='category-heading' data-category='Views/Portals/Editor'>Views/Portals/Editor</li><li><a href="PortEditorDataView.html">PortEditorDataView</a></li><li><a href="PortEditorImageView.html">PortEditorImageView</a></li><li><a href="PortEditorLogosView.html">PortEditorLogosView</a></li><li><a href="PortEditorMdSectionView.html">PortEditorMdSectionView</a></li><li><a href="PortEditorSectionView.html">PortEditorSectionView</a></li><li><a href="PortEditorSectionsView.html">PortEditorSectionsView</a></li><li><a href="PortEditorSettingsView.html">PortEditorSettingsView</a></li><li><a href="PortalEditorView.html">PortalEditorView</a></li><li class='category-heading' data-category='Views/Projects'>Views/Projects</li><li><a href="ProjectView.html">ProjectView</a></li><li class='category-heading' data-category='Views/QueryBuilder'>Views/QueryBuilder</li><li><a href="QueryBuilderView.html">QueryBuilderView</a></li><li><a href="QueryRuleView.html">QueryRuleView</a></li><li class='category-heading' data-category='Views/Search'>Views/Search</li><li><a href="SearchResultsPagerView.html">SearchResultsPagerView</a></li><li><a href="SearchResultsView.html">SearchResultsView</a></li><li><a href="SorterView.html">SorterView</a></li><li class='category-heading' data-category='Views/SearchSelect'>Views/SearchSelect</li><li><a href="AccountSelectView.html">AccountSelectView</a></li><li><a href="AnnotationFilter.html">AnnotationFilter</a></li><li><a href="BioontologySelectView.html">BioontologySelectView</a></li><li><a href="NodeSelect.html">NodeSelect</a></li><li><a href="ObjectFormatSelect.html">ObjectFormatSelect</a></li><li><a href="QueryFieldSelectView.html">QueryFieldSelectView</a></li><li><a href="SearchSelectView.html">SearchSelectView</a></li><li><a href="SeparatorView.html">SeparatorView</a></li><li class='category-heading' data-category='Deprecated'>Deprecated</li><li><a href="AnnotatorView.html">AnnotatorView</a></li><li><a href="ExternalView.html">ExternalView</a></li><li><a href="LogsSearch.html">LogsSearch</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addClassesFromResponse">addClassesFromResponse</a></li><li><a href="global.html#addFields">addFields</a></li><li><a href="global.html#addSelected">addSelected</a></li><li><a href="global.html#appConfigPath">appConfigPath</a></li><li><a href="global.html#buildChildrenUrl">buildChildrenUrl</a></li><li><a href="global.html#buildSearchUrl">buildSearchUrl</a></li><li><a href="global.html#canChangeSeparator">canChangeSeparator</a></li><li><a href="global.html#changeSubmenuOnSearch">changeSubmenuOnSearch</a></li><li><a href="global.html#couldBeLatLong">couldBeLatLong</a></li><li><a href="global.html#createBatchPayload">createBatchPayload</a></li><li><a href="global.html#createHeaders">createHeaders</a></li><li><a href="global.html#defaults">defaults</a></li><li><a href="global.html#encodeIfPresent">encodeIfPresent</a></li><li><a href="global.html#excludeFields">excludeFields</a></li><li><a href="global.html#fetchClasses">fetchClasses</a></li><li><a href="global.html#fetchClassesFromOntology">fetchClassesFromOntology</a></li><li><a href="global.html#fetchFromOntologies">fetchFromOntologies</a></li><li><a href="global.html#fetchQueryFields">fetchQueryFields</a></li><li><a href="global.html#fieldToOption">fieldToOption</a></li><li><a href="global.html#filterClassesToFetch">filterClassesToFetch</a></li><li><a href="global.html#finalizeFetch">finalizeFetch</a></li><li><a href="global.html#formatResult">formatResult</a></li><li><a href="global.html#formatResults">formatResults</a></li><li><a href="global.html#getAccountDetails">getAccountDetails</a></li><li><a href="global.html#getCachedClasses">getCachedClasses</a></li><li><a href="global.html#getCategoryNames">getCategoryNames</a></li><li><a href="global.html#getChildren">getChildren</a></li><li><a href="global.html#getClasses">getClasses</a></li><li><a href="global.html#getIncludeParam">getIncludeParam</a></li><li><a href="global.html#getNextPage">getNextPage</a></li><li><a href="global.html#getNextSeparator">getNextSeparator</a></li><li><a href="global.html#getOptionByLabelOrValue">getOptionByLabelOrValue</a></li><li><a href="global.html#getOptionsByCategory">getOptionsByCategory</a></li><li><a href="global.html#getQueryFieldOptions">getQueryFieldOptions</a></li><li><a href="global.html#getSelectedModels">getSelectedModels</a></li><li><a href="global.html#hasInvalidSelections">hasInvalidSelections</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#initializeFetch">initializeFetch</a></li><li><a href="global.html#isValidValue">isValidValue</a></li><li><a href="global.html#model">model</a></li><li><a href="global.html#moveClassesToNotFound">moveClassesToNotFound</a></li><li><a href="global.html#optionsAsJSON">optionsAsJSON</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#recordError">recordError</a></li><li><a href="global.html#removeSelected">removeSelected</a></li><li><a href="global.html#renameCategory">renameCategory</a></li><li><a href="global.html#resetPageInfo">resetPageInfo</a></li><li><a href="global.html#responseAsync">responseAsync</a></li><li><a href="global.html#separatorRequired">separatorRequired</a></li><li><a href="global.html#setAddedFieldDetails">setAddedFieldDetails</a></li><li><a href="global.html#setNextSeparator">setNextSeparator</a></li><li><a href="global.html#setOptionsForPreselected">setOptionsForPreselected</a></li><li><a href="global.html#setSelected">setSelected</a></li><li><a href="global.html#sortByProp">sortByProp</a></li><li><a href="global.html#sortFields">sortFields</a></li><li><a href="global.html#taxonomicClassification">taxonomicClassification</a></li><li><a href="global.html#toAccordionItem">toAccordionItem</a></li><li><a href="global.html#toJSON">toJSON</a></li><li><a href="global.html#toSearchSelectOption">toSearchSelectOption</a></li><li><a href="global.html#updateOptions">updateOptions</a></li><li><a href="global.html#url">url</a></li><li><a href="global.html#waitForFetchComplete">waitForFetchComplete</a></li></ul>
</nav>

<div id="main">

    <h1 class="page-title">Source: src/js/views/queryBuilder/QueryRuleView.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>define([
  "jquery",
  "underscore",
  "backbone",
  "views/searchSelect/SearchSelectView",
  "views/searchSelect/QueryFieldSelectView",
  "views/searchSelect/NodeSelectView",
  "views/searchSelect/AccountSelectView",
  "views/filters/NumericFilterView",
  "views/filters/DateFilterView",
  "views/searchSelect/ObjectFormatSelectView",
  "views/searchSelect/BioontologySelectView",
], (
  $,
  _,
  Backbone,
  SearchSelect,
  QueryFieldSelect,
  NodeSelect,
  AccountSelect,
  NumericFilterView,
  DateFilterView,
  ObjectFormatSelect,
  BioontologySelect,
) =>
  /**
   * @class QueryRuleView
   * @classdesc A view that provides an UI for a user to construct a single filter that
   * is part of a complex query
   * @classcategory Views/QueryBuilder
   * @screenshot views/QueryRuleView.png
   * @augments Backbone.View
   * @class
   * @since 2.14.0
   */
  Backbone.View.extend(
    /** @lends QueryRuleView.prototype */
    {
      /**
       * The type of View this is
       * @type {string}
       */
      type: "QueryRule",

      /**
       * The HTML class names for this view element
       * @type {string}
       */
      className: "query-rule",

      /**
       * The class to add to the rule number and other information on the left
       * @type {string}
       */
      ruleInfoClass: "rule-info",

      /**
       * The class to add to the field select element
       * @type {string}
       */
      fieldsClass: "field",

      /**
       * The class to add to the operator select element
       * @type {string}
       */
      operatorClass: "operator",

      /**
       * The class to add to the value select element
       * @type {string}
       */
      valuesClass: "value",

      /**
       * The class to add to the element that a user should click to remove a rule.
       * @type {string}
       */
      removeClass: "remove-rule",

      /**
       * An ID for the element that a user should click to remove a rule. A unique ID
       * will be appended to this ID, and the ID will be added to the template.
       * @type {string}
       */
      removeRuleID: "remove-rule-",

      /**
       * The maximum number of levels of nested Rule Groups (i.e. nested FilterGroup
       * models) that a user is permitted to build in the Query Builder that contains
       * this rule. This value should be passed to the rule by the parent Query Builder.
       * This value minus one will be passed on to any child Query Builders (those that
       * render nested FilterGroup models).
       * @type {number}
       * @since 2.17.0
       */
      nestedLevelsAllowed: 1,

      /**
       * An array of hex color codes used to help distinguish between different rules.
       * If this is a nested Query Rule, and the rule should inherit its colour from
       * the parent Query Rule, then set ruleColorPalette to "inherit".
       * @type {string[]|string}
       */
      ruleColorPalette: [
        "#44AA99",
        "#137733",
        "#c9a538",
        "#CC6677",
        "#882355",
        "#AA4499",
        "#332288",
      ],

      /**
       * Search index fields to exclude in the metadata field selector
       * @type {string[]}
       */
      excludeFields: [],

      /**
       * Query fields to exclude in the metadata field selector for any Query Rules that
       * are in nested Query Builders (i.e. in nested Filter Groups). This is a list of
       * field names that exist in the query service index (i.e. Solr), but which should
       * be hidden in nested Query Builders
       * @type {string[]}
       */
      nestedExcludeFields: [],

      /**
       * A single Filter model that is part of a Filters collection, such as the
       * definition filters for a Collection or Portal or the filters for a Search
       * model. The Filter model must be part of a Filters collection (i.e. there must
       * be a model.collection property)
       * @type {Filter|BooleanFilter|NumericFilter|DateFilter|FilterGroup}
       */
      model: undefined,

      /**
       * A function that creates and returns the Backbone events object.
       * @returns {object} Returns a Backbone events object
       */
      events() {
        const events = {};
        const removeID = `#${this.removeRuleID}${this.cid}`;
        events[`click ${removeID}`] = "removeSelf";
        events[`mouseover ${removeID}`] = "previewRemove";
        events[`mouseout ${removeID}`] = "previewRemove";
        return events;
      },

      /**
       * A list of additional fields which are not retrieved from the query API, but
       * which should be added to the list of options. This can be used to add
       * abstracted fields which are a combination of multiple query fields, or to add a
       * duplicate field that has a different label. These special fields are passed on
       * to {@link QueryFieldSelectView#addFields}.
       * @type {SpecialField[]}
       * @since 2.15.0
       */
      specialFields: [
        {
          name: "documents-special-field",
          fields: ["documents"],
          label: "Contains Data Files",
          description:
            "Limit results to packages that include data files. Without" +
            " this rule, results may include packages with metadata but no data.",
          category: "General",
          values: ["*"],
        },
        {
          name: "year-data-collection",
          fields: ["beginDate", "endDate"],
          label: "Year of Data Collection",
          description:
            "The temporal range of content described by the metadata",
          category: "Dates",
        },
      ],

      /**
       * An operator option is an object that lists the properties of one of the
       * operators that will be displayed to the user in the Query Rule "operator"
       * dropdown list. The operator properties are used to pre-select the correct
       * operator based on attributes in the associated
       * {@link Filter#defaults Filter model}, as well as to update the Filter model
       * when a user selects a new operator. Operators can set the exclude and
       * matchSubstring properties of the model, and sometimes the values as well.
       * Either the types property OR the fields property must be set, not both.
       * @typedef {object} OperatorOption
       * @property {string} label - The label to display to the user
       * @property {string} icon - An icon that represents the operator
       * @property {boolean} matchSubstring - Whether the matchSubstring attribute is
       * true or false in the filter model that matches this operator
       * @property {boolean} exclude - Whether the exclude attribute is true or false in
       * the filter model that matches this operator
       * @property {boolean} hasMax - Whether the filter model that matches this
       * operator must have a max attribute
       * @property {boolean} hasMin - Whether the filter model that matches this
       * operator must have a min attribute
       * @property {string[]} values - For this operator to work as desired, the values
       * that should be set in the filter (e.g. ["true"] for the operator "is true")
       * @property {string[]} [types] - The node names of the filters that this operator
       * is used for (e.g. "filter", "booleanFilter")
       * @property {string[]} [fields] - The query field names of the filters that this
       * operator is used for. If this is used for a
       * {@link QueryRuleView#specialFields special field}, then list the special field
       * name (id), and not the real query field names. If this fields property is set,
       * then the types property will be ignored. (i.e. fields is more specific than
       * types.)
       */

      /**
       * The list of operators that will be available in the dropdown list that connects
       * the query fields to the values. Each operator must be unique.
       * @type {OperatorOption[]}
       */
      operatorOptions: [
        {
          label: "is true",
          description:
            "The data package includes data files (and not only metadata)",
          icon: "ok-circle",
          matchSubstring: false,
          exclude: false,
          values: ["*"],
          fields: ["documents-special-field"],
        },
        {
          label: "is false",
          description:
            "The data package only contains metadata; it contains no data files.",
          icon: "ban-circle",
          matchSubstring: false,
          exclude: true,
          values: ["*"],
          fields: ["documents-special-field"],
        },
        {
          label: "equals",
          description:
            "The text in the metadata field is an exact match to the" +
            " selected value",
          icon: "equal",
          matchSubstring: false,
          exclude: false,
          types: ["filter"],
        },
        {
          label: "does not equal",
          description:
            "The text in the metadata field is anything except an exact" +
            " match to the selected value",
          icon: "not-equal",
          matchSubstring: false,
          exclude: true,
          types: ["filter"],
        },
        {
          label: "contains",
          description:
            "The text in the metadata field matches or contains the words" +
            " or phrase selected",
          icon: "ok-circle",
          matchSubstring: true,
          exclude: false,
          types: ["filter"],
        },
        {
          label: "does not contain",
          description:
            "The words or phrase selected are not contained within the" +
            " metadata field",
          icon: "ban-circle",
          matchSubstring: true,
          exclude: true,
          types: ["filter"],
        },
        {
          label: "is empty",
          description: "The metadata field contains no text or value",
          icon: "circle-blank",
          matchSubstring: false,
          exclude: true,
          values: ["*"],
          types: ["filter"],
        },
        {
          label: "is not empty",
          description: "The metadata field is filled in with any text at all",
          icon: "circle",
          matchSubstring: false,
          exclude: false,
          values: ["*"],
          types: ["filter"],
        },
        {
          label: "is true",
          description: "The metadata field is set to true",
          icon: "ok-circle",
          matchSubstring: false,
          exclude: false,
          values: [true],
          types: ["booleanFilter"],
        },
        {
          label: "is false",
          description: "The metadata field is set to false",
          icon: "ban-circle",
          matchSubstring: false,
          exclude: false,
          values: [false],
          types: ["booleanFilter"],
        },
        {
          label: "is between",
          description:
            "The metadata field is a value between the range selected" +
            " (inclusive of both values)",
          icon: "resize-horizontal",
          matchSubstring: false,
          exclude: false,
          hasMin: true,
          hasMax: true,
          types: ["numericFilter", "dateFilter"],
        },
        {
          label: "is less than or equal to",
          description:
            "The metadata field is a number less than the value selected",
          icon: "less-than-or-eq",
          matchSubstring: false,
          exclude: false,
          hasMin: false,
          hasMax: true,
          types: ["numericFilter"],
        },
        {
          label: "is greater than or equal to",
          description:
            "The metadata field is a number greater than the value selected",
          icon: "greater-than-or-eq",
          matchSubstring: false,
          exclude: false,
          hasMin: true,
          hasMax: false,
          types: ["numericFilter"],
        },
        {
          label: "is exactly",
          description: "The metadata field exactly equals the value selected",
          icon: "equal",
          matchSubstring: false,
          exclude: false,
          hasMin: false,
          hasMax: false,
          types: ["numericFilter"],
        },
        // TODO: The dateFilter model &amp; view need to be updated for these to work:
        // {
        //   label: "is during or before", icon: "less-than-or-eq", matchSubstring:
        //   false, exclude: false, hasMin: false, hasMax: true, types: ["dateFilter"]
        // },
        // {
        //   label: "is during or after", icon: "greater-than", matchSubstring: false,
        //   exclude: false, hasMin: true, hasMax: false, types: ["dateFilter"]
        // },
        // {
        //   label: "is in the year", icon: "equal", matchSubstring: false, exclude:
        //   false, hasMin: false, hasMax: false, types: ["dateFilter"]
        // }
      ],

      /**
       * The third input in each Query Rule is where the user enters a value, minimum,
       * or maximum for the filter model. Different types of values are appropriate for
       * different solr query fields, and so we display different interfaces depending
       * on the type and category of the selected query fields. A Value Input Option
       * object defines a of interface to show for a given type and category.
       * @typedef {object} ValueInputOption
       * @property {string[]} filterTypes - An array of one or more filter types that
       * are allowed for this interface.  If none are provided then any filter type is
       * allowed. Filter types are one of the four keys defined in
       * {@link QueryField#filterTypesMap}.
       * @property {string[]} categories - An array of one or more categories that are
       * allowed for this interface. These strings must exactly match the categories
       * provided in QueryField.categoriesMap(). If none are provided then any category
       * is allowed.
       * @property {string[]} queryFields - Specific names of fields that are allowed in
       * this interface. If none are provided, then any query fields are allowed that
       * match the other properties. If this value select should be used for a
       * {@link QueryRuleView#specialFields special field}, then use the name (id) of
       * the special field, not the actual query fields that it represents.
       * @property {string} label - If the interface does not include a label (e.g.
       * number filter), include a string to display here.
       * @property {Function} uiFunction - A function that returns the UI view to use
       * with all appropriate options set. The function will be called with this view as
       * the context.
       */

      /**
       * This list defines which type of value input to show depending on filter type,
       * category, and query fields. The value input options are ordered from *most*
       * specific to *least*, since the first match will be selected. The filter model
       * must match either the queryFields, or both the filterTypes AND the categories
       * for a UI to be selected.
       * @type {ValueInputOption[]}
       */
      valueSelectUImap: [
        // serviceCoupling field
        {
          queryFields: ["serviceCoupling"],
          uiFunction() {
            return new SearchSelect({
              options: [
                {
                  label: "tight",
                  description:
                    "Tight coupled service work only on the data described" +
                    " by this metadata document.",
                },
                {
                  label: "mixed",
                  description:
                    "Mixed coupling means service works on data described" +
                    " by this metadata document but may work on other data.",
                },
                {
                  label: "loose",
                  description:
                    "Loose coupling means service works on any data.",
                },
              ],
              allowMulti: true,
              allowAdditions: false,
              inputLabel: "Select a coupling",
              selected: this.model.get("values"),
              separator: this.model.get("operator"),
            });
          },
        },
        // Metadata format IDs
        {
          queryFields: ["formatId"],
          uiFunction() {
            return new ObjectFormatSelect({
              selected: this.model.get("values"),
              separator: this.model.get("operator"),
            });
          },
        },
        // Semantic annotation picker
        {
          queryFields: ["sem_annotation"],
          uiFunction() {
            // A bioportalAPIKey is required for the Annotation Filter UI
            if (MetacatUI.appModel.get("bioportalAPIKey")) {
              return new BioontologySelect({
                selected: this.model.get("values"),
                separator: this.model.get("operator"),
                allowMulti: true,
                allowAdditions: true,
                inputLabel: "Search for a term",
              });
              // If there's no API key, render the default UI (the last in this list)
            }
            return this.valueSelectUImap.slice(-1)[0].uiFunction.call(this);
          },
        },
        // User/Organization account ID lookup
        {
          queryFields: [
            "writePermission",
            "readPermission",
            "changePermission",
            "rightsHolder",
            "submitter",
          ],
          uiFunction() {
            return new AccountSelect({
              selected: this.model.get("values"),
              separator: this.model.get("operator"),
            });
          },
        },
        // Repository picker for fields that need a member node ID
        {
          filterTypes: ["filter"],
          queryFields: [
            "blockedReplicationMN",
            "preferredReplicationMN",
            "replicaMN",
            "authoritativeMN",
            "datasource",
          ],
          uiFunction() {
            return new NodeSelect({
              selected: this.model.get("values"),
              separator: this.model.get("operator"),
            });
          },
        },
        // Any numeric fields don't fit one of the above options
        {
          filterTypes: ["numericFilter"],
          label: "Choose a value",
          uiFunction() {
            return new NumericFilterView({
              model: this.model,
              showButton: false,
              separator: this.model.get("operator"),
            });
          },
        },
        // Any date fields that don't fit one of the above options
        {
          filterTypes: ["dateFilter"],
          label: "Choose a year",
          uiFunction() {
            return new DateFilterView({
              model: this.model,
              separator: this.model.get("operator"),
            });
          },
        },
        // The last is the default value selection UI
        {
          uiFunction() {
            return new SearchSelect({
              options: [],
              allowMulti: true,
              allowAdditions: true,
              inputLabel: "Type a value",
              selected: this.model.get("values"),
              separator: this.model.get("operator"),
            });
          },
        },
      ],

      /**
       * Creates a new QueryRuleView
       * @param {object} options - A literal object with options to pass to the view
       */
      initialize(options) {
        // Apply all the options to this view
        if (typeof options === "object") {
          Object.assign(this, options);
        }

        // If no model is provided in the options, we cannot render this view. A
        // filter model cannot be created, because it must be part of a collection.
        if (!this.model || !this.model.collection) {
          throw new Error(
            "A Filter model that's part of a Filters collection is required to initialize a Query Rule view.",
          );
        }

        // The model may be removed during the save process if it's empty. Remove this
        // Rule Group view when that happens.
        this.stopListening(this.model, "remove");
        this.listenTo(this.model, "remove", () => {
          this.removeSelf();
        });
      },

      /**
       * render - Render the view
       * @returns {QueryRule}  Returns the view
       */
      render() {
        // Add the Rule number.
        // TODO: Also add the number of datasets related to rule
        this.addRuleInfo();
        this.stopListening(this.model.collection, "remove");
        this.listenTo(this.model.collection, "remove", this.updateRuleInfo);
        // Nested rules should also listen for changes in Filters of their parent Rule
        if (this.parentRule) {
          this.stopListening(this.parentRule.model.collection, "remove");
          this.listenTo(
            this.parentRule.model.collection,
            "remove",
            this.updateRuleInfo,
          );
        }

        // The remove button is needed for both FilterGroups and other Filter models
        this.addRemoveButton();

        // Render nested filter group views as another Query Builder.
        if (this.model.type === "FilterGroup") {
          this.$el.addClass("rule-group");

          // We must initialize a QueryBuilderView using the inline require syntax to
          // avoid the problem of circular dependencies. QueryRuleView requires
          // QueryBuilderView, and QueryBuilderView requires QueryRuleView. For more
          // info, see https://requirejs.org/docs/api.html#circular
          const QueryBuilderView = require("views/queryBuilder/QueryBuilderView");

          // The default
          let nestedLevelsAllowed = 1;
          // If we are adding a query builer, then it is a nested level. Subtract one
          // from the total levels allowed.
          if (typeof this.nestedLevelsAllowed === "number") {
            nestedLevelsAllowed = this.nestedLevelsAllowed - 1;
          }

          // If there is a special list of fields to exclude in nested Query Builders
          // (i.e. in nested FilterGroup models), then pass this list on as the
          // excludeFields list in the child QueryBuilder
          let { excludeFields } = this;
          if (
            this.nestedExcludeFields &amp;&amp;
            Array.isArray(this.nestedExcludeFields)
          ) {
            excludeFields = this.nestedExcludeFields;
          }

          // Insert QueryRuleView
          const ruleGroup = new QueryBuilderView({
            filterGroup: this.model,
            // Nested Query Rules have the same color as their parent rule
            ruleColorPalette: "inherit",
            excludeFields,
            specialFields: this.specialFields,
            parentRule: this,
            nestedLevelsAllowed,
          });
          this.el.append(ruleGroup.el);
          ruleGroup.render();
        } else {
          // For any other filter type... Add a metadata selector field whether the
          // rule is new or has already been created
          this.addFieldSelect();

          // Operator field and value field Add an operator input only for already
          // existing filters (For new filters, a metadata field needs to be selected
          // first)
          if (this.model.get("fields") &amp;&amp; this.model.get("fields").length) {
            this.addOperatorSelect();
            this.addValueSelect();
          }
        }

        return this;
      },

      /**
       * Insert container for the color-coded rule numbering.
       */
      addRuleInfo() {
        this.$indexEl = $(document.createElement("span"));
        this.$ruleInfoEl = $(document.createElement("div")).addClass(
          this.ruleInfoClass,
        );
        this.$ruleInfoEl.append(this.$indexEl);

        this.$el.append(this.$ruleInfoEl);
        this.updateRuleInfo();
      },

      /**
       * Selects a color from the {@link QueryRuleView#ruleColorPalette}, given an
       * index. If the index is greater than the length of the palette, then the palette
       * is effectively repeated until long enough (i.e. colours will be recycled). If
       * no index in provided, the first colour in the palette will be selected.
       * @param  {number} [index] - The position of the rule within the Filters
       * collection.
       * @param  {string} [defaultColor] - A default colour to use in case
       * there is problem with this function (hex color code beginning with '#').
       * @returns {string} - Returns a hex color code string
       */
      getPaletteColor(index = 0, defaultColor = "#57b39c") {
        try {
          // Allow the rule to inherit its color from the parent rule within which it's
          // nested
          if (this.ruleColorPalette === "inherit") {
            return null;
          }

          if (!this.ruleColorPalette || !this.ruleColorPalette.length) {
            return defaultColor;
          }

          const numCols = this.ruleColorPalette.length;
          const adjustedIndex = index % numCols;

          return this.ruleColorPalette[adjustedIndex];
        } catch {
          return defaultColor;
        }
      },

      /**
       * Adds or updates the color-coded Query Rule information displayed to the user.
       * This needs to be run when rules are added or removed. Rule information includes
       * the rule number, but may one day also display information such as the number of
       * results that there are for this individual rule.
       */
      updateRuleInfo() {
        // Rules are numbered in the order in which they appear in the Filters
        // collection, excluding any invisible filter models. Rules nested in Rule
        // Groups (within Filter Models) get numbered 3A, 3B, etc.
        let letter = "";
        let index = "";
        // If this is a filter model nested in a filter group
        if (this.parentRule) {
          index = this.parentRule.ruleNumber;
          const letterIndex = this.model.collection.visibleIndexOf(this.model);
          if (typeof letterIndex === "number") {
            letter = String.fromCharCode(94 + letterIndex + 3).toUpperCase();
          }
          // For top-level filter models
        } else {
          index = this.model.collection.visibleIndexOf(this.model);
        }

        if (typeof index === "number") {
          index += 1;
        }

        const ruleNumber = index + letter;

        // Set the rule number of the parent view to be accessed by any nested child
        // rules
        this.ruleNumber = ruleNumber;

        // if(this.model.type == "FilterGroup")
        if (ruleNumber &amp;&amp; ruleNumber.length) {
          this.$indexEl.text(`Rule ${ruleNumber}`);
        } else {
          this.$indexEl.text("");
          return;
        }
        const color = this.getPaletteColor(index);
        if (color) {
          this.el.style.setProperty("--rule-color", color);
        }
      },

      /**
       * addRemoveButton - Create and insert the button to remove the Query Rule
       */
      addRemoveButton() {
        const removeButton = $(
          `&lt;i id='${this.removeRuleID}${this.cid}' class='${this.removeClass} icon icon-remove' title='Remove this Query Rule'>&lt;/i>`,
        );
        this.el.append(removeButton[0]);
      },

      /**
       * Determines whether the filter model that this rule renders matches one of the
       * {@link QueryRuleView#specialFields special fields} set on this view. If it
       * does, returns the first special field object that matches. For a filter model
       * to match to one of the special fields, it must contain all of the fields listed
       * in the special field's "fields" property. If the special field has an array set
       * for "values", then the model's values must also exactly match the special
       * field's values.
       * @param  {string[]} [fields] - Optionally set a list of query fields to search
       * with. If not set, then the fields that are set on the view's filter model are
       * used.
       * @returns {SpecialField|null} - The matching special field, or null if no match
       * was found.
       * @since 2.15.0
       */
      getSpecialField(fields) {
        // Get information about the filter model (or used the fields passed to this
        // function)
        const originalSelectedFields = fields || this.model.get("fields");
        const selectedFields = _.clone(originalSelectedFields);
        const selectedValues = this.model.get("values");

        if (!this.specialFields || !Array.isArray(this.specialFields)) {
          return null;
        }

        const matchingSpecialField = _.find(
          this.specialFields,
          (specialField) => {
            let fieldsMatch = false;
            let mustMatchValues = false;
            let valuesMatch = false;

            // If *all* the fields in the fields array are present in the list
            // of fields that the special field represents, then count this as a match.
            const commonFields = _.intersection(
              specialField.fields,
              selectedFields,
            );
            if (commonFields.length === specialField.fields.length) {
              fieldsMatch = true;
            }

            // The selected value must *exactly match* if one is set in the special
            // field
            if (specialField.values) {
              mustMatchValues = true;
              valuesMatch = _.isEqual(specialField.values, selectedValues);
            }

            return (
              fieldsMatch &amp;&amp;
              (!mustMatchValues || (mustMatchValues &amp;&amp; valuesMatch))
            );
          },
          this,
        );

        // If this model matches one of the special fields, render it differently
        return matchingSpecialField || null;
      },
      /**
       * Converts a list of query field names to special field names based on matches
       * from the special fields defined. If a field matches a special field's subfields,
       * it is replaced by the special field name.
       * @param {string[]} fields - The list of field names to convert
       * @returns {string[]} - The converted list of field names. If no special fields are
       * detected, then the field names are returned unchanged.
       */
      convertToSpecialFields(fields) {
        let fieldsCopy = [...fields];

        // Helper function to replace fields with a special field name
        const replaceWithSpecialField = (originalFields, specialField) => {
          const position = originalFields.findIndex((field) =>
            specialField.fields.includes(field),
          );
          if (position !== -1) {
            originalFields.splice(
              position,
              specialField.fields.length,
              specialField.name,
            );
          }
          return originalFields;
        };

        // Iterate over each selected special field to transform the fields array
        if (this.selectedSpecialFields &amp;&amp; this.selectedSpecialFields.length) {
          this.selectedSpecialFields.forEach((specialField) => {
            fieldsCopy = replaceWithSpecialField(fieldsCopy, specialField);
          });
        }

        // Replace any remaining matches
        let matchingSpecialField = this.getSpecialField(fieldsCopy);
        while (matchingSpecialField) {
          fieldsCopy = replaceWithSpecialField(
            fieldsCopy,
            matchingSpecialField,
          );
          matchingSpecialField = this.getSpecialField(fieldsCopy);
        }

        return fieldsCopy;
      },

      /**
       * Takes a list of query field names and checks if it contains any of the
       * {@link QueryRuleView#specialFields special field names}. Returns the list with
       * the special field names replaced with the actual field names that those special
       * fields represent. Stores the name of each special field name removed in an
       * array set on the view's selectedSpecialFields property. selectedSpecialFields
       * is cleared each time this function runs. This function is the opposite of
       * {@link QueryRuleView#convertToSpecialFields}
       * @param {string[]} fields - The list of fields to convert to actual query
       * service index fields
       * @returns {string[]} - Returns the list of fields with any special field
       * replaced with real fields from the query service index.  If there were no
       * special fields detected, or if there's an error, then then the field names are
       * returned unchanged.
       * @since 2.15.0
       */
      convertFromSpecialFields(fields) {
        try {
          this.selectedSpecialFields = [];
          if (this.specialFields) {
            this.specialFields.forEach((specialField) => {
              const index = fields.indexOf(specialField.name);
              if (index >= 0) {
                // Keep a record that the user selected a special field (useful in the
                // case that the special field is just a duplicate of another field)
                this.selectedSpecialFields.push(specialField);
                fields.splice(index, 1, ...specialField.fields);
              }
            }, this);
          }
          return fields;
        } catch (error) {
          return fields;
        }
      },

      /**
       * Create and insert an input that allows the user to select a metadata field to
       * query
       */
      addFieldSelect() {
        // Check whether the filter model set on this view contains query fields
        // and values that match one of the special rules. If it does,
        // convert the list of field names to special field to pass on to the
        // Query Field Select View.
        let selectedFields = _.clone(this.model.get("fields"));
        selectedFields = this.convertToSpecialFields(selectedFields);

        this.fieldSelect = new QueryFieldSelect({
          selected: selectedFields,
          excludeFields: this.excludeFields,
          addFields: this.specialFields,
          separator: this.model.get("fieldsOperator"),
        });
        this.fieldSelect.$el.addClass(this.fieldsClass);
        this.el.append(this.fieldSelect.el);
        this.fieldSelect.render();

        // Update the model when the fieldsOperator changes
        this.stopListening(this.fieldSelect.model, "change:separator");
        this.listenTo(
          this.fieldSelect.model,
          "change:separator",
          (_model, newOperator) => {
            this.model.set("fieldsOperator", newOperator);
          },
        );
        // Update model when the selected fields change
        this.stopListening(this.fieldSelect.model, "change:selected");
        this.listenTo(
          this.fieldSelect.model,
          "change:selected",
          (_model, fields) => {
            this.handleFieldChange(fields);
          },
        );
      },

      /**
       * Called when the Query Field Select View triggers a change
       * event. Updates the model with the new fields, and if required,
       * 1) converts the filter model to a different type based on the types of fields
       * selected, 2) updates the operator select and the value select
       * @param  {string[]} fields The list of new query fields that were selected
       */
      handleFieldChange(fields) {
        // Get the selected operator before the field changed
        const opBefore = this.getSelectedOperator();

        // If any of the new fields are special fields, replace them with the
        // actual query fields before setting them in the model...
        const newFields = this.convertFromSpecialFields(fields);

        // Get the current type of filter and required type given the newly selected
        // fields
        const typeBefore = this.model.get("nodeName");
        const typeAfter =
          MetacatUI.queryFields.getRequiredFilterType(newFields);

        // If the type has changed, then replace the model with one of the correct
        // type, update the value and operator inputs, and do nothing else
        if (typeBefore !== typeAfter) {
          this.model = this.model.collection.replaceModel(this.model, {
            filterType: typeAfter,
            fields: newFields,
          });
          this.removeInput("value");
          this.removeInput("operator");
          this.addOperatorSelect("");
          return;
        }

        // If the filter model type is the same, and the operator options are the same
        // for the selected fields, then update the model
        this.model.set("fields", newFields);

        // Get the selected operator now that we've updated the model with new fields
        const opAfter = this.getSelectedOperator();

        // Add an empty operator input field, if there isn't one
        if (!this.operatorSelect) {
          this.addOperatorSelect("");
          // If the operator options have changed, refresh the operator input
        } else if (opAfter !== opBefore) {
          this.removeInput("operator");
          // Make sure that we overwrite any values that don't apply to the new options.
          this.handleOperatorChange([""]);
          this.addOperatorSelect("");
          return;
        }

        // Refresh the value select in case a different value input is required for
        // the new fields
        if (this.valueSelect) {
          this.removeInput("value");
          this.addValueSelect();
        }
      },

      /**
       * Create and insert an input field where the user can select an operator for the
       * given rule. Operators will vary depending on filter model type.
       * @param {string} operator - optional. The label of an operator to
       * pre-select. Set to an empty string to render an empty operator selector.
       */
      addOperatorSelect(operator) {
        const view = this;
        const options = this.getOperatorOptions();
        let operatorError = false;
        let selectedOperator = operator;

        // Identify the selected operator for existing models
        if (typeof selectedOperator !== "string") {
          selectedOperator = this.getSelectedOperator();
          // If there was no operator found, then this is probably an unsupported
          // combination of exclude + matchSubstring + filterType
          if (selectedOperator === "") {
            operatorError = true;
          }
        }

        if (selectedOperator === "") {
          selectedOperator = [];
        } else {
          selectedOperator = [selectedOperator];
        }

        this.operatorSelect = new SearchSelect({
          options,
          allowMulti: false,
          inputLabel: "Select an operator",
          clearable: false,
          placeholderText: "Select an operator",
          selected: selectedOperator,
        });
        this.operatorSelect.$el.addClass(this.operatorClass);
        this.el.append(this.operatorSelect.el);

        this.operatorSelect.render();

        if (operatorError) {
          view.operatorSelect.showInvalidSelectionError();
        }

        // Update model when the values change
        this.stopListening(this.operatorSelect.model, "change:selected");
        this.listenTo(
          this.operatorSelect.model,
          "change:selected",
          (_model, newOperator) => {
            this.handleOperatorChange(newOperator);
          },
        );
      },

      /**
       * handleOperatorChange - When the operator selection is changed, update the model
       * and re-set the value UI when required
       * @param  {string[]} newOperatorLabel The new operator label within an array,
       * e.g. ["is greater than"]
       */
      handleOperatorChange(newOperatorLabel) {
        const view = this;

        if (!newOperatorLabel || newOperatorLabel[0] === "") {
          const modelDefaults = this.model.defaults();
          this.model.set({
            min: modelDefaults.min,
            max: modelDefaults.max,
            values: modelDefaults.values,
          });
          this.removeInput("value");
          return;
        }

        // Get the properties of the newly selected operator. The newOperatorLabel
        // will be an array with one value. Select only from the available options,
        // since there may be multiple options with the same label in
        // this.operatorOptions.
        const options = this.getOperatorOptions();
        const operator = _.findWhere(options, { label: newOperatorLabel[0] });

        // Gather  information about which values are currently set on the model, and
        // which are required
        const // Type
          type = view.model.get("nodeName");
        const isNumeric = ["dateFilter", "numericFilter"].includes(type);
        const isRange = operator.hasMin &amp;&amp; operator.hasMax;
        // Values
        const modelValues = this.model.get("values");
        const modelHasValues = modelValues
          ? modelValues &amp;&amp; modelValues.length
          : false;
        const modelFirstValue = modelHasValues ? modelValues[0] : null;
        const modelValueInt = parseInt(modelFirstValue, 10)
          ? parseInt(modelFirstValue, 10)
          : null;
        const needsValue =
          isNumeric &amp;&amp; !modelValueInt &amp;&amp; !operator.hasMin &amp;&amp; !operator.hasMax;
        // Min
        const modelMin = this.model.get("min");
        const modelHasMin = modelMin === 0 || modelMin;
        const needsMin = operator.hasMin &amp;&amp; !modelHasMin;
        // Max
        const modelMax = this.model.get("max");
        const modelHasMax = modelMax === 0 || modelMax;
        const needsMax = operator.hasMax &amp;&amp; !modelHasMax;

        // Some operator options include a specific value to be set on the model. For
        // example, "is not empty", should set the model value to the "*" wildcard.
        // For operators with these specific value requirements, update the filter
        // model value and remove the value select input.
        if (operator.values &amp;&amp; operator.values.length) {
          this.removeInput("value");
          this.model.set("values", operator.values);
          // If the operator does not have a default value, then ensure that there is
          // a value select available.
        } else if (!this.valueSelect) {
          this.model.set("values", view.model.defaults().values);
          this.addValueSelect();
        }

        // Update the model with true or false for matchSubstring and exclude
        ["matchSubstring", "exclude"].forEach((prop) => {
          if (typeof operator[prop] !== "undefined") {
            view.model.set(prop, operator[prop]);
          } else {
            view.model.set(prop, view.model.defaults()[prop]);
          }
        });

        // Set min &amp; max values as required by the operator
        // TODO - test this strategy with dates...

        // Add a minimum value if one is needed
        if (needsMin) {
          // Search for the min in the values, then in the max
          if (modelValueInt || modelValueInt === 0) {
            this.model.set("min", modelValueInt);
          } else if (modelHasMax) {
            this.model.set("min", modelMax);
          } else {
            this.model.set("min", 0);
          }
        }

        // Add a maximum value if one is needed
        if (needsMax) {
          // Search for the min in the values, then in the max
          if (modelValueInt || modelValueInt === 0) {
            this.model.set("max", modelValueInt);
          } else if (modelHasMin) {
            this.model.set("max", modelMin);
          } else {
            this.model.set("max", 0);
          }
        }

        // Add a value if one is needed
        if (needsValue) {
          if (modelHasMin) {
            this.model.set("values", [modelMin]);
          } else if (modelHasMax) {
            this.model.set("values", [modelMax]);
          } else {
            this.model.set("values", [0]);
          }
        }

        // Remove the minimum and max if they should not be included in the filter
        if (modelHasMax &amp;&amp; !operator.hasMax) {
          this.model.set("max", this.model.defaults().max);
        }
        if (modelHasMin &amp;&amp; !operator.hasMin) {
          this.model.set("min", this.model.defaults().min);
        }

        if (isRange) {
          this.model.set("range", true);
        } else if (isNumeric) {
          this.model.set("range", false);
        } else {
          this.model.unset("range");
        }

        // If the operator changed for a numeric or date field, reset the value
        // select. This way it can change from a range to a single value input if
        // needed.
        if (isNumeric) {
          this.removeInput("value");
          this.addValueSelect();
        }
      },

      /**
       * Get a list of {@link QueryRuleView#operatorOptions operatorOptions} that are
       * allowed for this view's filter model
       * @param  {string[]} [inputFields] - Optional list of fields to use instead of the
       * fields set on this view's Filter model
       * @returns {object[]} - Returns an array of operator options that are allowed for
       * this view's filter model
       * @since 2.15.0
       */
      getOperatorOptions(inputFields) {
        // Check which type of rule this is (boolean, numeric, text, date)
        const type = this.model.get("nodeName");

        // If this rule contains a special field, replace the real query field names
        // with the special field names for the purpose of selecting operator options
        let fields = inputFields || this.model.get("fields");
        fields = _.clone(fields);
        fields = this.convertToSpecialFields(fields);

        // Get the list of options for a user to select from based on field name.
        // All of the rule's fields must be contained within the operator option's
        // list of allowed fields for it to be a match.
        let options = _.filter(this.operatorOptions, (option) => {
          if (option.fields) {
            return _.every(fields, (fieldName) =>
              option.fields.includes(fieldName),
            );
          }
          return false;
        });

        // Function to check if option types include the specified type
        const includesType = (option) =>
          option.types &amp;&amp; option.types.includes(type);

        // Get the list of options for a user to select from based on type, if there
        // were none that matched based on field names
        if (!options || !options.length) {
          options = this.operatorOptions.filter(includesType);
        }

        return options;
      },

      /**
       * getSelectedOperator - Based on values set on the model, get the label to show
       * in the "operator" filed of the Query Rule
       * @returns {string} The operator label
       */
      getSelectedOperator() {
        // This view
        const view = this;
        // The user-facing operator label that we will return
        let selectedOperator = "";

        // --- Filter 1 - Filter options by type --- //

        // Reduce list of options to only  those that apply to the current filter type
        const type = view.model.get("nodeName");
        let operatorOptions = this.getOperatorOptions();

        // --- Filter 2 - filter by 'matchSubstring', 'exclude', 'min', 'max' --- //

        // Create the conditions based on the model
        const conditions = _.pick(
          this.model.attributes,
          "matchSubstring",
          "exclude",
          "min",
          "max",
        );

        const isNumeric = ["dateFilter", "numericFilter"].includes(type);

        if (!conditions.min &amp;&amp; conditions.min !== 0) {
          if (isNumeric) {
            conditions.hasMin = false;
          }
        } else if (isNumeric) {
          conditions.hasMin = true;
        }
        if (!conditions.max &amp;&amp; conditions.max !== 0) {
          if (isNumeric) {
            conditions.hasMax = false;
          }
        } else if (isNumeric) {
          conditions.hasMax = true;
        }

        delete conditions.min;
        delete conditions.max;

        operatorOptions = _.where(operatorOptions, conditions);

        // --- Filter 3 - filter based on the value, if there's > 1 option --- //

        if (operatorOptions.length > 1) {
          // Model values that determine the user-facing operator eg ["*"], [true],
          // [false]
          let specialValues = _.compact(
            _.pluck(this.operatorOptions, "values"),
          );
          specialValues = specialValues.map((val) => JSON.stringify(val));
          specialValues = _.uniq(specialValues);

          const modelValues = view.model.get("values");
          const modelValuesString = JSON.stringify(modelValues);

          operatorOptions = operatorOptions.filter((option) => {
            if (!option.values) return true; // Filter in options without values
            if (!specialValues.includes(modelValuesString)) return false; // If model values not special, filter out
            return JSON.stringify(option.values) === modelValuesString; // Check exact match for special values
          });
        }
        // --- Return value --- //

        if (operatorOptions.length === 1) {
          selectedOperator = operatorOptions[0].label;
        }

        return selectedOperator;
      },

      /**
       * getCategory - Given an array of query fields, get the user-facing category that
       * these fields belong to. If there are fields from multiple categories, then a
       * default "Text" category is returned.
       * @param  {string[]} fields An array of query (Solr) fields
       * @returns {string} The label for the category that the given fields belong to
       */
      getCategory(fields) {
        const categories = [];
        // When fields is empty or are different types
        const defaultCategory = "Text";

        if (!fields || fields.length === 0 || fields[0] === "") {
          return defaultCategory;
        }

        fields.forEach((field) => {
          // Get the category of the field from the matching filter model in the Query
          // Fields Collection
          const fieldModel = MetacatUI.queryFields.findWhere({ name: field });
          categories.push(fieldModel.get("category"));
        });

        // Test of all the fields are of the same type
        const allEqual = categories.every((val, i, arr) => val === arr[0]);

        if (allEqual) {
          return categories[0];
        }
        return defaultCategory;
      },

      /**
       * Create and insert an input field where the user can provide a search value
       */
      addValueSelect() {
        const view = this;
        const fields = this.model.get("fields");
        const filterType = MetacatUI.queryFields.getRequiredFilterType(fields);
        const category = this.getCategory(fields);
        const interfaces = this.valueSelectUImap;
        let label = "";

        // To help guide users to create valid queries, the type of value field will
        // vary based on the type of field (i.e. filter nodeName), and the operator
        // selected.

        // Some user-facing operators (e.g. "is true") don't require a value to be set
        const selectedOperator = _.findWhere(this.operatorOptions, {
          label: this.getSelectedOperator(),
        });
        if (selectedOperator) {
          if (selectedOperator.values &amp;&amp; selectedOperator.values.length) {
            return;
          }
        }

        // Find the appropriate UI to use the the value select field. Find the first
        // match in the valueSelectUImap according to the filter type and the
        // categories associated with the metadata field.
        const interfaceProperties = _.find(interfaces, (thisInterface) => {
          let typesMatch = true;
          let categoriesMatch = true;
          let namesMatch = true;
          if (thisInterface.queryFields &amp;&amp; thisInterface.queryFields.length) {
            fields.forEach((field) => {
              if (thisInterface.queryFields.includes(field) === false) {
                namesMatch = false;
              }
            });
          }
          if (thisInterface.filterTypes &amp;&amp; thisInterface.filterTypes.length) {
            typesMatch = thisInterface.filterTypes.includes(filterType);
          }
          if (thisInterface.categories &amp;&amp; thisInterface.categories.length) {
            categoriesMatch = thisInterface.categories.includes(category);
          }
          return typesMatch &amp;&amp; categoriesMatch &amp;&amp; namesMatch;
        });

        this.valueSelect = interfaceProperties.uiFunction.call(this);
        if (interfaceProperties.label &amp;&amp; interfaceProperties.label.length) {
          label = $(
            `&lt;p class='subtle search-select-label'>${interfaceProperties.label}&lt;/p>`,
          );
        }

        // Append and render the chosen value selector
        this.el.append(view.valueSelect.el);
        this.valueSelect.$el.addClass(this.valuesClass);
        view.valueSelect.render();
        if (label) {
          view.valueSelect.$el.prepend(label);
        }

        // Make sure the listeners set below are not set multiple times
        this.stopListening(
          view.valueSelect.model,
          "change:selected change:separator",
        );
        this.stopListening(view.valueSelect.model, "change:lastInteraction");

        // Update model when the values change - note that the date &amp; numeric filter
        // views do not trigger a 'change:selected' event, (because they are not based
        // on a SearchSelect View) but update the models directly
        this.listenTo(
          view.valueSelect.model,
          "change:selected",
          (_model, newValues) => {
            this.handleValueChange(newValues);
          },
        );

        // Update the model when the operator changes
        this.listenTo(
          view.valueSelect.model,
          "change:separator",
          (_model, newOperator) => {
            this.model.set("operator", newOperator);
          },
        );

        // Show a message that reminds the user that capitalization matters when they
        // are typing a value for a field that is case-sensitive.
        this.listenTo(
          view.valueSelect.model,
          "change:lastInteraction",
          (model, interaction) => {
            if (interaction !== "focus") return;
            const currentFields = view.model.get("fields");
            const isCaseSensitive = _.some(currentFields, (field) =>
              MetacatUI.queryFields.findWhere({
                name: field,
                caseSensitive: true,
              }),
            );

            if (isCaseSensitive) {
              let fieldsText = "The field";
              if (currentFields.length > 1) {
                fieldsText = "At least one of the fields";
              }

              const message = `&lt;i class='icon-lightbulb icon-on-left'>&lt;/i> &lt;b>Hint:&lt;/b> ${fieldsText} you selected is case-sensitive. Capitalization matters here.`;
              view.valueSelect.showMessage(message, "info", false);
            } else {
              view.valueSelect.removeMessages();
            }
          },
        );
      },

      /**
       * handleValueChange - Called when the select values for rule are changed. Updates
       * the model.
       * @param  {string[]} newValues The new values that were selected
       */
      handleValueChange(newValues) {
        // TODO: validate values
        // Don't add empty values to the model
        const filteredValues = _.reject(newValues, (val) => val === "");
        this.model.set("values", filteredValues);
      },

      /**
       * Remove one of the three input fields from the rule
       * @param  {string} inputType Which of the inputs to remove? "field", "operator",
       * or "value"
       */
      removeInput(inputType) {
        // TODO - what, if any, model updates should happen here?
        switch (inputType) {
          case "value":
            if (this.valueSelect) {
              this.stopListening(this.valueSelect.model, "change:selected");
              this.stopListening(
                this.valueSelect.model,
                "change:lastInteraction",
              );
              this.valueSelect.remove();
              this.valueSelect = null;
            }
            break;
          case "operator":
            if (this.operatorSelect) {
              this.stopListening(this.operatorSelect.model, "change:selected");
              this.operatorSelect.remove();
              this.operatorSelect = null;
            }
            break;
          case "field":
            if (this.fieldSelect) {
              this.stopListening(this.fieldSelect.model, "change:selected");
              this.fieldSelect.remove();
              this.fieldSelect = null;
            }
            break;
          default:
            break;
        }
      },

      /**
       * Indicate to the user that the rule will be removed when they hover over the
       * remove button.
       * @param {Event} e The mouseover or mouseout event
       */
      previewRemove(e) {
        const normalOpacity = 1.0;
        const previewOpacity = 0.2;
        const speed = 175;

        const removeEl = e.target;
        const subElements = this.$el.children().not(removeEl);

        if (e.type === "mouseover") {
          subElements.fadeTo(speed, previewOpacity);
          $(removeEl).fadeTo(speed, normalOpacity);
        }
        if (e.type === "mouseout") {
          subElements.fadeTo(speed, normalOpacity);
          $(removeEl).fadeTo(speed, previewOpacity);
        }
      },

      /**
       * removeSelf - When the delete button is clicked, remove this entire View and
       * associated model
       */
      removeSelf() {
        $("body .popover").remove();
        $("body .tooltip").remove();
        if (this.model &amp;&amp; this.model.collection) {
          this.model.collection.remove(this.model);
        }
        this.remove();
      },
    },
  ));
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
