<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>MetacatUI Dev Docs: Source: src/js/models/portals/PortalModel.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="/metacatui/assets/css/styles.css">
    <link type="text/css" rel="stylesheet" href="styles/style.css">
</head>

<body>

<nav id="nav">
    <a href="/">
      <div class="logo">
<svg class="cat" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="cat" class="svg-inline--fa fa-cat fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M290.59 192c-20.18 0-106.82 1.98-162.59 85.95V192c0-52.94-43.06-96-96-96-17.67 0-32 14.33-32 32s14.33 32 32 32c17.64 0 32 14.36 32 32v256c0 35.3 28.7 64 64 64h176c8.84 0 16-7.16 16-16v-16c0-17.67-14.33-32-32-32h-32l128-96v144c0 8.84 7.16 16 16 16h32c8.84 0 16-7.16 16-16V289.86c-10.29 2.67-20.89 4.54-32 4.54-61.81 0-113.52-44.05-125.41-102.4zM448 96h-64l-64-64v134.4c0 53.02 42.98 96 96 96s96-42.98 96-96V32l-64 64zm-72 80c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16zm80 0c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16z"></path></svg>

<svg width="459px" height="53px" viewBox="0 0 459 53" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="metacatui" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M16.492,52 C17.212,52 17.812,51.748 18.292,51.244 C18.772,50.74 19.012,50.128 19.012,49.408 L19.012,49.408 L18.94,22.912 L30.82,37.816 C31.204,38.344 31.72,38.764 32.368,39.076 C33.016,39.388 33.7,39.544 34.42,39.544 C35.908,39.544 37.132,38.896 38.092,37.6 L38.092,37.6 L49.684,22.912 L49.684,49.408 C49.684,50.128 49.96,50.74 50.512,51.244 C51.064,51.748 51.7,52 52.42,52 L52.42,52 L62.068,52 C62.788,52 63.388,51.748 63.868,51.244 C64.348,50.74 64.588,50.128 64.588,49.408 L64.588,49.408 L64.588,4.12 C64.588,3.448 64.336,2.86 63.832,2.356 C63.328,1.852 62.74,1.6 62.068,1.6 L62.068,1.6 L52.348,1.6 C51.388,1.6 50.56,1.648 49.864,1.744 C49.168,1.84 48.532,2.152 47.956,2.68 L47.956,2.68 L33.916,17.296 L20.524,2.608 C20.332,2.368 19.972,2.14 19.444,1.924 C18.916,1.708 18.412,1.6 17.932,1.6 L17.932,1.6 L6.772,1.6 C6.052,1.6 5.44,1.852 4.936,2.356 C4.432,2.86 4.18,3.448 4.18,4.12 L4.18,4.12 L4.18,49.408 C4.18,50.08 4.432,50.68 4.936,51.208 C5.44,51.736 6.052,52 6.772,52 L6.772,52 L16.492,52 Z M110.74,52 C111.556,52 112.264,51.676 112.864,51.028 C113.464,50.38 113.764,49.624 113.764,48.76 L113.764,48.76 L113.764,42.568 C113.764,41.608 113.464,40.828 112.864,40.228 C112.264,39.628 111.556,39.328 110.74,39.328 L110.74,39.328 L89.428,39.328 L89.428,32.92 L109.732,32.92 C110.5,32.92 111.184,32.596 111.784,31.948 C112.384,31.3 112.684,30.568 112.684,29.752 L112.684,29.752 L112.684,23.488 C112.684,22.576 112.384,21.82 111.784,21.22 C111.184,20.62 110.5,20.32 109.732,20.32 L109.732,20.32 L89.428,20.32 L89.428,14.488 L110.74,14.488 C111.508,14.488 112.204,14.164 112.828,13.516 C113.452,12.868 113.764,12.136 113.764,11.32 L113.764,11.32 L113.764,5.056 C113.764,4.144 113.464,3.388 112.864,2.788 C112.264,2.188 111.556,1.888 110.74,1.888 L110.74,1.888 L76.756,1.888 C75.94,1.888 75.232,2.188 74.632,2.788 C74.032,3.388 73.732,4.144 73.732,5.056 L73.732,5.056 L73.732,48.76 C73.732,49.624 74.032,50.38 74.632,51.028 C75.232,51.676 75.94,52 76.756,52 L76.756,52 L110.74,52 Z M147.604,52 C148.42,52 149.104,51.688 149.656,51.064 C150.208,50.44 150.484,49.672 150.484,48.76 L150.484,48.76 L150.484,16.216 L161.86,16.216 C162.676,16.216 163.396,15.904 164.02,15.28 C164.644,14.656 164.956,13.936 164.956,13.12 L164.956,13.12 L164.956,4.768 C164.956,4 164.644,3.316 164.02,2.716 C163.396,2.116 162.676,1.816 161.86,1.816 L161.86,1.816 L124.132,1.816 C123.22,1.816 122.464,2.104 121.864,2.68 C121.264,3.256 120.964,3.952 120.964,4.768 L120.964,4.768 L120.964,13.12 C120.964,13.936 121.264,14.656 121.864,15.28 C122.464,15.904 123.22,16.216 124.132,16.216 L124.132,16.216 L135.652,16.216 L135.148,48.832 C135.148,49.744 135.424,50.5 135.976,51.1 C136.528,51.7 137.212,52 138.028,52 L138.028,52 L147.604,52 Z M175.828,52 C176.836,52 177.676,51.82 178.348,51.46 C179.02,51.1 179.452,50.584 179.644,49.912 L179.644,49.912 L181.876,42.712 L197.932,42.712 L200.164,49.912 C200.356,50.584 200.8,51.1 201.496,51.46 C202.192,51.82 203.044,52 204.052,52 L204.052,52 L213.916,52 C215.836,51.712 216.796,50.704 216.796,48.976 C216.796,48.304 216.676,47.596 216.436,46.852 C216.196,46.108 216.052,45.616 216.004,45.376 L216.004,45.376 L199.876,4.84 C199.588,3.976 199.036,3.232 198.22,2.608 C197.404,1.984 196.372,1.648 195.124,1.6 L195.124,1.6 L184.756,1.6 C183.604,1.648 182.608,1.948 181.768,2.5 C180.928,3.052 180.292,3.832 179.86,4.84 L179.86,4.84 L163.876,45.376 C163.828,45.472 163.672,45.916 163.408,46.708 C163.144,47.5 163.012,48.304 163.012,49.12 C163.012,50.752 163.948,51.712 165.82,52 L165.82,52 L175.828,52 Z M195.34,30.544 L184.036,30.544 L189.652,13.624 L195.34,30.544 Z M245.38,53.08 C250.612,53.08 255.652,51.544 260.5,48.472 C261.22,47.944 261.58,47.296 261.58,46.528 C261.58,45.808 261.292,45.16 260.716,44.584 L260.716,44.584 L252.796,36.808 C252.364,36.376 251.836,36.16 251.212,36.16 C250.78,36.16 250.372,36.256 249.988,36.448 C248.356,37.12 246.796,37.456 245.308,37.456 C243.244,37.456 241.348,36.952 239.62,35.944 C237.892,34.936 236.512,33.58 235.48,31.876 C234.448,30.172 233.932,28.336 233.932,26.368 C233.932,24.352 234.436,22.504 235.444,20.824 C236.452,19.144 237.832,17.812 239.584,16.828 C241.336,15.844 243.244,15.352 245.308,15.352 C246.892,15.352 248.332,15.64 249.628,16.216 C250.012,16.408 250.444,16.504 250.924,16.504 C251.548,16.504 252.1,16.264 252.58,15.784 L252.58,15.784 L259.636,8.008 C260.164,7.384 260.428,6.76 260.428,6.136 C260.428,5.224 259.996,4.528 259.132,4.048 C254.86,1.552 250.276,0.304 245.38,0.304 C240.532,0.304 236.032,1.492 231.88,3.868 C227.728,6.244 224.44,9.448 222.016,13.48 C219.592,17.512 218.38,21.904 218.38,26.656 C218.38,31.408 219.592,35.812 222.016,39.868 C224.44,43.924 227.728,47.14 231.88,49.516 C236.032,51.892 240.532,53.08 245.38,53.08 Z M279.796,52 C280.804,52 281.644,51.82 282.316,51.46 C282.988,51.1 283.42,50.584 283.612,49.912 L283.612,49.912 L285.844,42.712 L301.9,42.712 L304.132,49.912 C304.324,50.584 304.768,51.1 305.464,51.46 C306.16,51.82 307.012,52 308.02,52 L308.02,52 L317.884,52 C319.804,51.712 320.764,50.704 320.764,48.976 C320.764,48.304 320.644,47.596 320.404,46.852 C320.164,46.108 320.02,45.616 319.972,45.376 L319.972,45.376 L303.844,4.84 C303.556,3.976 303.004,3.232 302.188,2.608 C301.372,1.984 300.34,1.648 299.092,1.6 L299.092,1.6 L288.724,1.6 C287.572,1.648 286.576,1.948 285.736,2.5 C284.896,3.052 284.26,3.832 283.828,4.84 L283.828,4.84 L267.844,45.376 C267.796,45.472 267.64,45.916 267.376,46.708 C267.112,47.5 266.98,48.304 266.98,49.12 C266.98,50.752 267.916,51.712 269.788,52 L269.788,52 L279.796,52 Z M299.308,30.544 L288.004,30.544 L293.62,13.624 L299.308,30.544 Z M352.588,52 C353.404,52 354.088,51.688 354.64,51.064 C355.192,50.44 355.468,49.672 355.468,48.76 L355.468,48.76 L355.468,16.216 L366.844,16.216 C367.66,16.216 368.38,15.904 369.004,15.28 C369.628,14.656 369.94,13.936 369.94,13.12 L369.94,13.12 L369.94,4.768 C369.94,4 369.628,3.316 369.004,2.716 C368.38,2.116 367.66,1.816 366.844,1.816 L366.844,1.816 L329.116,1.816 C328.204,1.816 327.448,2.104 326.848,2.68 C326.248,3.256 325.948,3.952 325.948,4.768 L325.948,4.768 L325.948,13.12 C325.948,13.936 326.248,14.656 326.848,15.28 C327.448,15.904 328.204,16.216 329.116,16.216 L329.116,16.216 L340.636,16.216 L340.132,48.832 C340.132,49.744 340.408,50.5 340.96,51.1 C341.512,51.7 342.196,52 343.012,52 L343.012,52 L352.588,52 Z M402.052,52.792 C408.1,52.792 412.912,51.628 416.488,49.3 C420.064,46.972 422.536,44.068 423.904,40.588 C425.272,37.108 425.932,33.424 425.884,29.536 C425.884,29.5309474 425.883967,29.5237673 425.8839,29.5144598 L425.883102,29.4330859 C425.879911,29.1480111 425.868211,28.3183158 425.848,26.944 C425.8294,25.6792 425.818008,22.91524 425.813823,18.65212 L425.813103,17.80828 C425.812997,17.66452 425.8129,17.5192 425.81281,17.37232 L425.812,3.904 C425.86,3.184 425.632,2.62 425.128,2.212 C424.624,1.804 423.916,1.6 423.004,1.6 L423.004,1.6 L413.428,1.6 C412.612,1.6 411.904,1.828 411.304,2.284 C410.704,2.74 410.404,3.28 410.404,3.904 L410.404,3.904 L410.26,27.808 C410.26,34.144 407.476,37.312 401.908,37.312 C399.076,37.312 396.832,36.412 395.176,34.612 C393.52,32.812 392.668,30.352 392.62,27.232 L392.62,27.232 L392.332,3.76 C392.332,3.088 392.068,2.56 391.54,2.176 C391.012,1.792 390.268,1.6 389.308,1.6 L389.308,1.6 L379.876,1.6 C378.244,1.6 377.428,2.32 377.428,3.76 L377.428,3.76 L377.5,28.816 C377.5,33.04 378.376,36.964 380.128,40.588 C381.88,44.212 384.592,47.152 388.264,49.408 C391.936,51.664 396.532,52.792 402.052,52.792 Z M449.284,52.144 C450.148,52.144 450.88,51.844 451.48,51.244 C452.08,50.644 452.38,49.84 452.38,48.832 L452.38,48.832 L452.38,4.912 C452.38,4 452.08,3.22 451.48,2.572 C450.88,1.924 450.148,1.6 449.284,1.6 L449.284,1.6 L439.42,1.6 C438.46,1.6 437.692,1.924 437.116,2.572 C436.54,3.22 436.252,4 436.252,4.912 L436.252,4.912 L436.252,48.832 C436.252,49.84 436.54,50.644 437.116,51.244 C437.692,51.844 438.46,52.144 439.42,52.144 L439.42,52.144 L449.284,52.144 Z" id="metacatui" fill="#FCBF49" fill-rule="nonzero"></path>
    </g>
</svg>
</logo>

    </a>
    <h3>Namespaces</h3><ul><li><a href="AppConfig.html">AppConfig</a></li><li><a href="IconUtilities.html">IconUtilities</a></li><li><a href="MapConfig.html">MapConfig</a></li><li><a href="MetacatUI.html">MetacatUI</a></li><li><a href="Utilities.html">Utilities</a></li></ul><h3>Classes</h3><ul><li class='category-heading' data-category='Collections'>Collections</li><li><a href="AccessPolicy.html">AccessPolicy</a></li><li><a href="Citations.html">Citations</a></li><li><a href="DataPackage.html">DataPackage</a></li><li><a href="Filters.html">Filters</a></li><li><a href="ObjectFormats.html">ObjectFormats</a></li><li><a href="ProjectList.html">ProjectList</a></li><li><a href="QualityReport.html">QualityReport</a></li><li><a href="SolrResults.html">SolrResults</a></li><li><a href="Units.html">Units</a></li><li><a href="UserGroup.html">UserGroup</a></li><li class='category-heading' data-category='Collections/Bookkeeper'>Collections/Bookkeeper</li><li><a href="Quotas.html">Quotas</a></li><li><a href="Usages.html">Usages</a></li><li class='category-heading' data-category='Collections/Geohashes'>Collections/Geohashes</li><li><a href="Geohashes.html">Geohashes</a></li><li class='category-heading' data-category='Collections/Maps'>Collections/Maps</li><li><a href="AssetCategories.html">AssetCategories</a></li><li><a href="AssetColors.html">AssetColors</a></li><li><a href="Features.html">Features</a></li><li><a href="GeoPoints.html">GeoPoints</a></li><li><a href="MapAssets.html">MapAssets</a></li><li><a href="VectorFilters.html">VectorFilters</a></li><li><a href="ZoomPresets.html">ZoomPresets</a></li><li class='category-heading' data-category='Collections/Metadata/EML'>Collections/Metadata/EML</li><li><a href="EMLAnnotations.html">EMLAnnotations</a></li><li><a href="EMLMissingValueCodes.html">EMLMissingValueCodes</a></li><li class='category-heading' data-category='Collections/QueryFields'>Collections/QueryFields</li><li><a href="QueryFields.html">QueryFields</a></li><li class='category-heading' data-category='Models'>Models</li><li><a href="AccessRule.html">AccessRule</a></li><li><a href="AppModel.html">AppModel</a></li><li><a href="CitationModel.html">CitationModel</a></li><li><a href="CollectionModel.html">CollectionModel</a></li><li><a href="DataONEObject.html">DataONEObject</a></li><li><a href="LookupModel.html">LookupModel</a></li><li><a href="Map.html">Map</a></li><li><a href="Metrics.html">Metrics</a></li><li><a href="QualityCheck.html">QualityCheck</a></li><li><a href="Search.html">Search</a></li><li><a href="SolrResult.html">SolrResult</a></li><li><a href="Stats.html">Stats</a></li><li class='category-heading' data-category='Models/Analytics'>Models/Analytics</li><li><a href="Analytics.html">Analytics</a></li><li><a href="GoogleAnalytics.html">GoogleAnalytics</a></li><li class='category-heading' data-category='Models/Bookkeeper'>Models/Bookkeeper</li><li><a href="Quota.html">Quota</a></li><li><a href="Subscription.html">Subscription</a></li><li><a href="Usage.html">Usage</a></li><li class='category-heading' data-category='Models/Connectors'>Models/Connectors</li><li><a href="FiltersMapConnector.html">FiltersMapConnector</a></li><li><a href="FiltersSearchConnector.html">FiltersSearchConnector</a></li><li><a href="GeoPointsCesiumConnector.html">GeoPointsCesiumConnector</a></li><li><a href="GeoPointsCesiumPointsConnector.html">GeoPointsCesiumPointsConnector</a></li><li><a href="GeoPointsCesiumPolygonConnector.html">GeoPointsCesiumPolygonConnector</a></li><li><a href="MapSearchConnector.html">MapSearchConnector</a></li><li><a href="MapSearchFiltersConnector.html">MapSearchFiltersConnector</a></li><li class='category-heading' data-category='Models/Filters'>Models/Filters</li><li><a href="BooleanFilter.html">BooleanFilter</a></li><li><a href="ChoiceFilter.html">ChoiceFilter</a></li><li><a href="DateFilter.html">DateFilter</a></li><li><a href="Filter.html">Filter</a></li><li><a href="FilterGroup.html">FilterGroup</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="SpatialFilter.html">SpatialFilter</a></li><li><a href="ToggleFilter.html">ToggleFilter</a></li><li class='category-heading' data-category='Models/Formats'>Models/Formats</li><li><a href="ObjectFormat.html">ObjectFormat</a></li><li class='category-heading' data-category='Models/Geocoder'>Models/Geocoder</li><li><a href="GeocodedLocation.html">GeocodedLocation</a></li><li><a href="GeocoderSearch.html">GeocoderSearch</a></li><li><a href="GoogleMapsAutocompleter.html">GoogleMapsAutocompleter</a></li><li><a href="GoogleMapsGeocoder.html">GoogleMapsGeocoder</a></li><li><a href="Prediction.html">Prediction</a></li><li class='category-heading' data-category='Models/Geohashes'>Models/Geohashes</li><li><a href="Geohash.html">Geohash</a></li><li class='category-heading' data-category='Models/Maps'>Models/Maps</li><li><a href="AssetCategory.html">AssetCategory</a></li><li><a href="AssetColor.html">AssetColor</a></li><li><a href="AssetColorPalette.html">AssetColorPalette</a></li><li><a href="ExpansionPanelsModel.html">ExpansionPanelsModel</a></li><li><a href="Feature.html">Feature</a></li><li><a href="GeoBoundingBox.html">GeoBoundingBox</a></li><li><a href="GeoPoint.html">GeoPoint</a></li><li><a href="GeoScale.html">GeoScale</a></li><li><a href="GeoUtilities.html">GeoUtilities</a></li><li><a href="MapInteraction.html">MapInteraction</a></li><li><a href="MapModel.html">MapModel</a></li><li><a href="VectorFilter.html">VectorFilter</a></li><li><a href="ViewfinderModel.html">ViewfinderModel</a></li><li><a href="ZoomPresetModel.html">ZoomPresetModel</a></li><li class='category-heading' data-category='Models/Maps/Assets'>Models/Maps/Assets</li><li><a href="Cesium3DTileset.html">Cesium3DTileset</a></li><li><a href="CesiumGeohash.html">CesiumGeohash</a></li><li><a href="CesiumImagery.html">CesiumImagery</a></li><li><a href="CesiumTerrain.html">CesiumTerrain</a></li><li><a href="CesiumVectorData.html">CesiumVectorData</a></li><li><a href="MapAsset.html">MapAsset</a></li><li class='category-heading' data-category='Models/Metadata'>Models/Metadata</li><li><a href="ScienceMetadata.html">ScienceMetadata</a></li><li class='category-heading' data-category='Models/Metadata/EML'>Models/Metadata/EML</li><li><a href="EMLMethodStep.html">EMLMethodStep</a></li><li><a href="EMLSpecializedText.html">EMLSpecializedText</a></li><li><a href="EMLTaxonCoverage.html">EMLTaxonCoverage</a></li><li class='category-heading' data-category='Models/Metadata/EML211'>Models/Metadata/EML211</li><li><a href="EML211.html">EML211</a></li><li><a href="EMLAnnotation.html">EMLAnnotation</a></li><li><a href="EMLAttribute.html">EMLAttribute</a></li><li><a href="EMLDataTable.html">EMLDataTable</a></li><li><a href="EMLDistribution.html">EMLDistribution</a></li><li><a href="EMLEntity.html">EMLEntity</a></li><li><a href="EMLGeoCoverage.html">EMLGeoCoverage</a></li><li><a href="EMLMeasurementScale.html">EMLMeasurementScale</a></li><li><a href="EMLMethods.html">EMLMethods</a></li><li><a href="EMLMissingValueCode.html">EMLMissingValueCode</a></li><li><a href="EMLNonNumericDomain.html">EMLNonNumericDomain</a></li><li><a href="EMLNumericDomain.html">EMLNumericDomain</a></li><li><a href="EMLOtherEntity.html">EMLOtherEntity</a></li><li><a href="EMLParty.html">EMLParty</a></li><li><a href="EMLTemporalCoverage.html">EMLTemporalCoverage</a></li><li><a href="EMLText211.html">EMLText211</a></li><li><a href="EMLUnit.html">EMLUnit</a></li><li class='category-heading' data-category='Models/Metadata/EML220'>Models/Metadata/EML220</li><li><a href="EMLText.html">EMLText</a></li><li class='category-heading' data-category='Models/Portals'>Models/Portals</li><li><a href="PortalImage.html">PortalImage</a></li><li><a href="PortalModel.html">PortalModel</a></li><li><a href="PortalSectionModel.html">PortalSectionModel</a></li><li class='category-heading' data-category='Models/Projects'>Models/Projects</li><li><a href="Project.html">Project</a></li><li class='category-heading' data-category='Models/QueryFields'>Models/QueryFields</li><li><a href="QueryField.html">QueryField</a></li><li class='category-heading' data-category='Router'>Router</li><li><a href="UIRouter.html">UIRouter</a></li><li class='category-heading' data-category='Views'>Views</li><li><a href="AccessPolicyView.html">AccessPolicyView</a></li><li><a href="AccessRuleView.html">AccessRuleView</a></li><li><a href="AnnotationView.html">AnnotationView</a></li><li><a href="AppView.html">AppView</a></li><li><a href="CatalogSearchView.html">CatalogSearchView</a></li><li><a href="CitationHeaderView.html">CitationHeaderView</a></li><li><a href="CitationListView.html">CitationListView</a></li><li><a href="CitationModalView.html">CitationModalView</a></li><li><a href="CitationView.html">CitationView</a></li><li><a href="ColorPaletteView.html">ColorPaletteView</a></li><li><a href="DataCatalogViewWithFilters.html">DataCatalogViewWithFilters</a></li><li><a href="DataItemView.html">DataItemView</a></li><li><a href="DataPackageView.html">DataPackageView</a></li><li><a href="DraftsView.html">DraftsView</a></li><li><a href="EditCollectionView.html">EditCollectionView</a></li><li><a href="EditorView.html">EditorView</a></li><li><a href="FooterView.html">FooterView</a></li><li><a href="GroupListView.html">GroupListView</a></li><li><a href="ImageUploaderView.html">ImageUploaderView</a></li><li><a href="MarkdownEditorView.html">MarkdownEditorView</a></li><li><a href="MarkdownView.html">MarkdownView</a></li><li><a href="MdqRunView.html">MdqRunView</a></li><li><a href="MetadataView.html">MetadataView</a></li><li><a href="MetricModalView.html">MetricModalView</a></li><li><a href="MetricView.html">MetricView</a></li><li><a href="MetricsChartView.html">MetricsChartView</a></li><li><a href="NavbarView.html">NavbarView</a></li><li><a href="RegisterCitationView.html">RegisterCitationView</a></li><li><a href="SearchResultView.html">SearchResultView</a></li><li><a href="SignInView.html">SignInView</a></li><li><a href="TOCView.html">TOCView</a></li><li><a href="TableEditorView.html">TableEditorView</a></li><li><a href="UserGroupView.html">UserGroupView</a></li><li><a href="UserView.html">UserView</a></li><li class='category-heading' data-category='Views/Filters'>Views/Filters</li><li><a href="BooleanFilterView.html">BooleanFilterView</a></li><li><a href="ChoiceFilterView.html">ChoiceFilterView</a></li><li><a href="DateFilterView.html">DateFilterView</a></li><li><a href="FilterEditorView.html">FilterEditorView</a></li><li><a href="FilterGroupView.html">FilterGroupView</a></li><li><a href="FilterGroupsView.html">FilterGroupsView</a></li><li><a href="FilterView.html">FilterView</a></li><li><a href="NumericFilterView.html">NumericFilterView</a></li><li><a href="SemanticFilterView.html">SemanticFilterView</a></li><li><a href="ToggleFilterView.html">ToggleFilterView</a></li><li class='category-heading' data-category='Views/Maps'>Views/Maps</li><li><a href="CesiumWidgetView.html">CesiumWidgetView</a></li><li><a href="DrawTool.html">DrawTool</a></li><li><a href="FeatureInfoView.html">FeatureInfoView</a></li><li><a href="LayerCategoryItemView.html">LayerCategoryItemView</a></li><li><a href="LayerCategoryListView.html">LayerCategoryListView</a></li><li><a href="LayerDetailView.html">LayerDetailView</a></li><li><a href="LayerDetailsView.html">LayerDetailsView</a></li><li><a href="LayerInfoView.html">LayerInfoView</a></li><li><a href="LayerItemView.html">LayerItemView</a></li><li><a href="LayerListView.html">LayerListView</a></li><li><a href="LayerNavigationView.html">LayerNavigationView</a></li><li><a href="LayerOpacityView.html">LayerOpacityView</a></li><li><a href="LayersPanelView.html">LayersPanelView</a></li><li><a href="LegendView.html">LegendView</a></li><li><a href="MapHelpPanel.html">MapHelpPanel</a></li><li><a href="MapView.html">MapView</a></li><li><a href="PredictionView.html">PredictionView</a></li><li><a href="PredictionsListView.html">PredictionsListView</a></li><li><a href="ScaleBarView.html">ScaleBarView</a></li><li><a href="SearchInputView.html">SearchInputView</a></li><li><a href="SearchView.html">SearchView</a></li><li><a href="ToolbarView.html">ToolbarView</a></li><li><a href="ViewfinderView.html">ViewfinderView</a></li><li class='category-heading' data-category='Views/Maps/Viewfinder'>Views/Maps/Viewfinder</li><li><a href="ExpansionPanelView.html">ExpansionPanelView</a></li><li><a href="ZoomPresetView.html">ZoomPresetView</a></li><li><a href="ZoomPresetsListView.html">ZoomPresetsListView</a></li><li class='category-heading' data-category='Views/Metadata'>Views/Metadata</li><li><a href="EML211EditorView.html">EML211EditorView</a></li><li><a href="EMLAttributeView.html">EMLAttributeView</a></li><li><a href="EMLEntityView.html">EMLEntityView</a></li><li><a href="EMLMeasurementScaleView.html">EMLMeasurementScaleView</a></li><li><a href="EMLMeasurementTypeView.html">EMLMeasurementTypeView</a></li><li><a href="EMLMethodsView.html">EMLMethodsView</a></li><li><a href="EMLMissingValueCodeView.html">EMLMissingValueCodeView</a></li><li><a href="EMLMissingValueCodesView.html">EMLMissingValueCodesView</a></li><li><a href="EMLOtherEntityView.html">EMLOtherEntityView</a></li><li><a href="EMLPartyView.html">EMLPartyView</a></li><li><a href="EMLTempCoverageView.html">EMLTempCoverageView</a></li><li><a href="EMLView.html">EMLView</a></li><li><a href="EMlGeoCoverageView_.html">EMlGeoCoverageView</a></li><li><a href="ScienceMetadataView.html">ScienceMetadataView</a></li><li class='category-heading' data-category='Views/Portals'>Views/Portals</li><li><a href="PortalDataView.html">PortalDataView</a></li><li><a href="PortalHeaderView.html">PortalHeaderView</a></li><li><a href="PortalListView.html">PortalListView</a></li><li><a href="PortalLogosView.html">PortalLogosView</a></li><li><a href="PortalMembersView.html">PortalMembersView</a></li><li><a href="PortalSectionView.html">PortalSectionView</a></li><li><a href="PortalUsagesView.html">PortalUsagesView</a></li><li><a href="PortalView.html">PortalView</a></li><li><a href="PortalVisualizationsView.html">PortalVisualizationsView</a></li><li><a href="PortalsSearchView.html">PortalsSearchView</a></li><li class='category-heading' data-category='Views/Portals/Editor'>Views/Portals/Editor</li><li><a href="PortEditorDataView.html">PortEditorDataView</a></li><li><a href="PortEditorImageView.html">PortEditorImageView</a></li><li><a href="PortEditorLogosView.html">PortEditorLogosView</a></li><li><a href="PortEditorMdSectionView.html">PortEditorMdSectionView</a></li><li><a href="PortEditorSectionView.html">PortEditorSectionView</a></li><li><a href="PortEditorSectionsView.html">PortEditorSectionsView</a></li><li><a href="PortEditorSettingsView.html">PortEditorSettingsView</a></li><li><a href="PortalEditorView.html">PortalEditorView</a></li><li class='category-heading' data-category='Views/Projects'>Views/Projects</li><li><a href="ProjectView.html">ProjectView</a></li><li class='category-heading' data-category='Views/QueryBuilder'>Views/QueryBuilder</li><li><a href="QueryBuilderView.html">QueryBuilderView</a></li><li><a href="QueryRuleView.html">QueryRuleView</a></li><li class='category-heading' data-category='Views/Search'>Views/Search</li><li><a href="SearchResultsPagerView.html">SearchResultsPagerView</a></li><li><a href="SearchResultsView.html">SearchResultsView</a></li><li><a href="SorterView.html">SorterView</a></li><li class='category-heading' data-category='Views/SearchSelect'>Views/SearchSelect</li><li><a href="AccountSelectView.html">AccountSelectView</a></li><li><a href="AnnotationFilter.html">AnnotationFilter</a></li><li><a href="NodeSelect.html">NodeSelect</a></li><li><a href="ObjectFormatSelect.html">ObjectFormatSelect</a></li><li><a href="QueryFieldSelectView.html">QueryFieldSelectView</a></li><li><a href="SearchableSelectView.html">SearchableSelectView</a></li><li class='category-heading' data-category='Deprecated'>Deprecated</li><li><a href="AnnotatorView.html">AnnotatorView</a></li><li><a href="ExternalView.html">ExternalView</a></li><li><a href="LogsSearch.html">LogsSearch</a></li></ul><h3>Global</h3><ul><li><a href="global.html#appConfigPath">appConfigPath</a></li><li><a href="global.html#couldBeLatLong">couldBeLatLong</a></li><li><a href="global.html#taxonomicClassification">taxonomicClassification</a></li></ul>
</nav>

<div id="main">

    <h1 class="page-title">Source: src/js/models/portals/PortalModel.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @exports PortalModel
 */
define([
  "jquery",
  "underscore",
  "backbone",
  "gmaps",
  "uuid",
  "collections/Filters",
  "collections/SolrResults",
  "models/filters/Filter",
  "models/portals/PortalSectionModel",
  "models/portals/PortalVizSectionModel",
  "models/portals/PortalImage",
  "models/metadata/eml211/EMLParty",
  "models/metadata/eml220/EMLText",
  "models/CollectionModel",
  "models/Search",
  "models/filters/FilterGroup",
  "models/Map",
], function (
  $,
  _,
  Backbone,
  gmaps,
  uuid,
  Filters,
  SolrResults,
  FilterModel,
  PortalSectionModel,
  PortalVizSectionModel,
  PortalImage,
  EMLParty,
  EMLText,
  CollectionModel,
  SearchModel,
  FilterGroup,
  MapModel,
) {
  /**
   * @classdesc A PortalModel is a specialized collection that represents a portal,
   * including the associated data, people, portal descriptions, results and
   * visualizations.  It also includes settings for customized filtering of the
   * associated data, and properties used to customized the map display and the
   * overall branding of the portal.
   *
   * @class PortalModel
   * @classcategory Models/Portals
   * @extends CollectionModel
   * @module models/PortalModel
   * @name PortalModel
   * @constructor
   */
  var PortalModel = CollectionModel.extend(
    /** @lends PortalModel.prototype */ {
      /**
       * The name of this type of model
       * @type {string}
       */
      type: "Portal",

      /**
       * Overrides the default Backbone.Model.defaults() function to
       * specify default attributes for the portal model
       * @type {object}
       */
      defaults: function () {
        return _.extend(CollectionModel.prototype.defaults(), {
          id: null,
          objectXML: null,
          formatId: MetacatUI.appModel.get("portalEditorSerializationFormat"),
          formatType: "METADATA",
          type: "portal",
          //Is true if the last fetch was sent with user credentials. False if not.
          fetchedWithAuth: null,
          logo: null,
          sections: [],
          associatedParties: [],
          acknowledgments: null,
          acknowledgmentsLogos: [],
          awards: [],
          checkedNodeLabels: false,
          labelDoubleChecked: false,
          literatureCited: [],
          filterGroups: [],
          createSeriesId: true, //If true, a seriesId will be created when this object is saved.
          // The portal document options may specify section to hide
          edit: false, // Set to true if this model is being used in a portal editor view
          hideMetrics: null,
          hideData: null,
          hideMembers: null,
          hideMap: null,
          // List of section labels indicating the order in which to display the sections.
          // Labels must exactly match the labels set on sections, or the values set on the
          // metricsLabel, dataLabel, and membersLabel options.
          pageOrder: null,
          //Options for the custom section labels
          //NOTE: This are not fully supported yet.
          metricsLabel: "Metrics",
          dataLabel: "Data",
          membersLabel: "Members",
          // Map options, as specified in the portal document options
          mapZoomLevel: 3,
          mapCenterLatitude: null,
          mapCenterLongitude: null,
          mapShapeHue: 200,
          // The MapModel
          mapModel: gmaps ? new MapModel() : null,
          optionNames: [
            "primaryColor",
            "secondaryColor",
            "accentColor",
            "mapZoomLevel",
            "mapCenterLatitude",
            "mapCenterLongitude",
            "mapShapeHue",
            "hideData",
            "hideMetrics",
            "hideMembers",
            "pageOrder",
            "layout",
            "theme",
          ],
          // Portal view colors, as specified in the portal document options
          primaryColor:
            MetacatUI.appModel.get("portalDefaults").primaryColor || "#006699",
          secondaryColor:
            MetacatUI.appModel.get("portalDefaults").secondaryColor ||
            "#009299",
          accentColor:
            MetacatUI.appModel.get("portalDefaults").accentColor || "#f89406",
          primaryColorRGB: null,
          secondaryColorRGB: null,
          accentColorRGB: null,
          primaryColorTransparent:
            MetacatUI.appModel.get("portalDefaults").primaryColorTransparent ||
            "rgba(0, 102, 153, .7)",
          secondaryColorTransparent:
            MetacatUI.appModel.get("portalDefaults")
              .secondaryColorTransparent || "rgba(0, 146, 153, .7)",
          accentColorTransparent:
            MetacatUI.appModel.get("portalDefaults").accentColorTransparent ||
            "rgba(248, 148, 6, .7)",
          theme: null,
          layout: null,
        });
      },

      /**
       * The default text to use for a new section label added by the user
       * @type {string}
       */
      newSectionLabel: "Untitled",

      /**
       * Overrides the default Backbone.Model.initialize() function to
       * provide some custom initialize options
       *
       * @param {} options -
       */
      initialize: function (attrs) {
        //Call the super class initialize function
        CollectionModel.prototype.initialize.call(this, attrs);

        // Generate transparent colours from the primary, secondary, and accent colors
        // TODO

        if (attrs.isNew) {
          this.set("synced", true);
          //Create an isPartOf filter for this new Portal
          this.addIsPartOfFilter();

          var model = this;

          // Insert new sections if any are set in the appModel

          var portalDefaults = MetacatUI.appModel.get("portalDefaults"),
            defaultSections = portalDefaults ? portalDefaults.sections : [];

          if (
            defaultSections &amp;&amp;
            defaultSections.length &amp;&amp;
            Array.isArray(defaultSections)
          ) {
            defaultSections.forEach(function (section, index) {
              // If there is at least one section default set...
              if (section.title || section.label) {
                var newDefaultSection = new PortalSectionModel({
                  title: section.title || "",
                  label: section.label || this.newSectionLabel,
                  // Set a default image on new markdown sections
                  image: model.getRandomSectionImage(),
                  portalModel: model,
                });
                model.addSection(newDefaultSection);
              }
            });
          }
        }

        // check for info received from Bookkeeper
        if (MetacatUI.appModel.get("enableBookkeeperServices")) {
          this.listenTo(
            MetacatUI.appUserModel,
            "change:dataoneSubscription",
            function () {
              if (
                MetacatUI.appUserModel.get("dataoneSubscription").isTrialing()
              ) {
                this.setRandomLabel();
              }
            },
          );

          //Fetch the user subscription info
          MetacatUI.appUserModel.fetchSubscription();
        }

        // Cache this model for later use
        this.cachePortal();
      },

      /**
       * getRandomSectionImage - Using the list of image identifiers set
       * in the app config, select an image to use for a portal section.
       * The function will not return the same image until all the images
       * have been returned at least once. If an image would return a 404
       * error, it is skipped. If all images give 404s, an empty string
       * is returned.
       *
       * @return {PortalImage}  A portal image model to use in a section model
       */
      getRandomSectionImage: function () {
        // This variable will hold the section image to return, if any
        var newSectionImage = "",
          // The default portal values set in the config
          portalDefaults = MetacatUI.appModel.get("portalDefaults"),
          // Check if default images are set on the model already
          defaultImageIds = this.get("defaultSectionImageIds"),
          // Keep track of where we are in the list of default images,
          // so there's not too much repetition
          runningNumber = this.get("defaultImageRunningNumber") || 0;

        // If none are set, get the configured default image IDs,
        // shuffle them, and set them on the model.
        if (!defaultImageIds || !defaultImageIds.length) {
          // Get the list of default section image IDs from the appModel
          defaultImageIds = portalDefaults
            ? portalDefaults.sectionImageIdentifiers
            : false;

          // If some are configured...
          if (defaultImageIds &amp;&amp; defaultImageIds.length) {
            // ...Shuffle the images...
            for (let i = defaultImageIds.length - 1; i > 0; i--) {
              let j = Math.floor(Math.random() * (i + 1));
              [defaultImageIds[i], defaultImageIds[j]] = [
                defaultImageIds[j],
                defaultImageIds[i],
              ];
            }
            // ... and save the shuffled list to the portal model
            this.set("defaultSectionImageIds", defaultImageIds);
          }
        }

        // Can't get a random image if none are configured
        if (!defaultImageIds) {
          console.log(
            "Can't set a default image on new markdown sections because there are no default image IDs set. Check portalDefaults.sectionImageIdentifiers in the config file.",
          );
          return;
        }

        // Select one of the image IDs
        if (defaultImageIds &amp;&amp; defaultImageIds.length > 0) {
          if (runningNumber >= defaultImageIds.length) {
            runningNumber = 0;
          }

          // Go through the shuffled array of image IDs in order
          for (i = runningNumber; i &lt; defaultImageIds.length; i++) {
            // Skip images that have already returned 404 errors
            if (defaultImageIds[i] == "NOT FOUND") {
              continue;
            }

            // Section images are PortalImage models
            var newSectionImage = new PortalImage({
              identifier: defaultImageIds[i],
              portalModel: this.get("portalModel"),
            });

            // Skip adding an image if it doesn't exist given the identifer and baseUrl found in the image model
            if (newSectionImage.imageExists()) {
              break;
              // If the image doesn't exist, mark it so we don't have to
              // check again next time
            } else {
              defaultImageIds[i] = "NOT FOUND";
              newSectionImage = "";
            }
          }
        }

        this.set("defaultImageRunningNumber", i + 1);
        this.set("defaultSectionImageIds", defaultImageIds);

        return newSectionImage;
      },

      /**
       * Returns the portal URL
       *
       * @return {string} The portal URL
       */
      url: function () {
        //Start the base URL string
        // use the resolve service if there is no object service url
        // (e.g. in DataONE theme)
        var urlBase =
          MetacatUI.appModel.get("objectServiceUrl") ||
          MetacatUI.appModel.get("resolveServiceUrl");

        //Get the active alternative repository, if one is configured
        var activeAltRepo = MetacatUI.appModel.getActiveAltRepo();

        if (activeAltRepo) {
          urlBase = activeAltRepo.objectServiceUrl;
        }

        //If this object is being updated, use the old pid in the URL
        if (!this.isNew() &amp;&amp; this.get("oldPid")) {
          return urlBase + encodeURIComponent(this.get("oldPid"));
        }
        //If this object is new, use the new pid in the URL
        else {
          return (
            urlBase + encodeURIComponent(this.get("seriesId") || this.get("id"))
          );
        }
      },

      /**
       * Overrides the default Backbone.Model.fetch() function to provide some custom
       * fetch options
       * @param [options] {object} - Options for this fetch
       * @property [options.objectOnly] {Boolean} - If true, only the object will be retrieved and not the system metadata
       * @property [options.systemMetadataOnly] {Boolean} - If true, only the system metadata will be retrieved
       * @return {XMLDocument} The XMLDocument returned from the fetch() AJAX call
       */
      fetch: function (options) {
        if (!options) var options = {};
        else var options = _.clone(options);

        //If the seriesId has not been found yet, get it from Solr
        if (!this.get("id") &amp;&amp; !this.get("seriesId") &amp;&amp; this.get("label")) {
          this.once("change:seriesId", function () {
            this.fetch(options);
          });
          this.once("latestVersionFound", function () {
            this.fetch(options);
          });

          //Get the series ID of this object
          this.getSeriesIdByLabel();

          return;
        }
        //If we found the latest version in this pid version chain,
        else if (this.get("id") &amp;&amp; this.get("latestVersion")) {
          //Set it as the id of this model
          this.set("id", this.get("latestVersion"));

          //Stop listening to the change of seriesId and the latest version found
          this.stopListening("change:seriesId", this.fetch);
          this.stopListening("latestVersionFound", this.fetch);
        }

        //If this MetacatUI instance is pointing to a CN, use the origin MN
        // to fetch the Portal, if available as an alt repo.
        if (MetacatUI.appModel.get("isCN") &amp;&amp; this.get("datasource")) {
          //Check if the origin MN (datasource) is an alt repo option
          var altRepo = _.findWhere(
            MetacatUI.appModel.get("alternateRepositories"),
            { identifier: this.get("datasource") },
          );

          if (altRepo) {
            //Set the origin MN (datasource) as the active alt repo
            MetacatUI.appModel.set(
              "activeAlternateRepositoryId",
              this.get("datasource"),
            );
          }
        }

        //Fetch the system metadata
        if (!options.objectOnly || options.systemMetadataOnly) {
          this.fetchSystemMetadata();

          if (options.systemMetadataOnly) {
            return;
          }
        }

        var requestSettings = {
          dataType: "xml",
          error: function (model, response) {
            model.trigger("error", model, response);

            if (response &amp;&amp; response.status == 404) {
              model.trigger("notFound");
            }
          },
        };

        //Save a boolean flag for whether or not this fetch was done with user authentication.
        //This is helpful when the app is dealing with potentially private data
        this.set("fetchedWithAuth", MetacatUI.appUserModel.get("loggedIn"));

        // Add the user settings to the fetch settings
        requestSettings = _.extend(
          requestSettings,
          MetacatUI.appUserModel.createAjaxSettings(),
        );

        // Call Backbone.Model.fetch()
        return Backbone.Model.prototype.fetch.call(this, requestSettings);
      },

      /**
       * Get the portal seriesId by searching for the portal by its label in Solr
       */
      getSeriesIdByLabel: function () {
        //Exit if there is no portal name set
        if (!this.get("label")) return;

        var model = this;

        //Start the base URL for the query service
        var baseUrl = "";

        try {
          //If this app instance is pointing to the CN, find the Portal series ID on the MN
          if (MetacatUI.appModel.get("alternateRepositories").length) {
            //Get the array of possible authoritative MNs
            var possibleAuthMNs = this.get("possibleAuthMNs");

            //If there are no possible authoritative MNs, use the CN query service
            if (!possibleAuthMNs.length) {
              baseUrl = MetacatUI.appModel.get("queryServiceUrl");
            } else {
              baseUrl = possibleAuthMNs[0].queryServiceUrl;
            }
          } else {
            //Get the query service URL
            baseUrl = MetacatUI.appModel.get("queryServiceUrl");
          }
        } catch (e) {
          console.error(
            "Error in trying to determine the query service URL. Going to try to use the AppModel setting. ",
            e,
          );
        } finally {
          //Default to the query service URL configured in the AppModel, if one wasn't set earlier
          if (!baseUrl) {
            baseUrl = MetacatUI.appModel.get("queryServiceUrl");
            //If there isn't a query service URL, trigger a "not found" error and exit
            if (!baseUrl) {
              this.trigger("notFound");
              return;
            }
          }
        }

        var requestSettings = {
          url:
            baseUrl +
            'q=label:"' +
            this.get("label") +
            '" OR ' +
            'seriesId:"' +
            this.get("label") +
            '"' +
            "&amp;fl=seriesId,id,label,datasource" +
            "&amp;sort=dateUploaded%20asc" +
            "&amp;rows=1" +
            "&amp;wt=json",
          dataType: "json",
          error: function (response) {
            model.trigger("error", model, response);

            if (response.status == 404) {
              model.trigger("notFound");
            }
          },
          success: function (response) {
            if (response.response.numFound > 0) {
              //Set the label and datasource
              model.set("label", response.response.docs[0].label);
              model.set("datasource", response.response.docs[0].datasource);

              //Save the seriesId, if one is found
              if (response.response.docs[0].seriesId) {
                model.set("seriesId", response.response.docs[0].seriesId);
              }
              //If this portal doesn't have a seriesId,
              //but id has been found
              else if (response.response.docs[0].id) {
                //Save the id
                model.set("id", response.response.docs[0].id);

                //Find the latest version in this version chain
                model.findLatestVersion(response.response.docs[0].id);
              }
              // if we don't have Id or SeriesId
              else {
                model.trigger("notFound");
              }
            } else {
              var possibleAuthMNs = model.get("possibleAuthMNs");
              if (possibleAuthMNs.length) {
                //Remove the first MN from the array, since it didn't contain the Portal, so it's not the auth MN
                possibleAuthMNs.shift();
              }

              //If there are no other possible auth MNs to check, trigger this Portal as Not Found.
              if (possibleAuthMNs.length == 0 || !possibleAuthMNs) {
                model.trigger("notFound");
              }
              //If there's more MNs to check, try again
              else {
                model.getSeriesIdByLabel();
              }
            }
          },
        };

        //Save a boolean flag for whether or not this fetch was done with user authentication.
        //This is helpful when the app is dealing with potentially private data
        this.set("fetchedWithAuth", MetacatUI.appUserModel.get("loggedIn"));

        requestSettings = _.extend(
          requestSettings,
          MetacatUI.appUserModel.createAjaxSettings(),
        );

        $.ajax(requestSettings);
      },

      /**
       * This function has been renamed `getSeriesIdByLabel` and may be removed in future releases.
       * @deprecated This function has been renamed `getSeriesIdByLabel` and may be removed in future releases.
       * @see PortalModel#getSeriesIdByLabel
       */
      getSeriesIdByName: function () {
        this.getSeriesIdByLabel();
      },

      /**
       * Overrides the default Backbone.Model.parse() function to parse the custom
       * portal XML document
       *
       * @param {XMLDocument} response - The XMLDocument returned from the fetch() AJAX call
       * @return {JSON} The result of the parsed XML, in JSON. To be set directly on the model.
       */
      parse: function (response) {
        //Start the empty JSON object
        var modelJSON = {},
          modelRef = this,
          portalNode;

        // Iterate over each root XML node to find the portal node
        $(response)
          .children()
          .each(function (i, el) {
            if (el.tagName.indexOf("portal") > -1) {
              portalNode = el;
              return false;
            }
          });

        // If a portal XML node wasn't found, return an empty JSON object
        if (typeof portalNode == "undefined" || !portalNode) {
          return {};
        }

        // Parse the collection elements
        modelJSON = this.parseCollectionXML(portalNode);

        // Save the xml for serialize
        modelJSON.objectXML = response;

        // Parse the portal logo
        var portLogo = $(portalNode).children("logo")[0];
        if (portLogo) {
          var portImageModel = new PortalImage({
            objectDOM: portLogo,
            portalModel: this,
          });
          portImageModel.set(portImageModel.parse());
          modelJSON.logo = portImageModel;
        }

        // Parse acknowledgement logos into urls
        var logos = $(portalNode).children("acknowledgmentsLogo");
        modelJSON.acknowledgmentsLogos = [];
        _.each(
          logos,
          function (logo, i) {
            if (!logo) return;

            var imageModel = new PortalImage({
              objectDOM: logo,
              portalModel: this,
            });
            imageModel.set(imageModel.parse());

            if (imageModel.get("imageURL")) {
              modelJSON.acknowledgmentsLogos.push(imageModel);
            }
          },
          this,
        );

        // Parse the literature cited
        // This will only work for bibtex at the moment
        var bibtex = $(portalNode)
          .children("literatureCited")
          .children("bibtex");
        if (bibtex.length > 0) {
          modelJSON.literatureCited = this.parseTextNode(
            portalNode,
            "literatureCited",
          );
        }

        // Parse the portal content sections
        modelJSON.sections = [];
        $(portalNode)
          .children("section")
          .each(function (i, section) {
            //Get the section type, if there is one
            var sectionTypeNode = $(section).find(
                "optionName:contains(sectionType)",
              ),
              sectionType = "";

            if (sectionTypeNode.length) {
              var optionValueNode = sectionTypeNode
                .first()
                .siblings("optionValue");
              if (optionValueNode.length) {
                sectionType = optionValueNode[0].textContent;
              }
            }

            if (sectionType == "visualization") {
              // Create a new PortalVizSectionModel
              modelJSON.sections.push(
                new PortalVizSectionModel({
                  objectDOM: section,
                  literatureCited: modelJSON.literatureCited,
                }),
              );
            } else {
              // Create a new PortalSectionModel
              modelJSON.sections.push(
                new PortalSectionModel({
                  objectDOM: section,
                  literatureCited: modelJSON.literatureCited,
                  portalModel: modelRef,
                }),
              );
            }

            //Parse the PortalSectionModel
            modelJSON.sections[i].set(modelJSON.sections[i].parse(section));
          });

        // Parse the EMLText elements
        modelJSON.acknowledgments = this.parseEMLTextNode(
          portalNode,
          "acknowledgments",
        );

        // Parse the awards
        modelJSON.awards = [];
        var parse_it = this.parseTextNode;
        $(portalNode)
          .children("award")
          .each(function (i, award) {
            var award_parsed = {};
            $(award)
              .children()
              .each(function (i, award_attr) {
                if (award_attr.nodeName != "funderLogo") {
                  // parse the text nodes
                  award_parsed[award_attr.nodeName] = parse_it(
                    award,
                    award_attr.nodeName,
                  );
                } else {
                  // parse funderLogo which is type ImageType
                  var imageModel = new PortalImage({ objectDOM: award_attr });
                  imageModel.set(imageModel.parse());
                  award_parsed[award_attr.nodeName] = imageModel;
                }
              });
            modelJSON.awards.push(award_parsed);
          });

        // Parse the associatedParties
        modelJSON.associatedParties = [];
        $(portalNode)
          .children("associatedParty")
          .each(function (i, associatedParty) {
            modelJSON.associatedParties.push(
              new EMLParty({
                objectDOM: associatedParty,
              }),
            );
          });

        // Parse the options. Use children() and not find() because we only want
        // option nodes that are direct children of the portal node. Option nodes
        // can also be found within section nodes.
        $(portalNode)
          .children("option")
          .each(function (i, option) {
            var optionName = $(option).find("optionName")[0].textContent,
              optionValue = $(option).find("optionValue")[0].textContent;

            if (optionValue === "true") {
              optionValue = true;
            } else if (optionValue === "false") {
              optionValue = false;
            }

            // TODO: keep a list of optionNames so that in the case of
            // custom options, we can serialize them in serialize()
            // otherwise it's not saved in the model which attributes
            // are &lt;option>&lt;/option>s

            // Convert the comma separated list of pages into an array
            if (
              optionName === "pageOrder" &amp;&amp;
              optionValue &amp;&amp;
              optionValue.length
            ) {
              optionValue = optionValue.split(",");
            }

            if (!_.has(modelJSON, optionName)) {
              modelJSON[optionName] = optionValue;
            }
          });

        // Convert all the hex colors to rgb
        if (modelJSON.primaryColor) {
          modelJSON.primaryColorRGB = this.hexToRGB(modelJSON.primaryColor);
          modelJSON.primaryColorTransparent =
            "rgba(" +
            modelJSON.primaryColorRGB.r +
            "," +
            modelJSON.primaryColorRGB.g +
            "," +
            modelJSON.primaryColorRGB.b +
            ", .7)";
        }
        if (modelJSON.secondaryColor) {
          modelJSON.secondaryColorRGB = this.hexToRGB(modelJSON.secondaryColor);
          modelJSON.secondaryColorTransparent =
            "rgba(" +
            modelJSON.secondaryColorRGB.r +
            "," +
            modelJSON.secondaryColorRGB.g +
            "," +
            modelJSON.secondaryColorRGB.b +
            ", .5)";
        }
        if (modelJSON.accentColor) {
          modelJSON.accentColorRGB = this.hexToRGB(modelJSON.accentColor);
          modelJSON.accentColorTransparent =
            "rgba(" +
            modelJSON.accentColorRGB.r +
            "," +
            modelJSON.accentColorRGB.g +
            "," +
            modelJSON.accentColorRGB.b +
            ", .5)";
        }

        if (gmaps) {
          // Create a MapModel with all the map options
          modelJSON.mapModel = new MapModel();
          var mapOptions = modelJSON.mapModel.get("mapOptions");

          if (modelJSON.mapZoomLevel) {
            mapOptions.zoom = parseInt(modelJSON.mapZoomLevel);
            mapOptions.minZoom = parseInt(modelJSON.mapZoomLevel);
          }
          if (
            (modelJSON.mapCenterLatitude ||
              modelJSON.mapCenterLatitude === 0) &amp;&amp;
            (modelJSON.mapCenterLongitude || modelJSON.mapCenterLongitude === 0)
          ) {
            mapOptions.center = modelJSON.mapModel.createLatLng(
              modelJSON.mapCenterLatitude,
              modelJSON.mapCenterLongitude,
            );
          }
          if (modelJSON.mapShapeHue) {
            modelJSON.mapModel.set("tileHue", modelJSON.mapShapeHue);
          }
        }

        // Parse the UIFilterGroups
        modelJSON.filterGroups = [];
        var allFilters = modelJSON.searchModel.get("filters");
        $(portalNode)
          .children("filterGroup")
          .each(function (i, filterGroup) {
            // Create a FilterGroup model
            var filterGroupModel = new FilterGroup({
              objectDOM: filterGroup,
              isUIFilterType: true,
            });
            modelJSON.filterGroups.push(filterGroupModel);

            // Add the Filters from this FilterGroup to the portal's Search model,
            // unless this portal model is being edited. Then we only want the
            // definition filters to be included in the search model.
            if (!modelRef.get("edit")) {
              allFilters.add(filterGroupModel.get("filters").models);
            }
          });

        return modelJSON;
      },

      /**
       * Parses the XML nodes that are of type EMLText
       *
       * @param {Element} parentNode - The XML Element that contains all the EMLText nodes
       * @param {string} nodeName - The name of the XML node to parse
       * @param {boolean} isMultiple - If true, parses the nodes into an array
       * @return {(string|Array)} A string or array of strings comprising the text content
       */
      parseEMLTextNode: function (parentNode, nodeName, isMultiple) {
        var node = $(parentNode).children(nodeName);

        // If no matching nodes were found, return falsey values
        if (!node || !node.length) {
          // Return an empty array if the isMultiple flag is true
          if (isMultiple) return [];
          // Return null if the isMultiple flag is false
          else return null;
        }
        // If exactly one node is found and we are only expecting one, return the text content
        else if (node.length == 1 &amp;&amp; !isMultiple) {
          return new EMLText({
            objectDOM: node[0],
          });
        } else {
          // If more than one node is found, parse into an array
          return _.map(node, function (node) {
            return new EMLText({
              objectDOM: node,
            });
          });
        }
      },

      /**
       * Sets the fileName attribute on this model using the portal label
       * @override
       */
      setMissingFileName: function () {
        var fileName = this.get("label");

        if (!fileName) {
          fileName = "portal.xml";
        } else {
          fileName = fileName.replace(/[^a-zA-Z0-9]/g, "_") + ".xml";
        }

        this.set("fileName", fileName);
      },

      /**
       * @typedef {Object} PortalModel#rgb - An RGB color value
       * @property {number} r - A value between 0 and 255 defining the intensity of red
       * @property {number} g - A value between 0 and 255 defining the intensity of green
       * @property {number} b - A value between 0 and 255 defining the intensity of blue
       */

      /**
       * Converts hex color values to RGB
       *
       * @param {string} hex - a color in hexadecimal format
       * @return {rgb} a color in RGB format
       */
      hexToRGB: function (hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result
          ? {
              r: parseInt(result[1], 16),
              g: parseInt(result[2], 16),
              b: parseInt(result[3], 16),
            }
          : null;
      },

      /**
       * Finds the node in the given portal XML document afterwhich the
       * given node type should be inserted
       *
       * @param {Element} portalNode - The portal element of an XML document
       * @param {string} nodeName - The name of the node to be inserted
       *                             into xml
       * @return {(jQuery|boolean)} A jQuery object indicating a position,
       *                            or false when nodeName is not in the
       *                            portal schema
       */
      getXMLPosition: function (portalNode, nodeName) {
        var nodeOrder = [
          "label",
          "name",
          "description",
          "definition",
          "logo",
          "section",
          "associatedParty",
          "acknowledgments",
          "acknowledgmentsLogo",
          "award",
          "literatureCited",
          "filterGroup",
          "option",
        ];

        var position = _.indexOf(nodeOrder, nodeName);

        // First check that nodeName is in the list of nodes
        if (position == -1) {
          return false;
        }

        // If there's already an occurence of nodeName...
        if ($(portalNode).children(nodeName).length > 0) {
          // ...insert it after the last occurence
          return $(portalNode).children(nodeName).last();
        } else {
          // Go through each node in the node list and find the position
          // after which this node will be inserted
          for (var i = position - 1; i >= 0; i--) {
            if ($(portalNode).children(nodeOrder[i]).length) {
              return $(portalNode).children(nodeOrder[i]).last();
            }
          }
        }

        return false;
      },

      /**
       * Retrieves the model attributes and serializes into portal XML,
       * to produce the new or modified portal document.
       *
       * @return {string} - Returns the portal XML as a string.
       */
      serialize: function () {
        try {
          // So we can call getXMLPosition() from within if{}
          var model = this;

          var xmlDoc, portalNode, xmlString;

          xmlDoc = this.get("objectXML");

          // Check if there is a portal doc already
          if (xmlDoc == null) {
            // If not create one
            xmlDoc = this.createXML();
          } else {
            // If yes, clone it
            xmlDoc = xmlDoc.cloneNode(true);
          }

          // Iterate over each root XML node to find the portal node
          $(xmlDoc)
            .children()
            .each(function (i, el) {
              if (el.tagName.indexOf("portal") > -1) {
                portalNode = el;
              }
            });

          // Serialize the collection elements
          // ("name", "label", "description", "definition")
          portalNode = this.updateCollectionDOM(portalNode);
          xmlDoc = portalNode.getRootNode();
          var $portalNode = $(portalNode);

          // Set formatID
          this.set(
            "formatId",
            MetacatUI.appModel.get("portalEditorSerializationFormat") ||
              "https://purl.dataone.org/portals-1.1.0",
          );

          /* ==== Serialize portal logo ==== */

          // Remove node if it exists already
          $(xmlDoc).find("logo").remove();

          // Get new values
          var logo = this.get("logo");

          // Don't serialize falsey values or empty logos
          if (logo &amp;&amp; logo.get("identifier")) {
            // Make new node
            var logoSerialized = logo.updateDOM("logo");

            //Add the logo node to the XMLDocument
            xmlDoc.adoptNode(logoSerialized);

            // Insert new node at correct position
            var insertAfter = this.getXMLPosition(portalNode, "logo");
            if (insertAfter) {
              insertAfter.after(logoSerialized);
            } else {
              portalNode.appendChild(logoSerialized);
            }
          }

          /* ==== Serialize acknowledgment logos ==== */

          // Remove element if it exists already
          $(xmlDoc).find("acknowledgmentsLogo").remove();

          var acknowledgmentsLogos = this.get("acknowledgmentsLogos");

          // Don't serialize falsey values
          if (acknowledgmentsLogos) {
            _.each(acknowledgmentsLogos, function (imageModel) {
              // Don't serialize empty imageModels
              if (
                imageModel.get("identifier") ||
                imageModel.get("label") ||
                imageModel.get("associatedURL")
              ) {
                var ackLogosSerialized = imageModel.updateDOM();

                //Add the logo node to the XMLDocument
                xmlDoc.adoptNode(ackLogosSerialized);

                // Insert new node at correct position
                var insertAfter = model.getXMLPosition(
                  portalNode,
                  "acknowledgmentsLogo",
                );
                if (insertAfter) {
                  insertAfter.after(ackLogosSerialized);
                } else {
                  portalNode.appendChild(ackLogosSerialized);
                }
              }
            });
          }

          /* ==== Serialize literature cited ==== */
          // Assumes the value of literatureCited is a block of bibtex text

          // Remove node if it exists already
          $(xmlDoc).find("literatureCited").remove();

          // Get new values
          var litCit = this.get("literatureCited");

          // Don't serialize falsey values
          if (litCit.length) {
            // If there's only one element in litCited, it will be a string
            // turn it into an array so that we can use _.each
            if (typeof litCit == "string") {
              litCit = [litCit];
            }

            // Make new &lt;literatureCited> element
            var litCitSerialized = xmlDoc.createElement("literatureCited");

            _.each(litCit, function (bibtex) {
              // Wrap in literature cited in cdata tags
              var cdataLitCit = xmlDoc.createCDATASection(bibtex);
              var bibtexSerialized = xmlDoc.createElement("bibtex");
              // wrap in CDATA tags so that bibtex characters aren't escaped
              bibtexSerialized.appendChild(cdataLitCit);
              // &lt;bibxtex> is a subelement of &lt;literatureCited>
              litCitSerialized.appendChild(bibtexSerialized);
            });

            // Insert new element at correct position
            var insertAfter = this.getXMLPosition(
              portalNode,
              "literatureCited",
            );
            if (insertAfter) {
              insertAfter.after(litCitSerialized);
            } else {
              portalNode.appendChild(litCitSerialized);
            }
          }

          /* ==== Serialize portal content sections ==== */

          // Remove node if it exists already
          $portalNode.children("section").remove();

          var sections = this.get("sections");

          // Don't serialize falsey values
          if (sections) {
            _.each(
              sections,
              function (sectionModel) {
                // Don't serialize sections with default values
                if (!this.sectionIsDefault(sectionModel)) {
                  var sectionSerialized = sectionModel.updateDOM();

                  //If there was an error serializing this section, or if
                  // nothing was returned, don't do anythiing further
                  if (!sectionSerialized) {
                    return;
                  }

                  //Add the section node to the XMLDocument
                  xmlDoc.adoptNode(sectionSerialized);

                  // Remove sections entirely if the content is blank
                  var newMD = $(sectionSerialized).find("markdown")[0];
                  if (!newMD || newMD.textContent == "") {
                    $(sectionSerialized).find("markdown").remove();
                  }

                  // Remove the &lt;content> element if it's empty.
                  // This will trigger a validation error, prompting user to
                  // enter content.
                  if ($(sectionSerialized).find("content").is(":empty")) {
                    $(sectionSerialized).find("content").remove();
                  }

                  // Insert new node at correct position
                  var insertAfter = model.getXMLPosition(portalNode, "section");
                  if (insertAfter) {
                    insertAfter.after(sectionSerialized);
                  } else {
                    portalNode.appendChild(sectionSerialized);
                  }
                }
              },
              this,
            );
          }

          /* ====  Serialize the EMLText elements ("acknowledgments") ==== */

          var textFields = ["acknowledgments"];

          _.each(
            textFields,
            function (field) {
              var fieldName = field;

              // Get the EMLText model
              var emlTextModels = Array.isArray(this.get(field))
                ? this.get(field)
                : [this.get(field)];
              if (!emlTextModels.length) return;

              // Get the node from the XML doc
              var nodes = $portalNode.children(fieldName);

              // Update the DOMs for each model
              _.each(
                emlTextModels,
                function (thisTextModel, i) {
                  //Don't serialize falsey values
                  if (!thisTextModel) return;

                  var node;

                  //Get the existing node or create a new one
                  if (nodes.length &lt; i + 1) {
                    node = xmlDoc.createElement(fieldName);
                    this.getXMLPosition(portalNode, fieldName).after(node);
                  } else {
                    node = nodes[i];
                  }

                  var textModelSerialized = thisTextModel.updateDOM();

                  //If the text model wasn't serialized correctly or resulted in nothing
                  if (
                    typeof textModelSerialized == "undefined" ||
                    !textModelSerialized
                  ) {
                    //Remove the existing node
                    $(node).remove();
                  } else {
                    xmlDoc.adoptNode(textModelSerialized);
                    $(node).replaceWith(textModelSerialized);
                  }
                },
                this,
              );

              // Remove the extra nodes
              this.removeExtraNodes(nodes, emlTextModels);
            },
            this,
          );

          /* ====  Serialize awards ==== */

          // Remove award node if it exists already
          $portalNode.children("award").remove();

          // Get new values
          var awards = this.get("awards");

          // Don't serialize falsey values
          if (awards &amp;&amp; awards.length > 0) {
            _.each(awards, function (award) {
              // Make new node
              var awardSerialized = xmlDoc.createElement("award");

              // create the &lt;award> subnodes
              _.map(award, function (value, nodeName) {
                // serialize the simple text nodes
                if (nodeName != "funderLogo") {
                  // Don't serialize falsey values
                  if (value) {
                    // Make new sub-nodes
                    var awardSubnodeSerialized = xmlDoc.createElement(nodeName);
                    $(awardSubnodeSerialized).text(value);
                    $(awardSerialized).append(awardSubnodeSerialized);
                  }
                } else {
                  // serialize "funderLogo" which is ImageType
                  var funderLogoSerialized = value.updateDOM();
                  xmlDoc.adoptNode(funderLogoSerialized);
                  $(awardSerialized).append(funderLogoSerialized);
                }
              });

              // Insert new node at correct position
              var insertAfter = model.getXMLPosition(portalNode, "award");
              if (insertAfter) {
                insertAfter.after(awardSerialized);
              } else {
                portalNode.appendChild(awardSerialized);
              }
            });
          }

          /* ====  Serialize associatedParties ==== */

          // Remove element if it exists already
          $portalNode.children("associatedParty").remove();

          // Get new values
          var parties = this.get("associatedParties");

          // Don't serialize falsey values
          if (parties) {
            // Serialize each associatedParty
            _.each(parties, function (party) {
              // Update the DOM of the EMLParty
              var partyEl = party.updateDOM();
              partyDoc = $.parseXML(party.formatXML($(partyEl)[0]));

              // Make sure we don't insert empty EMLParty nodes into the EML
              if (partyDoc.childNodes.length) {
                //Save a reference to the associated party element in the NodeList
                var assocPartyEl = partyDoc.childNodes[0];
                //Add the associated part element to the portal XML doc
                xmlDoc.adoptNode(assocPartyEl);

                // Get the last node of this type to insert after
                var insertAfter = $portalNode
                  .children("associatedParty")
                  .last();

                // If there isn't a node found, find the EML position to insert after
                if (!insertAfter.length) {
                  insertAfter = model.getXMLPosition(
                    portalNode,
                    "associatedParty",
                  );
                }

                //Insert the party DOM at the insert position
                if (insertAfter &amp;&amp; insertAfter.length) {
                  insertAfter.after(assocPartyEl);
                } else {
                  portalNode.appendChild(assocPartyEl);
                }
              }
            });
          }

          try {
            /* ====  Serialize options (including map options) ==== */
            // This will only serialize the options named in `optNames` (below)
            // Functionality needed in order to serialize new or custom options

            // The standard list of options used in portals
            var optNames = this.get("optionNames");

            _.each(optNames, function (optName) {
              //Get the value on the model
              var optValue = model.get(optName),
                existingValue;

              //Get the existing optionName element
              var matchingOption = $portalNode
                .children("option")
                .find("optionName:contains('" + optName + "')");

              //
              if (
                !matchingOption.length ||
                matchingOption.first().text() != optName
              ) {
                matchingOption = false;
              } else {
                //Get the value for this option from the Portal doc
                existingValue = matchingOption.siblings("optionValue").text();
              }

              // Don't serialize null or undefined values. Also don't serialize values that match the default model value
              if (
                (optValue || optValue === 0 || optValue === false) &amp;&amp;
                optValue != model.defaults()[optName]
              ) {
                //Replace the existing option, if it exists
                if (matchingOption) {
                  matchingOption.siblings("optionValue").text(optValue);
                } else {
                  // Make new node
                  // &lt;optionName> and &lt;optionValue> are subelements of &lt;option>
                  var optionSerialized = xmlDoc.createElement("option"),
                    optNameSerialized = xmlDoc.createElement("optionName"),
                    optValueSerialized = xmlDoc.createElement("optionValue");

                  $(optNameSerialized).text(optName);
                  $(optValueSerialized).text(optValue);

                  $(optionSerialized).append(
                    optNameSerialized,
                    optValueSerialized,
                  );

                  // Insert new node at correct position
                  var insertAfter = model.getXMLPosition(portalNode, "option");

                  if (insertAfter) {
                    insertAfter.after(optionSerialized);
                  }
                }
              } else {
                //Remove the elements from the portal XML when the value is invalid
                if (matchingOption) {
                  matchingOption.parent("option").remove();
                }
              }
            });
          } catch (e) {
            console.error(e);
          }

          /* ====  Serialize UI FilterGroups (aka custom search filters) ==== */

          // Get new filter group values
          var filterGroups = this.get("filterGroups");

          // Remove filter groups in the current objectDOM that are at the portal
          // level. (don't use .find("filterGroup") as that would remove
          // filterGroups that are nested in the definition
          $portalNode.children("filterGroup").remove();

          // Make a new node for each filter group in the model
          _.each(filterGroups, function (filterGroup) {
            filterGroupSerialized = filterGroup.updateDOM();

            if (filterGroupSerialized) {
              //Add the new element to the XMLDocument
              xmlDoc.adoptNode(filterGroupSerialized);

              // Insert new node at correct position
              var insertAfter = model.getXMLPosition(portalNode, "filterGroup");

              if (insertAfter) {
                insertAfter.after(filterGroupSerialized);
              } else {
                portalNode.appendChild(filterGroupSerialized);
              }
            }
          });

          /* ====  Remove duplicates ==== */

          //Do a final check to make sure there are no duplicate ids in the XML
          var elementsWithIDs = $(xmlDoc).find("[id]"),
            //Get an array of all the ids in this EML doc
            allIDs = _.map(elementsWithIDs, function (el) {
              return $(el).attr("id");
            });

          //If there is at least one id in the EML...
          if (allIDs &amp;&amp; allIDs.length) {
            //Boil the array down to just the unique values
            var uniqueIDs = _.uniq(allIDs);

            //If the unique array is shorter than the array of all ids,
            // then there is a duplicate somewhere
            if (uniqueIDs.length &lt; allIDs.length) {
              //For each element in the EML that has an id,
              _.each(elementsWithIDs, function (el) {
                //Get the id for this element
                var id = $(el).attr("id");

                //If there is more than one element in the EML with this id,
                if ($(xmlDoc).find("[id='" + id + "']").length > 1) {
                  //And if it is not a unit node, which we don't want to change,
                  if (!$(el).is("unit"))
                    //Then change the id attribute to a random uuid
                    $(el).attr("id", "urn-uuid-" + uuid.v4());
                }
              });
            }
          }

          // Convert xml to xmlString and return xmlString
          xmlString = new XMLSerializer().serializeToString(xmlDoc);

          //If there isn't an XML declaration, add one
          if (xmlString.indexOf("&lt;?xml") == -1) {
            xmlString = '&lt;?xml version="1.0" encoding="UTF-8"?>' + xmlString;
          }

          return xmlString;
        } catch (e) {
          console.error("Error while serializing the Portal XML document: ", e);
          this.set("errorMessage", e.stack);
          this.trigger(
            "errorSaving",
            MetacatUI.appModel.get("portalEditSaveErrorMsg"),
          );
          return;
        }
      },

      /**
       * Checks whether the given sectionModel has been updated by the
       * user, or whether all attributes match their default values.
       * For a section's markdown, the default value is either an empty
       * string or null. For a section's label, the default
       * value is either an empty string or a string that begins with the
       * value set to PortalModel.newSectionLabel. For all other attributes,
       * the defaults are set in PortalSectionModel.defaults.
       * @param {PortalSectionModel} sectionModel - The model to check against a default model
       * @return {boolean} returns true if the sectionModel matches a default model, and false when at least one attribute differs
       */
      sectionIsDefault: function (sectionModel) {
        try {
          var defaults = sectionModel.defaults(),
            currentMarkdown = sectionModel.get("content").get("markdown"),
            labelRegex = new RegExp("^" + this.newSectionLabel, "i");

          // For each attribute, check whether it matches the default
          if (
            // Check whether markdown matches the content that's
            // auto-filled or whether it's empty
            //currentMarkdown === this.markdownExample ||
            (currentMarkdown == "" || currentMarkdown == null) &amp;&amp;
            sectionModel.get("image") === defaults.image &amp;&amp;
            sectionModel.get("introduction") === defaults.introduction &amp;&amp;
            // Check whether label starts with the default new page name,
            // or whether it's empty
            (labelRegex.test(sectionModel.get("label")) ||
              sectionModel.get("label") == "" ||
              sectionModel.get("label") == null) &amp;&amp;
            sectionModel.get("literatureCited") === defaults.literatureCited &amp;&amp;
            sectionModel.get("title") === defaults.title
          ) {
            // All elements of the section match the default
            return true;
          } else {
            // At least one attribute of the section has been updated
            return false;
          }
        } catch (e) {
          // If there's a problem with this function for some reason,
          // return false so that the section is serialized to avoid
          // losing information
          console.log(
            "Failed to check whether section model is default. Serializing it anyway. Error message:" +
              e,
          );
          return false;
        }
      },

      /**
       * Initialize the object XML for a brand spankin' new portal
       * @inheritdoc
       *
       */
      createXML: function () {
        var format =
          MetacatUI.appModel.get("portalEditorSerializationFormat") ||
          "https://purl.dataone.org/portals-1.1.0";
        var xmlString = '&lt;por:portal xmlns:por="' + format + '">&lt;/por:portal>';
        var xmlNew = $.parseXML(xmlString);
        var portalNode = xmlNew.getElementsByTagName("por:portal")[0];

        this.set("ownerDocument", portalNode.ownerDocument);
        return xmlNew;
      },

      /**
       * Overrides the default Backbone.Model.validate.function() to
       * check if this portal model has all the required values necessary
       * to save to the server.
       *
       * @param {Object} [attrs] - A literal object of model attributes to validate.
       * @param {Object} [options] - A literal object of options for this validation process
       * @return {Object} If there are errors, an object comprising error
       *                   messages. If no errors, returns nothing.
       */
      validate: function (attrs, options) {
        try {
          var errors = {},
            requiredFields =
              MetacatUI.appModel.get("portalEditorRequiredFields") || {};

          //Execute the superclass validate() function
          var collectionErrors = this.constructor.__super__.validate.call(this);
          if (
            typeof collectionErrors == "object" &amp;&amp;
            Object.keys(collectionErrors).length
          ) {
            //Use the errors messages from the CollectionModel for this PortalModel
            errors = collectionErrors;
          }

          // ---- Validate the description and name ----
          //Map the model attributes to the user-facing attribute name
          var textFields = {
            description: "description",
            name: "title",
          };
          //Iterate over each text field
          _.each(
            Object.keys(textFields),
            function (field) {
              //If this field is required, and it is a string
              if (requiredFields[field] &amp;&amp; typeof this.get(field) == "string") {
                //If this is an empty string, set an error message
                if (!this.get(field).trim().length) {
                  errors[field] = "A " + textFields[field] + " is required.";
                }
              }
              //If this field is required, and it's not a string at all, set an error message
              else if (requiredFields[field]) {
                errors[field] = "A " + textFields[field] + " is required.";
              }
            },
            this,
          );

          //---Validate the sections---
          //Iterate over each section model
          _.each(
            this.get("sections"),
            function (section) {
              //Validate the section model
              var sectionErrors = section.validate();

              //If there is at least one error, then add an error to the PortalModel error list
              if (sectionErrors &amp;&amp; Object.keys(sectionErrors).length) {
                errors.sections = "At least one section has an error";
              }
            },
            this,
          );

          //----Validate the logo----
          if (
            requiredFields.logo &amp;&amp;
            (!this.get("logo") || !this.get("logo").get("identifier"))
          ) {
            errors.logo = "A logo image is required";
          } else if (this.get("logo")) {
            logoErrors = this.get("logo").validate();
            if (logoErrors &amp;&amp; Object.keys(logoErrors).length) {
              errors.logo = "A logo image is required";
            }
          }

          //---Validate the acknowledgmentsLogo---

          var nonEmptyAckLogos = this.get("acknowledgmentsLogos").filter(
            function (portalImage) {
              return !portalImage.isEmpty();
            },
          );

          if (requiredFields.acknowledgmentsLogos &amp;&amp; !nonEmptyAckLogos.length) {
            errors.acknowledgmentsLogos =
              "At least one partner logo image is required.";
          } else if (nonEmptyAckLogos &amp;&amp; nonEmptyAckLogos.length) {
            _.each(
              nonEmptyAckLogos,
              function (ackLogo) {
                // Validate the portal image model
                var ackLogoErrors = ackLogo.validate();

                // If there is at least one error, then add an error to the PortalModel error list
                if (ackLogoErrors &amp;&amp; Object.keys(ackLogoErrors).length) {
                  errors.acknowledgmentsLogosImages =
                    "At least one acknowledgment logo has an error";
                }
              },
              this,
            );
          }

          //TODO: Validate these other elements, listed below, as they are added to the portal editor

          //---Validate the associatedParties---

          //---Validate the acknowledgments---

          //---Validate the award---

          //---Validate the literatureCited---

          //---Validate the filterGroups---

          //Return the errors object
          if (Object.keys(errors).length) return errors;
          else {
            return;
          }
        } catch (e) {
          console.error(e);
        }
      },

      /**
       * Checks for the existing block list for repository labels
       * If at least one other Portal has the same label, then it is not available.
       * @param {string} label - The label to query for
       */
      checkLabelAvailability: function (label) {
        //Validate the label set on the model if one isn't given
        if (!label || typeof label != "string") {
          var label = this.get("label");
          if (!label || typeof label != "string") {
            //Trigger an error event
            this.trigger("errorValidatingLabel");
            console.error("error validating label, no label provided");
            return;
          }
        }

        var model = this;

        if (!this.get("checkedNodeLabels")) {
          // query CN to fetch the latest node data
          model.updateNodeBlockList();

          this.listenTo(this, "change:checkedNodeLabels", function () {
            this.checkPortalLabelAvailability(label);
          });
        } else {
          this.checkPortalLabelAvailability(label);
        }
      },

      /**
       * Queries the Solr discovery index for other Portal objects with this same label.
       * Also, checks for the existing block list for repository labels
       * If at least one other Portal has the same label, then it is not available.
       * @param {string} label - The label to query for
       */
      checkPortalLabelAvailability: function (label) {
        var model = this;

        // Stop Listening to the node model. We only need to retrieve this node label once.
        this.stopListening(this, "change:checkedNodeLabels", function () {
          this.checkPortalLabelAvailability(label);
        });

        // Convert the block list to lower case for case insensitive match
        var lowerCaseBlockList = this.get("labelBlockList").map(
          function (value) {
            return value.toLowerCase();
          },
        );

        // Check the existing blockList before making a Solr call
        if (lowerCaseBlockList.indexOf(label.toLowerCase()) > -1) {
          model.trigger("labelTaken");
          return;
        }

        // Query solr to see if other portals already use this label
        var requestSettings = {
          url:
            MetacatUI.appModel.get("queryServiceUrl") +
            'q=label:"' +
            label +
            '"' +
            ' AND formatId:"' +
            this.get("formatId") +
            '"' +
            "&amp;rows=0" +
            "&amp;wt=json",
          error: function (response) {
            model.trigger("errorValidatingLabel");
          },
          success: function (response) {
            if (response.response.numFound > 0) {
              //Add this label to the blockList so we don't have to query for it later
              var blockList = model.get("labelBlockList");
              if (Array.isArray(blockList)) {
                blockList.push(label);
              }

              model.trigger("labelTaken");
            } else {
              if (MetacatUI.appModel.get("alternateRepositories").length) {
                MetacatUI.appModel.setActiveAltRepo();
                var activeAltRepo = MetacatUI.appModel.getActiveAltRepo();
                if (activeAltRepo) {
                  var requestSettings = {
                    url:
                      activeAltRepo.queryServiceUrl +
                      'q=label:"' +
                      label +
                      '"' +
                      ' AND formatId:"' +
                      model.get("formatId") +
                      '"' +
                      "&amp;rows=0" +
                      "&amp;wt=json",
                    error: function (response) {
                      model.trigger("errorValidatingLabel");
                    },
                    success: function (response) {
                      if (response.response.numFound > 0) {
                        //Add this label to the blockList so we don't have to query for it later
                        var blockList = model.get("labelBlockList");
                        if (Array.isArray(blockList)) {
                          blockList.push(label);
                        }

                        model.trigger("labelTaken");
                      } else {
                        model.trigger("labelAvailable");
                      }
                    },
                  };
                  //Attach the User auth info and send the request
                  requestSettings = _.extend(
                    requestSettings,
                    MetacatUI.appUserModel.createAjaxSettings(),
                  );
                  $.ajax(requestSettings);
                }
              } else {
                model.trigger("labelAvailable");
              }
            }
          },
        };
        //Attach the User auth info and send the request
        requestSettings = _.extend(
          requestSettings,
          MetacatUI.appUserModel.createAjaxSettings(),
        );
        $.ajax(requestSettings);
      },

      /**
       * Queries the CN Solr to retrieve the updated BlockList
       */
      updateNodeBlockList: function () {
        var model = this;

        $.ajax({
          url: MetacatUI.appModel.get("nodeServiceUrl"),
          dataType: "text",
          error: function (data, textStatus, xhr) {
            // if there is an error in retrieving the node list;
            // proceed with the existing node list to perform the checks
            model.checkPortalLabelAvailability();
          },
          success: function (data, textStatus, xhr) {
            var xmlResponse = $.parseXML(data) || null;
            if (!xmlResponse) return;

            // update the node block list on success
            model.saveNodeBlockList(xmlResponse);
          },
        });
      },

      /**
       * Parses the retrieved XML document and saves the node information to the BlockList
       *
       * @param {XMLDocument} The XMLDocument returned from the fetch() AJAX call
       */
      saveNodeBlockList: function (xml) {
        var model = this,
          children = xml.children || xml.childNodes;

        //Traverse the XML response to get the MN info
        _.each(children, function (d1NodeList) {
          var d1NodeListChildren = d1NodeList.children || d1NodeList.childNodes;

          //The first (and only) child should be the d1NodeList
          _.each(d1NodeListChildren, function (thisNode) {
            //Ignore parts of the XML that is not MN info
            if (!thisNode.attributes) return;

            //'node' will be a single node
            var node = {},
              nodeProperties = thisNode.children || thisNode.childNodes;

            //Grab information about this node from XML nodes
            _.each(nodeProperties, function (nodeProperty) {
              if (nodeProperty.nodeName == "property")
                node[$(nodeProperty).attr("key")] = nodeProperty.textContent;
              else node[nodeProperty.nodeName] = nodeProperty.textContent;

              //Check if this member node has v2 read capabilities - important for the Package service
              if (
                nodeProperty.nodeName == "services" &amp;&amp;
                nodeProperty.childNodes.length
              ) {
                var v2 = $(nodeProperty).find(
                  "service[name='MNRead'][version='v2'][available='true']",
                ).length;
                node["readv2"] = v2;
              }
            });

            //Grab information about this node from XLM attributes
            _.each(thisNode.attributes, function (attribute) {
              node[attribute.nodeName] = attribute.nodeValue;
            });

            // Append Node name, node identifier and node short identifier to the array.
            // node identifier
            if (
              Array.isArray(model.get("labelBlockList")) &amp;&amp;
              model.get("labelBlockList").indexOf(node.identifier) &lt; 0
            ) {
              model.get("labelBlockList").push(node.identifier);
            }

            // node name
            if (node.CN_node_name) {
              node.name = node.CN_node_name;
              if (
                Array.isArray(model.get("labelBlockList")) &amp;&amp;
                model.get("labelBlockList").indexOf(node.name) &lt; 0
              ) {
                model.get("labelBlockList").push(node.name);
              }
            }

            // node short identifier
            node.shortIdentifier = node.identifier.substring(
              node.identifier.lastIndexOf(":") + 1,
            );
            if (
              Array.isArray(model.get("labelBlockList")) &amp;&amp;
              model.get("labelBlockList").indexOf(node.shortIdentifier) &lt; 0
            ) {
              model.get("labelBlockList").push(node.shortIdentifier);
            }
          });
        });

        this.set("checkedNodeLabels", "true");
      },

      /**
       * Removes nodes from the XML that do not have an accompanying model
       * (i.e. nodes which were probably removed by the user during editing)
       *
       * @param {jQuery} nodes - The nodes to potentially remove
       * @param {Model[]} models - The model to compare to
       */
      removeExtraNodes: function (nodes, models) {
        // Remove the extra nodes
        var extraNodes = nodes.length - models.length;
        if (extraNodes > 0) {
          for (var i = models.length; i &lt; nodes.length; i++) {
            $(nodes[i]).remove();
          }
        }
      },

      /**
       * Saves the portal XML document to the server using the DataONE API
       */
      save: function () {
        var model = this;

        // Remove empty filters from the custom portal search filters.
        this.get("filterGroups").forEach(function (filterGroupModel) {
          filterGroupModel.get("filters").removeEmptyFilters();
        }, this);

        // Ensure empty filters (rule groups) are removed, including from
        // within any nested filter groups
        this.get("definitionFilters").removeEmptyFilters(true);

        // Validate before we try anything else
        if (!this.isValid()) {
          //Trigger the invalid and cancelSave events
          this.trigger("invalid");
          this.trigger("cancelSave");
          //Don't save the model since it's invalid
          return false;
        } else {
          //Double-check that the label is available, if it was changed
          if (
            (this.isNew() || this.get("originalLabel") != this.get("label")) &amp;&amp;
            !this.get("labelDoubleChecked")
          ) {
            //If the label is taken
            this.once("labelTaken", function () {
              //Stop listening to the label availability
              this.stopListening("labelAvailable");

              //Set that the label has been double-checked
              this.set("labelDoubleChecked", true);

              //If this portal is in a free trial of DataONE Plus, generate a new random label
              // and start the save process again
              if (MetacatUI.appModel.get("enableBookkeeperServices")) {
                var subscription = MetacatUI.appUserModel.get(
                  "dataoneSubscription",
                );
                if (subscription &amp;&amp; subscription.isTrialing()) {
                  this.setRandomLabel();

                  this.set("labelDoubleChecked", true);

                  // Start the save process again
                  this.save();

                  return;
                }
              } else {
                //If the label is taken, trigger an invalid event
                this.trigger("invalid");
                //Trigger a cancellation of the save event
                this.trigger("cancelSave");
              }
            });

            this.once("labelAvailable", function () {
              this.stopListening("labelTaken");
              this.set("labelDoubleChecked", true);
              this.save();
            });

            // Check label availability
            this.checkLabelAvailability(this.get("label"));

            // console.log("Double checking label");

            //Don't proceed with the rest of the save
            return;
          } else {
            this.trigger("valid");
          }
        }

        //Check if the checksum has been calculated yet.
        if (!this.get("checksum")) {
          // Serialize the XML
          var xml = this.serialize();

          //If there is no xml returned from the serialize() function, then there
          // was an error, so don't save.
          if (typeof xml === "undefined" || !xml) {
            //If no error message is set on the model, trigger an error now.
            // If there is an error message already, it means the error has already
            // been triggered inside the serialize() function.
            if (!this.get("errorMessage")) {
              this.trigger(
                "errorSaving",
                MetacatUI.appModel.get("portalEditSaveErrorMsg"),
              );
            }

            return;
          }

          var xmlBlob = new Blob([xml], { type: "application/xml" });

          //Set the Blob as the upload file
          this.set("uploadFile", xmlBlob);

          //When it is calculated, restart this function
          this.off("checksumCalculated", this.save);
          this.on("checksumCalculated", this.save);
          //Calculate the checksum for this file
          this.calculateChecksum();

          //Exit this function until the checksum is done
          return;
        }

        this.constructor.__super__.save.call(this);
      },

      /**
       * Removes or hides the given section from this Portal
       * @param {PortalSectionModel|string} section - Either the PortalSectionModel
       * to remove, or the name of the section to remove. Some sections in the portals
       * are not tied to PortalSectionModels, because they are created from other parts of the Portal
       * document. For example, the Data, Metrics, and Members sections.
       */
      removeSection: function (section) {
        try {
          //If this section is a string, remove it by adding custom options
          if (typeof section == "string") {
            switch (section.toLowerCase()) {
              case "data":
                this.set("hideData", true);
                break;
              case "metrics":
                this.set("hideMetrics", true);
                break;
              case "members":
                this.set("hideMembers", true);
                break;
            }
          }
          //If this section is a section model, delete it from this Portal
          else if (PortalSectionModel.prototype.isPrototypeOf(section)) {
            // Remove the section from the model's sections array object.
            // Use clone() to create new array reference and ensure change
            // event is tirggered.
            var sectionModels = _.clone(this.get("sections"));
            sectionModels.splice($.inArray(section, sectionModels), 1);
            this.set({ sections: sectionModels });
          } else {
            return;
          }
        } catch (e) {
          console.error(e);
        }
      },

      /**
       * Adds the given section to this Portal
       * @param {PortalSectionModel|string} section - Either the PortalSectionModel
       * to add, or the name of the section to add. Some sections in the portals
       * are not tied to PortalSectionModels, because they are created from other parts of the Portal
       * document. For example, the Data, Metrics, and Members sections.
       */
      addSection: function (section) {
        try {
          //If this section is a string, add it by adding custom options
          if (typeof section == "string") {
            switch (section.toLowerCase()) {
              case "data":
                this.set("hideData", null);
                break;
              case "metrics":
                this.set("hideMetrics", null);
                break;
              case "members":
                this.set("hideMembers", null);
                break;
              case "freeform":
                // Add a new, blank markdown section with a default image
                var sectionModels = _.clone(this.get("sections")),
                  newSection = new PortalSectionModel({
                    portalModel: this,
                    // Include a default image if some are configured.
                    image: this.getRandomSectionImage(),
                  });

                sectionModels.push(newSection);
                this.set("sections", sectionModels);
                // Trigger event manually so we can just pass newSection
                this.trigger("addSection", newSection);
                break;
            }
          }
          // If this section is a section model, add it to this Portal
          else if (PortalSectionModel.prototype.isPrototypeOf(section)) {
            var sectionModels = _.clone(this.get("sections"));
            sectionModels.push(section);
            this.set({ sections: sectionModels });
            // trigger event manually so we can just pass newSection
            this.trigger("addSection", section);
          } else {
            return;
          }
        } catch (e) {
          console.error(e);
        }
      },

      /**
       * removePortalImage - remove a PortalImage model from either the
       * logo, sections, or acknowledgmentsLogos node of the portal model.
       *
       * @param  {Image} portalImage the portalImage model to remove
       */
      removePortalImage: function (portalImage) {
        try {
          // find the portalImage to remove
          switch (portalImage.get("nodeName")) {
            case "logo":
              if (portalImage === this.get("logo")) {
                this.set("logo", this.defaults().logo);
              }
              break;
            case "image":
              _.each(this.get("sections"), function (section, i) {
                if (portalImage === section.get("image")) {
                  section.set("image", section.defaults().image);
                }
              });
              break;
            case "acknowledgmentsLogo":
              var ackLogos = _.clone(this.get("acknowledgmentsLogos"));
              ackLogos.splice($.inArray(portalImage, ackLogos), 1);
              this.set({ acknowledgmentsLogos: ackLogos });
              break;
          }
        } catch (e) {
          console.log(
            "Failed to remove a portalImage model, error message: " + e,
          );
        }
      },

      /**
       * Saves a reference to this Portal on the MetacatUI global object
       */
      cachePortal: function () {
        if (this.get("id")) {
          MetacatUI.portals = MetacatUI.portals || {};
          MetacatUI.portals[this.get("id")] = this;
        }

        this.on("change:id", this.cachePortal);
      },

      /**
       * Creates a URL for viewing more information about this object
       * @return {string}
       */
      createViewURL: function () {
        return (
          MetacatUI.root +
          "/" +
          MetacatUI.appModel.get("portalTermPlural") +
          "/" +
          encodeURIComponent(
            this.get("label") || this.get("seriesId") || this.get("id"),
          )
        );
      },

      /**
       * Sets attributes on this Portal using the given Member Node data
       * @param {object} nodeInfoObject - A literal object taken from the NodeModel 'members' array
       */
      createNodeAttributes: function (nodeInfoObject) {
        var nodePortalModel = {};

        if (nodeInfoObject === undefined) {
          nodeInfoObject = {};
        }

        //TODO - check for undefined for each of the nodeInfo properties

        // Setting basic properties from the node info object
        this.set("name", nodeInfoObject.name);
        this.set("logo", nodeInfoObject.logo);
        this.set("description", nodeInfoObject.description);

        // Creating repo specific Filters
        var nodeFilterModel = new FilterModel({
          fields: ["datasource"],
          values: [nodeInfoObject.identifier],
          label: "Datasets for a repository",
          matchSubstring: false,
          operator: "OR",
        });

        // adding the filter in the node model
        this.get("definitionFilters").add(nodeFilterModel);

        // Set up the search model
        this.get("searchModel").get("filters").add(nodeFilterModel);
      },

      /**
       * Cleans up the given text so that it is XML-valid by escaping reserved characters, trimming white space, etc.
       *
       * @param {string} textString - The string to clean up
       * @return {string} - The cleaned up string
       */
      cleanXMLText: function (textString) {
        if (typeof textString != "string") return;

        textString = textString.trim();

        //Check for XML/HTML elements
        _.each(textString.match(/&lt;\s*[^>]*>/g), function (xmlNode) {
          //Encode &lt;, >, and &lt;/ substrings
          var tagName = xmlNode.replace(/>/g, "&amp;gt;");
          tagName = tagName.replace(/&lt;/g, "&amp;lt;");

          //Replace the xmlNode in the full text string
          textString = textString.replace(xmlNode, tagName);
        });

        //Remove Unicode characters that are not valid XML characters
        //Create a regular expression that matches any character that is not a valid XML character
        // (see https://www.w3.org/TR/xml/#charsets)
        var invalidCharsRegEx =
          /[^\u0009\u000a\u000d\u0020-\uD7FF\uE000-\uFFFD]/g;
        textString = textString.replace(invalidCharsRegEx, "");

        return textString;
      },

      /**
       * Generates a random portal label for free trial portals
       * @fires PortalModel#change:label
       * @since 2.14.0
       */
      setRandomLabel: function () {
        if (this.isNew()) {
          var labelLength = MetacatUI.appModel.get("randomLabelNumericLength");
          var randomGeneratedLabel = Math.floor(
            Math.pow(10, labelLength - 1) +
              Math.random() * (9 * Math.pow(10, labelLength - 1)),
          );
          randomGeneratedLabel = randomGeneratedLabel.toString();
          this.set("label", randomGeneratedLabel);
        }
      },
    },
  );

  return PortalModel;
});
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
