<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>MetacatUI Dev Docs: Source: src/js/models/portals/PortalModel.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="/assets/css/styles.css">
    <link type="text/css" rel="stylesheet" href="styles/style.css">
</head>

<body>

<nav id="nav">
    <a href="/">
      <div class="logo">
<svg class="cat" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="cat" class="svg-inline--fa fa-cat fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M290.59 192c-20.18 0-106.82 1.98-162.59 85.95V192c0-52.94-43.06-96-96-96-17.67 0-32 14.33-32 32s14.33 32 32 32c17.64 0 32 14.36 32 32v256c0 35.3 28.7 64 64 64h176c8.84 0 16-7.16 16-16v-16c0-17.67-14.33-32-32-32h-32l128-96v144c0 8.84 7.16 16 16 16h32c8.84 0 16-7.16 16-16V289.86c-10.29 2.67-20.89 4.54-32 4.54-61.81 0-113.52-44.05-125.41-102.4zM448 96h-64l-64-64v134.4c0 53.02 42.98 96 96 96s96-42.98 96-96V32l-64 64zm-72 80c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16zm80 0c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16z"></path></svg>

<svg width="459px" height="53px" viewBox="0 0 459 53" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="metacatui" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M16.492,52 C17.212,52 17.812,51.748 18.292,51.244 C18.772,50.74 19.012,50.128 19.012,49.408 L19.012,49.408 L18.94,22.912 L30.82,37.816 C31.204,38.344 31.72,38.764 32.368,39.076 C33.016,39.388 33.7,39.544 34.42,39.544 C35.908,39.544 37.132,38.896 38.092,37.6 L38.092,37.6 L49.684,22.912 L49.684,49.408 C49.684,50.128 49.96,50.74 50.512,51.244 C51.064,51.748 51.7,52 52.42,52 L52.42,52 L62.068,52 C62.788,52 63.388,51.748 63.868,51.244 C64.348,50.74 64.588,50.128 64.588,49.408 L64.588,49.408 L64.588,4.12 C64.588,3.448 64.336,2.86 63.832,2.356 C63.328,1.852 62.74,1.6 62.068,1.6 L62.068,1.6 L52.348,1.6 C51.388,1.6 50.56,1.648 49.864,1.744 C49.168,1.84 48.532,2.152 47.956,2.68 L47.956,2.68 L33.916,17.296 L20.524,2.608 C20.332,2.368 19.972,2.14 19.444,1.924 C18.916,1.708 18.412,1.6 17.932,1.6 L17.932,1.6 L6.772,1.6 C6.052,1.6 5.44,1.852 4.936,2.356 C4.432,2.86 4.18,3.448 4.18,4.12 L4.18,4.12 L4.18,49.408 C4.18,50.08 4.432,50.68 4.936,51.208 C5.44,51.736 6.052,52 6.772,52 L6.772,52 L16.492,52 Z M110.74,52 C111.556,52 112.264,51.676 112.864,51.028 C113.464,50.38 113.764,49.624 113.764,48.76 L113.764,48.76 L113.764,42.568 C113.764,41.608 113.464,40.828 112.864,40.228 C112.264,39.628 111.556,39.328 110.74,39.328 L110.74,39.328 L89.428,39.328 L89.428,32.92 L109.732,32.92 C110.5,32.92 111.184,32.596 111.784,31.948 C112.384,31.3 112.684,30.568 112.684,29.752 L112.684,29.752 L112.684,23.488 C112.684,22.576 112.384,21.82 111.784,21.22 C111.184,20.62 110.5,20.32 109.732,20.32 L109.732,20.32 L89.428,20.32 L89.428,14.488 L110.74,14.488 C111.508,14.488 112.204,14.164 112.828,13.516 C113.452,12.868 113.764,12.136 113.764,11.32 L113.764,11.32 L113.764,5.056 C113.764,4.144 113.464,3.388 112.864,2.788 C112.264,2.188 111.556,1.888 110.74,1.888 L110.74,1.888 L76.756,1.888 C75.94,1.888 75.232,2.188 74.632,2.788 C74.032,3.388 73.732,4.144 73.732,5.056 L73.732,5.056 L73.732,48.76 C73.732,49.624 74.032,50.38 74.632,51.028 C75.232,51.676 75.94,52 76.756,52 L76.756,52 L110.74,52 Z M147.604,52 C148.42,52 149.104,51.688 149.656,51.064 C150.208,50.44 150.484,49.672 150.484,48.76 L150.484,48.76 L150.484,16.216 L161.86,16.216 C162.676,16.216 163.396,15.904 164.02,15.28 C164.644,14.656 164.956,13.936 164.956,13.12 L164.956,13.12 L164.956,4.768 C164.956,4 164.644,3.316 164.02,2.716 C163.396,2.116 162.676,1.816 161.86,1.816 L161.86,1.816 L124.132,1.816 C123.22,1.816 122.464,2.104 121.864,2.68 C121.264,3.256 120.964,3.952 120.964,4.768 L120.964,4.768 L120.964,13.12 C120.964,13.936 121.264,14.656 121.864,15.28 C122.464,15.904 123.22,16.216 124.132,16.216 L124.132,16.216 L135.652,16.216 L135.148,48.832 C135.148,49.744 135.424,50.5 135.976,51.1 C136.528,51.7 137.212,52 138.028,52 L138.028,52 L147.604,52 Z M175.828,52 C176.836,52 177.676,51.82 178.348,51.46 C179.02,51.1 179.452,50.584 179.644,49.912 L179.644,49.912 L181.876,42.712 L197.932,42.712 L200.164,49.912 C200.356,50.584 200.8,51.1 201.496,51.46 C202.192,51.82 203.044,52 204.052,52 L204.052,52 L213.916,52 C215.836,51.712 216.796,50.704 216.796,48.976 C216.796,48.304 216.676,47.596 216.436,46.852 C216.196,46.108 216.052,45.616 216.004,45.376 L216.004,45.376 L199.876,4.84 C199.588,3.976 199.036,3.232 198.22,2.608 C197.404,1.984 196.372,1.648 195.124,1.6 L195.124,1.6 L184.756,1.6 C183.604,1.648 182.608,1.948 181.768,2.5 C180.928,3.052 180.292,3.832 179.86,4.84 L179.86,4.84 L163.876,45.376 C163.828,45.472 163.672,45.916 163.408,46.708 C163.144,47.5 163.012,48.304 163.012,49.12 C163.012,50.752 163.948,51.712 165.82,52 L165.82,52 L175.828,52 Z M195.34,30.544 L184.036,30.544 L189.652,13.624 L195.34,30.544 Z M245.38,53.08 C250.612,53.08 255.652,51.544 260.5,48.472 C261.22,47.944 261.58,47.296 261.58,46.528 C261.58,45.808 261.292,45.16 260.716,44.584 L260.716,44.584 L252.796,36.808 C252.364,36.376 251.836,36.16 251.212,36.16 C250.78,36.16 250.372,36.256 249.988,36.448 C248.356,37.12 246.796,37.456 245.308,37.456 C243.244,37.456 241.348,36.952 239.62,35.944 C237.892,34.936 236.512,33.58 235.48,31.876 C234.448,30.172 233.932,28.336 233.932,26.368 C233.932,24.352 234.436,22.504 235.444,20.824 C236.452,19.144 237.832,17.812 239.584,16.828 C241.336,15.844 243.244,15.352 245.308,15.352 C246.892,15.352 248.332,15.64 249.628,16.216 C250.012,16.408 250.444,16.504 250.924,16.504 C251.548,16.504 252.1,16.264 252.58,15.784 L252.58,15.784 L259.636,8.008 C260.164,7.384 260.428,6.76 260.428,6.136 C260.428,5.224 259.996,4.528 259.132,4.048 C254.86,1.552 250.276,0.304 245.38,0.304 C240.532,0.304 236.032,1.492 231.88,3.868 C227.728,6.244 224.44,9.448 222.016,13.48 C219.592,17.512 218.38,21.904 218.38,26.656 C218.38,31.408 219.592,35.812 222.016,39.868 C224.44,43.924 227.728,47.14 231.88,49.516 C236.032,51.892 240.532,53.08 245.38,53.08 Z M279.796,52 C280.804,52 281.644,51.82 282.316,51.46 C282.988,51.1 283.42,50.584 283.612,49.912 L283.612,49.912 L285.844,42.712 L301.9,42.712 L304.132,49.912 C304.324,50.584 304.768,51.1 305.464,51.46 C306.16,51.82 307.012,52 308.02,52 L308.02,52 L317.884,52 C319.804,51.712 320.764,50.704 320.764,48.976 C320.764,48.304 320.644,47.596 320.404,46.852 C320.164,46.108 320.02,45.616 319.972,45.376 L319.972,45.376 L303.844,4.84 C303.556,3.976 303.004,3.232 302.188,2.608 C301.372,1.984 300.34,1.648 299.092,1.6 L299.092,1.6 L288.724,1.6 C287.572,1.648 286.576,1.948 285.736,2.5 C284.896,3.052 284.26,3.832 283.828,4.84 L283.828,4.84 L267.844,45.376 C267.796,45.472 267.64,45.916 267.376,46.708 C267.112,47.5 266.98,48.304 266.98,49.12 C266.98,50.752 267.916,51.712 269.788,52 L269.788,52 L279.796,52 Z M299.308,30.544 L288.004,30.544 L293.62,13.624 L299.308,30.544 Z M352.588,52 C353.404,52 354.088,51.688 354.64,51.064 C355.192,50.44 355.468,49.672 355.468,48.76 L355.468,48.76 L355.468,16.216 L366.844,16.216 C367.66,16.216 368.38,15.904 369.004,15.28 C369.628,14.656 369.94,13.936 369.94,13.12 L369.94,13.12 L369.94,4.768 C369.94,4 369.628,3.316 369.004,2.716 C368.38,2.116 367.66,1.816 366.844,1.816 L366.844,1.816 L329.116,1.816 C328.204,1.816 327.448,2.104 326.848,2.68 C326.248,3.256 325.948,3.952 325.948,4.768 L325.948,4.768 L325.948,13.12 C325.948,13.936 326.248,14.656 326.848,15.28 C327.448,15.904 328.204,16.216 329.116,16.216 L329.116,16.216 L340.636,16.216 L340.132,48.832 C340.132,49.744 340.408,50.5 340.96,51.1 C341.512,51.7 342.196,52 343.012,52 L343.012,52 L352.588,52 Z M402.052,52.792 C408.1,52.792 412.912,51.628 416.488,49.3 C420.064,46.972 422.536,44.068 423.904,40.588 C425.272,37.108 425.932,33.424 425.884,29.536 C425.884,29.5309474 425.883967,29.5237673 425.8839,29.5144598 L425.883102,29.4330859 C425.879911,29.1480111 425.868211,28.3183158 425.848,26.944 C425.8294,25.6792 425.818008,22.91524 425.813823,18.65212 L425.813103,17.80828 C425.812997,17.66452 425.8129,17.5192 425.81281,17.37232 L425.812,3.904 C425.86,3.184 425.632,2.62 425.128,2.212 C424.624,1.804 423.916,1.6 423.004,1.6 L423.004,1.6 L413.428,1.6 C412.612,1.6 411.904,1.828 411.304,2.284 C410.704,2.74 410.404,3.28 410.404,3.904 L410.404,3.904 L410.26,27.808 C410.26,34.144 407.476,37.312 401.908,37.312 C399.076,37.312 396.832,36.412 395.176,34.612 C393.52,32.812 392.668,30.352 392.62,27.232 L392.62,27.232 L392.332,3.76 C392.332,3.088 392.068,2.56 391.54,2.176 C391.012,1.792 390.268,1.6 389.308,1.6 L389.308,1.6 L379.876,1.6 C378.244,1.6 377.428,2.32 377.428,3.76 L377.428,3.76 L377.5,28.816 C377.5,33.04 378.376,36.964 380.128,40.588 C381.88,44.212 384.592,47.152 388.264,49.408 C391.936,51.664 396.532,52.792 402.052,52.792 Z M449.284,52.144 C450.148,52.144 450.88,51.844 451.48,51.244 C452.08,50.644 452.38,49.84 452.38,48.832 L452.38,48.832 L452.38,4.912 C452.38,4 452.08,3.22 451.48,2.572 C450.88,1.924 450.148,1.6 449.284,1.6 L449.284,1.6 L439.42,1.6 C438.46,1.6 437.692,1.924 437.116,2.572 C436.54,3.22 436.252,4 436.252,4.912 L436.252,4.912 L436.252,48.832 C436.252,49.84 436.54,50.644 437.116,51.244 C437.692,51.844 438.46,52.144 439.42,52.144 L439.42,52.144 L449.284,52.144 Z" id="metacatui" fill="#FCBF49" fill-rule="nonzero"></path>
    </g>
</svg>
</logo>

    </a>
    <h3>Namespaces</h3><ul><li><a href="AppConfig.html">AppConfig</a></li><li><a href="MetacatUI.html">MetacatUI</a></li><li><a href="Utilities.html">Utilities</a></li></ul><h3>Classes</h3><ul><li class='category-heading' data-category='Collections'>Collections</li><li><a href="AccessPolicy.html">AccessPolicy</a></li><li><a href="Citations.html">Citations</a></li><li><a href="DataPackage.html">DataPackage</a></li><li><a href="Filters.html">Filters</a></li><li><a href="ObjectFormats.html">ObjectFormats</a></li><li><a href="QualityReport.html">QualityReport</a></li><li><a href="SolrResults.html">SolrResults</a></li><li><a href="Units.html">Units</a></li><li><a href="UserGroup.html">UserGroup</a></li><li class='category-heading' data-category='Collections/Bookkeeper'>Collections/Bookkeeper</li><li><a href="Quotas.html">Quotas</a></li><li><a href="Usages.html">Usages</a></li><li class='category-heading' data-category='Collections/QueryFields'>Collections/QueryFields</li><li><a href="QueryFields.html">QueryFields</a></li><li class='category-heading' data-category='Models'>Models</li><li><a href="AccessRule.html">AccessRule</a></li><li><a href="AppModel.html">AppModel</a></li><li><a href="Citation.html">Citation</a></li><li><a href="CollectionModel.html">CollectionModel</a></li><li><a href="DataONEObject.html">DataONEObject</a></li><li><a href="LookupModel.html">LookupModel</a></li><li><a href="Map.html">Map</a></li><li><a href="Metrics.html">Metrics</a></li><li><a href="QualityCheck.html">QualityCheck</a></li><li><a href="Search.html">Search</a></li><li><a href="SolrResult.html">SolrResult</a></li><li><a href="Stats.html">Stats</a></li><li class='category-heading' data-category='Models/Bookkeeper'>Models/Bookkeeper</li><li><a href="Quota.html">Quota</a></li><li><a href="Subscription.html">Subscription</a></li><li><a href="Usage.html">Usage</a></li><li class='category-heading' data-category='Models/Filters'>Models/Filters</li><li><a href="BooleanFilter.html">BooleanFilter</a></li><li><a href="ChoiceFilter.html">ChoiceFilter</a></li><li><a href="DateFilter.html">DateFilter</a></li><li><a href="Filter.html">Filter</a></li><li><a href="FilterGroup.html">FilterGroup</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="SpatialFilter.html">SpatialFilter</a></li><li><a href="ToggleFilter.html">ToggleFilter</a></li><li class='category-heading' data-category='Models/Formats'>Models/Formats</li><li><a href="ObjectFormat.html">ObjectFormat</a></li><li class='category-heading' data-category='Models/Metadata'>Models/Metadata</li><li><a href="ScienceMetadata.html">ScienceMetadata</a></li><li class='category-heading' data-category='Models/Metadata/EML211'>Models/Metadata/EML211</li><li><a href="EML211.html">EML211</a></li><li><a href="EMLAttribute.html">EMLAttribute</a></li><li><a href="EMLDataTable.html">EMLDataTable</a></li><li><a href="EMLEntity.html">EMLEntity</a></li><li><a href="EMLGeoCoverage.html">EMLGeoCoverage</a></li><li><a href="EMLMeasurementScale.html">EMLMeasurementScale</a></li><li><a href="EMLNonNumericDomain.html">EMLNonNumericDomain</a></li><li><a href="EMLNumericDomain.html">EMLNumericDomain</a></li><li><a href="EMLOtherEntity.html">EMLOtherEntity</a></li><li><a href="EMLParty.html">EMLParty</a></li><li><a href="EMLTemporalCoverage.html">EMLTemporalCoverage</a></li><li><a href="EMLUnit.html">EMLUnit</a></li><li class='category-heading' data-category='Models/Metadata/EML220'>Models/Metadata/EML220</li><li><a href="EMLText.html">EMLText</a></li><li class='category-heading' data-category='Models/Portals'>Models/Portals</li><li><a href="PortalImage.html">PortalImage</a></li><li><a href="PortalModel.html">PortalModel</a></li><li><a href="PortalSectionModel.html">PortalSectionModel</a></li><li class='category-heading' data-category='Models/QueryFields'>Models/QueryFields</li><li><a href="QueryField.html">QueryField</a></li><li class='category-heading' data-category='Router'>Router</li><li><a href="UIRouter.html">UIRouter</a></li><li class='category-heading' data-category='Views'>Views</li><li><a href="AccessPolicyView.html">AccessPolicyView</a></li><li><a href="AccessRuleView.html">AccessRuleView</a></li><li><a href="AppView.html">AppView</a></li><li><a href="CitationListView.html">CitationListView</a></li><li><a href="ColorPaletteView.html">ColorPaletteView</a></li><li><a href="DataCatalogViewWithFilters.html">DataCatalogViewWithFilters</a></li><li><a href="DataItemView.html">DataItemView</a></li><li><a href="DataPackageView.html">DataPackageView</a></li><li><a href="DraftsView.html">DraftsView</a></li><li><a href="EditCollectionView.html">EditCollectionView</a></li><li><a href="EditorView.html">EditorView</a></li><li><a href="GroupListView.html">GroupListView</a></li><li><a href="ImageUploaderView.html">ImageUploaderView</a></li><li><a href="MarkdownEditorView.html">MarkdownEditorView</a></li><li><a href="MarkdownView.html">MarkdownView</a></li><li><a href="MdqRunView.html">MdqRunView</a></li><li><a href="MetadataView.html">MetadataView</a></li><li><a href="MetricModalView.html">MetricModalView</a></li><li><a href="MetricsChartView.html">MetricsChartView</a></li><li><a href="MetricView.html">MetricView</a></li><li><a href="NavbarView.html">NavbarView</a></li><li><a href="RegisterCitationView.html">RegisterCitationView</a></li><li><a href="SignInView.html">SignInView</a></li><li><a href="TableEditorView.html">TableEditorView</a></li><li><a href="TOCView.html">TOCView</a></li><li><a href="UserView.html">UserView</a></li><li class='category-heading' data-category='Views/Filters'>Views/Filters</li><li><a href="BooleanFilterView.html">BooleanFilterView</a></li><li><a href="ChoiceFilterView.html">ChoiceFilterView</a></li><li><a href="DateFilterView.html">DateFilterView</a></li><li><a href="FilterGroupsView.html">FilterGroupsView</a></li><li><a href="FilterGroupView.html">FilterGroupView</a></li><li><a href="FilterView.html">FilterView</a></li><li><a href="NumericFilterView.html">NumericFilterView</a></li><li><a href="ToggleFilterView.html">ToggleFilterView</a></li><li class='category-heading' data-category='Views/Metadata'>Views/Metadata</li><li><a href="EML211EditorView.html">EML211EditorView</a></li><li><a href="EMLAttributeView.html">EMLAttributeView</a></li><li><a href="EMLEntityView.html">EMLEntityView</a></li><li><a href="EMlGeoCoverageView.html">EMlGeoCoverageView</a></li><li><a href="EMLMeasurementScaleView.html">EMLMeasurementScaleView</a></li><li><a href="EMLMethodsView.html">EMLMethodsView</a></li><li><a href="EMLOtherEntityView.html">EMLOtherEntityView</a></li><li><a href="EMLPartyView.html">EMLPartyView</a></li><li><a href="EMLTempCoverageView.html">EMLTempCoverageView</a></li><li><a href="EMLView.html">EMLView</a></li><li><a href="ScienceMetadataView.html">ScienceMetadataView</a></li><li class='category-heading' data-category='Views/Portals'>Views/Portals</li><li><a href="PortalDataView.html">PortalDataView</a></li><li><a href="PortalHeaderView.html">PortalHeaderView</a></li><li><a href="PortalListView.html">PortalListView</a></li><li><a href="PortalLogosView.html">PortalLogosView</a></li><li><a href="PortalMembersView.html">PortalMembersView</a></li><li><a href="PortalSectionView.html">PortalSectionView</a></li><li><a href="PortalUsagesView.html">PortalUsagesView</a></li><li><a href="PortalView.html">PortalView</a></li><li><a href="PortalVisualizationsView.html">PortalVisualizationsView</a></li><li class='category-heading' data-category='Views/Portals/Editor'>Views/Portals/Editor</li><li><a href="PortalEditorView.html">PortalEditorView</a></li><li><a href="PortEditorDataView.html">PortEditorDataView</a></li><li><a href="PortEditorImageView.html">PortEditorImageView</a></li><li><a href="PortEditorLogosView.html">PortEditorLogosView</a></li><li><a href="PortEditorMdSectionView.html">PortEditorMdSectionView</a></li><li><a href="PortEditorSectionsView.html">PortEditorSectionsView</a></li><li><a href="PortEditorSectionView.html">PortEditorSectionView</a></li><li><a href="PortEditorSettingsView.html">PortEditorSettingsView</a></li><li class='category-heading' data-category='Views/QueryBuilder'>Views/QueryBuilder</li><li><a href="QueryBuilderView.html">QueryBuilderView</a></li><li><a href="QueryRuleView.html">QueryRuleView</a></li><li class='category-heading' data-category='Views/SearchSelect'>Views/SearchSelect</li><li><a href="AccountSelectView.html">AccountSelectView</a></li><li><a href="AnnotationFilter.html">AnnotationFilter</a></li><li><a href="NodeSelect.html">NodeSelect</a></li><li><a href="ObjectFormatSelect.html">ObjectFormatSelect</a></li><li><a href="QueryFieldSelectView.html">QueryFieldSelectView</a></li><li><a href="SearchableSelectView.html">SearchableSelectView</a></li><li class='category-heading' data-category='Deprecated'>Deprecated</li><li><a href="ExternalView.html">ExternalView</a></li><li><a href="LogsSearch.html">LogsSearch</a></li></ul><h3>Global</h3><ul><li><a href="global.html#appConfigPath">appConfigPath</a></li></ul>
</nav>

<div id="main">

    <h1 class="page-title">Source: src/js/models/portals/PortalModel.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @exports PortalModel
 */
/* global define */
define(["jquery",
        "underscore",
        "backbone",
        "gmaps",
        "uuid",
        "collections/Filters",
        "collections/SolrResults",
        "models/filters/Filter",
        "models/portals/PortalSectionModel",
        "models/portals/PortalVizSectionModel",
        "models/portals/PortalImage",
        "models/metadata/eml211/EMLParty",
        "models/metadata/eml220/EMLText",
        "models/CollectionModel",
        "models/Search",
        "models/filters/FilterGroup",
        "models/Map"
    ],
    function($, _, Backbone, gmaps, uuid, Filters, SolrResults, FilterModel, PortalSectionModel, PortalVizSectionModel, PortalImage,
        EMLParty, EMLText, CollectionModel, SearchModel, FilterGroup, MapModel) {
        /**
         * @classdesc A PortalModel is a specialized collection that represents a portal,
         * including the associated data, people, portal descriptions, results and
         * visualizations.  It also includes settings for customized filtering of the
         * associated data, and properties used to customized the map display and the
         * overall branding of the portal.
         *
         * @class PortalModel
         * @classcategory Models/Portals
         * @extends CollectionModel
         * @module models/PortalModel
         * @name PortalModel
         * @constructor
        */
        var PortalModel = CollectionModel.extend(
            /** @lends PortalModel.prototype */{

            /**
            * The name of this type of model
            * @type {string}
            */
            type: "Portal",

            /**
             * Overrides the default Backbone.Model.defaults() function to
             * specify default attributes for the portal model
            * @type {object}
            */
            defaults: function() {
                return _.extend(CollectionModel.prototype.defaults(), {
                    id: null,
                    objectXML: null,
                    formatId: "https://purl.dataone.org/portals-1.0.0",
                    formatType: "METADATA",
                    type: "portal",
                    //Is true if the last fetch was sent with user credentials. False if not.
                    fetchedWithAuth: null,
                    logo: null,
                    sections: [],
                    associatedParties: [],
                    acknowledgments: null,
                    acknowledgmentsLogos: [],
                    awards: [],
                    checkedNodeLabels: false,
                    labelDoubleChecked: false,
                    literatureCited: [],
                    filterGroups: [],
                    createSeriesId: true, //If true, a seriesId will be created when this object is saved.
                    // The portal document options may specify section to hide
                    hideMetrics: null,
                    hideData: null,
                    hideMembers: null,
                    hideMap: null,
                    // List of section labels indicating the order in which to display the sections.
                    // Labels must exactly match the labels set on sections, or the values set on the
                    // metricsLabel, dataLabel, and membersLabel options.
                    pageOrder: null,
                    //Options for the custom section labels
                    //NOTE: This are not fully supported yet.
                    metricsLabel: "Metrics",
                    dataLabel: "Data",
                    membersLabel: "Members",
                    // Map options, as specified in the portal document options
                    mapZoomLevel: 3,
                    mapCenterLatitude: null,
                    mapCenterLongitude: null,
                    mapShapeHue: 200,
                    // The MapModel
                    mapModel: gmaps ? new MapModel() : null,
                    optionNames: ["primaryColor", "secondaryColor", "accentColor",
                            "mapZoomLevel", "mapCenterLatitude", "mapCenterLongitude",
                            "mapShapeHue", "hideData", "hideMetrics", "hideMembers", "pageOrder"],
                    // Portal view colors, as specified in the portal document options
                    primaryColor: MetacatUI.appModel.get("portalDefaults").primaryColor || "#006699",
                    secondaryColor: MetacatUI.appModel.get("portalDefaults").secondaryColor || "#009299",
                    accentColor: MetacatUI.appModel.get("portalDefaults").accentColor || "#f89406",
                    primaryColorRGB: null,
                    secondaryColorRGB: null,
                    accentColorRGB: null,
                    primaryColorTransparent: MetacatUI.appModel.get("portalDefaults").primaryColorTransparent || "rgba(0, 102, 153, .7)",
                    secondaryColorTransparent: MetacatUI.appModel.get("portalDefaults").secondaryColorTransparent || "rgba(0, 146, 153, .7)",
                    accentColorTransparent: MetacatUI.appModel.get("portalDefaults").accentColorTransparent || "rgba(248, 148, 6, .7)"
                });
            },

            /**
             * The default text to use for a new section label added by the user
             * @type {string}
            */
            newSectionLabel: "Untitled",

            /**
             * Overrides the default Backbone.Model.initialize() function to
             * provide some custom initialize options
             *
             * @param {} options -
            */
            initialize: function(attrs) {

              //Call the super class initialize function
              CollectionModel.prototype.initialize.call(this, attrs);

              // Generate transparent colours from the primary, secondary, and accent colors
              // TODO

              if( attrs.isNew ){
                this.set("synced", true);
                //Create an isPartOf filter for this new Portal
                this.addIsPartOfFilter();

                var model = this;

                // Insert new sections if any are set in the appModel

                var portalDefaults = MetacatUI.appModel.get("portalDefaults"),
                    defaultSections = portalDefaults ? portalDefaults.sections : [];

                if(defaultSections &amp;&amp; defaultSections.length &amp;&amp; Array.isArray(defaultSections)){
                  defaultSections.forEach(function(section, index){
                    // If there is at least one section default set...
                    if(section.title || section.label){
                      var newDefaultSection = new PortalSectionModel({
                        title: section.title || "",
                        label: section.label || this.newSectionLabel,
                        // Set a default image on new markdown sections
                        image: model.getRandomSectionImage(),
                        portalModel: model
                      });
                      model.addSection(newDefaultSection);
                    }
                  });
                }
              }

              // check for info received from Bookkeeper
              if( MetacatUI.appModel.get("enableBookkeeperServices") ){

                this.listenTo( MetacatUI.appUserModel, "change:dataoneSubscription", function(){
                  if(MetacatUI.appUserModel.get("dataoneSubscription").isTrialing()) {
                    this.setRandomLabel();
                  }
                });

                //Fetch the user subscription info
                MetacatUI.appUserModel.fetchSubscription();
              }

              // Cache this model for later use
              this.cachePortal();

            },

            /**
             * getRandomSectionImage - Using the list of image identifiers set
             * in the app config, select an image to use for a portal section.
             * The function will not return the same image until all the images
             * have been returned at least once. If an image would return a 404
             * error, it is skipped. If all images give 404s, an empty string
             * is returned.
             *
             * @return {PortalImage}  A portal image model to use in a section model
             */
            getRandomSectionImage: function(){

              // This variable will hold the section image to return, if any
              var newSectionImage = "",
                  // The default portal values set in the config
                  portalDefaults = MetacatUI.appModel.get("portalDefaults"),
                  // Check if default images are set on the model already
                  defaultImageIds = this.get("defaultSectionImageIds"),
                  // Keep track of where we are in the list of default images,
                  // so there's not too much repetition
                  runningNumber = this.get("defaultImageRunningNumber") || 0;

              // If none are set, get the configured default image IDs,
              // shuffle them, and set them on the model.
              if(!defaultImageIds || !defaultImageIds.length){

                // Get the list of default section image IDs from the appModel
                defaultImageIds = portalDefaults ? portalDefaults.sectionImageIdentifiers : false;

                // If some are configured...
                if(defaultImageIds &amp;&amp; defaultImageIds.length){
                  // ...Shuffle the images...
                  for (let i = defaultImageIds.length - 1; i > 0; i--) {
                    let j = Math.floor(Math.random() * (i + 1));
                    [defaultImageIds[i], defaultImageIds[j]] = [defaultImageIds[j], defaultImageIds[i]];
                  }
                  // ... and save the shuffled list to the portal model
                  this.set("defaultSectionImageIds", defaultImageIds);
                }
              }

              // Can't get a random image if none are configured
              if(!defaultImageIds){
                console.log("Can't set a default image on new markdown sections because there are no default image IDs set. Check portalDefaults.sectionImageIdentifiers in the config file.");
                return
              }

              // Select one of the image IDs
              if(defaultImageIds &amp;&amp; defaultImageIds.length > 0){

                if(runningNumber >= defaultImageIds.length){
                  runningNumber = 0
                }

                // Go through the shuffled array of image IDs in order
                for (i = runningNumber; i &lt; defaultImageIds.length; i++) {

                  // Skip images that have already returned 404 errors
                  if(defaultImageIds[i] == "NOT FOUND"){
                    continue;
                  }

                  // Section images are PortalImage models
                  var newSectionImage = new PortalImage({
                    identifier: defaultImageIds[i],
                    portalModel: this.get("portalModel")
                  });

                  // Skip adding an image if it doesn't exist given the identifer and baseUrl found in the image model
                  if(newSectionImage.imageExists()){
                    break;
                  // If the image doesn't exist, mark it so we don't have to
                  // check again next time
                  } else {
                    defaultImageIds[i] = "NOT FOUND";
                    newSectionImage = "";
                  }
                }
              }

              this.set("defaultImageRunningNumber", i + 1);
              this.set("defaultSectionImageIds", defaultImageIds);

              return newSectionImage
            },

            /**
             * Returns the portal URL
             *
             * @return {string} The portal URL
            */
            url: function() {

              //Start the base URL string
              // use the resolve service if there is no object service url
              // (e.g. in DataONE theme)
              var urlBase = MetacatUI.appModel.get("objectServiceUrl") ||
                MetacatUI.appModel.get("resolveServiceUrl");

              //Get the active alternative repository, if one is configured
              var activeAltRepo = MetacatUI.appModel.getActiveAltRepo();

              if( activeAltRepo ){
                urlBase = activeAltRepo.objectServiceUrl;
              }

              //If this object is being updated, use the old pid in the URL
              if ( !this.isNew() &amp;&amp; this.get("oldPid") ) {
                return urlBase +
                    encodeURIComponent(this.get("oldPid"));
              }
              //If this object is new, use the new pid in the URL
              else {
                return urlBase +
                    encodeURIComponent(this.get("seriesId") || this.get("id"));
              }
            },

            /**
             * Overrides the default Backbone.Model.fetch() function to provide some custom
             * fetch options
             * @param [options] {object} - Options for this fetch
             * @property [options.objectOnly] {Boolean} - If true, only the object will be retrieved and not the system metadata
             * @property [options.systemMetadataOnly] {Boolean} - If true, only the system metadata will be retrieved
             * @return {XMLDocument} The XMLDocument returned from the fetch() AJAX call
            */
            fetch: function(options) {

              if ( ! options ) var options = {};
              else var options = _.clone(options);

              //If the seriesId has not been found yet, get it from Solr
              if( !this.get("id") &amp;&amp; !this.get("seriesId") &amp;&amp; this.get("label") ){

                this.once("change:seriesId", function(){
                  this.fetch(options)
                });
                this.once("latestVersionFound", function(){
                  this.fetch(options)
                });

                //Get the series ID of this object
                this.getSeriesIdByLabel();

                return;
              }
              //If we found the latest version in this pid version chain,
              else if( this.get("id") &amp;&amp; this.get("latestVersion") ){
                //Set it as the id of this model
                this.set("id", this.get("latestVersion"));

                //Stop listening to the change of seriesId and the latest version found
                this.stopListening("change:seriesId", this.fetch);
                this.stopListening("latestVersionFound", this.fetch);
              }

              //If this MetacatUI instance is pointing to a CN, use the origin MN
              // to fetch the Portal, if available as an alt repo.
              if( MetacatUI.appModel.get("isCN") &amp;&amp; this.get("datasource") ){
                //Check if the origin MN (datasource) is an alt repo option
                var altRepo = _.findWhere(MetacatUI.appModel.get("alternateRepositories"), { identifier: this.get("datasource") });

                if( altRepo ){
                  //Set the origin MN (datasource) as the active alt repo
                  MetacatUI.appModel.set("activeAlternateRepositoryId", this.get("datasource"));
                }

              }

              //Fetch the system metadata
              if( !options.objectOnly || options.systemMetadataOnly ){
                this.fetchSystemMetadata();

                if( options.systemMetadataOnly ){
                  return;
                }
              }

              var requestSettings = {
                  dataType: "xml",
                  error: function(model, response) {

                      model.trigger("error", model, response);

                      if( response &amp;&amp; response.status == 404 ){
                        model.trigger("notFound");
                      }
                  }
              };

              //Save a boolean flag for whether or not this fetch was done with user authentication.
              //This is helpful when the app is dealing with potentially private data
              this.set("fetchedWithAuth", MetacatUI.appUserModel.get("loggedIn"));

              // Add the user settings to the fetch settings
              requestSettings = _.extend(requestSettings, MetacatUI.appUserModel.createAjaxSettings());

              // Call Backbone.Model.fetch()
              return Backbone.Model.prototype.fetch.call(this, requestSettings);

            },

            /**
            * Get the portal seriesId by searching for the portal by its label in Solr
            */
            getSeriesIdByLabel: function(){

              //Exit if there is no portal name set
              if( !this.get("label") )
                return;

              var model = this;

              //Start the base URL for the query service
              var baseUrl = "";

              try{
                //If this app instance is pointing to the CN, find the Portal series ID on the MN
                if( MetacatUI.appModel.get("alternateRepositories").length ){

                  //Get the array of possible authoritative MNs
                  var possibleAuthMNs = this.get("possibleAuthMNs");

                  //If there are no possible authoritative MNs, use the CN query service
                  if( !possibleAuthMNs.length ){
                    baseUrl = MetacatUI.appModel.get("queryServiceUrl");
                  }
                  else{
                    baseUrl = possibleAuthMNs[0].queryServiceUrl;
                  }

                }
                else{
                  //Get the query service URL
                  baseUrl = MetacatUI.appModel.get("queryServiceUrl");
                }
              }
              catch(e){
                console.error("Error in trying to determine the query service URL. Going to try to use the AppModel setting. ", e);
              }
              finally{
                //Default to the query service URL configured in the AppModel, if one wasn't set earlier
                if( !baseUrl ){
                  baseUrl = MetacatUI.appModel.get("queryServiceUrl");
                  //If there isn't a query service URL, trigger a "not found" error and exit
                  if( !baseUrl ){
                    this.trigger("notFound");
                    return;
                  }
                }
              }

              var requestSettings = {
                  url: baseUrl +
                       "q=label:\"" + this.get("label") + "\" OR " +
                       "seriesId:\"" + this.get("label") + "\"" +
                       "&amp;fl=seriesId,id,label,datasource" +
                       "&amp;sort=dateUploaded%20asc" +
                       "&amp;rows=1" +
                       "&amp;wt=json",
                  dataType: "json",
                  error: function(response) {
                      model.trigger("error", model, response);

                      if( response.status == 404 ){
                        model.trigger("notFound");
                      }
                  },
                  success: function(response){
                    if( response.response.numFound > 0 ){

                      //Set the label and datasource
                      model.set("label", response.response.docs[0].label);
                      model.set("datasource", response.response.docs[0].datasource);

                      //Save the seriesId, if one is found
                      if( response.response.docs[0].seriesId ){
                        model.set("seriesId", response.response.docs[0].seriesId);
                      }
                      //If this portal doesn't have a seriesId,
                      //but id has been found
                      else if ( response.response.docs[0].id ){
                        //Save the id
                        model.set("id", response.response.docs[0].id);

                        //Find the latest version in this version chain
                        model.findLatestVersion(response.response.docs[0].id);
                      }
                      // if we don't have Id or SeriesId
                      else {
                        model.trigger("notFound");
                      }

                    }
                    else{

                      var possibleAuthMNs = model.get("possibleAuthMNs");
                      if( possibleAuthMNs.length ){
                        //Remove the first MN from the array, since it didn't contain the Portal, so it's not the auth MN
                        possibleAuthMNs.shift();
                      }

                      //If there are no other possible auth MNs to check, trigger this Portal as Not Found.
                      if( possibleAuthMNs.length == 0 || !possibleAuthMNs ){
                        model.trigger("notFound");
                      }
                      //If there's more MNs to check, try again
                      else{
                        model.getSeriesIdByLabel();
                      }

                    }
                  }
              }

              //Save a boolean flag for whether or not this fetch was done with user authentication.
              //This is helpful when the app is dealing with potentially private data
              this.set("fetchedWithAuth", MetacatUI.appUserModel.get("loggedIn"));

              requestSettings = _.extend(requestSettings, MetacatUI.appUserModel.createAjaxSettings());

              $.ajax(requestSettings);

            },

            /**
            * This function has been renamed `getSeriesIdByLabel` and may be removed in future releases.
            * @deprecated This function has been renamed `getSeriesIdByLabel` and may be removed in future releases.
            * @see PortalModel#getSeriesIdByLabel
            */
            getSeriesIdByName: function(){ this.getSeriesIdByLabel() },

            /**
             * Overrides the default Backbone.Model.parse() function to parse the custom
             * portal XML document
             *
             * @param {XMLDocument} response - The XMLDocument returned from the fetch() AJAX call
             * @return {JSON} The result of the parsed XML, in JSON. To be set directly on the model.
            */
            parse: function(response) {

                //Start the empty JSON object
                var modelJSON = {},
                    modelRef = this,
                    portalNode;

                // Iterate over each root XML node to find the portal node
                $(response).children().each(function(i, el) {
                    if (el.tagName.indexOf("portal") > -1) {
                        portalNode = el;
                        return false;
                    }
                });

                // If a portal XML node wasn't found, return an empty JSON object
                if (typeof portalNode == "undefined" || !portalNode) {
                    return {};
                }

                // Parse the collection elements
                modelJSON = this.parseCollectionXML(portalNode);

                // Save the xml for serialize
                modelJSON.objectXML = response;

                // Parse the portal logo
                var portLogo = $(portalNode).children("logo")[0];
                if (portLogo) {
                  var portImageModel = new PortalImage({
                    objectDOM: portLogo,
                    portalModel: this
                  });
                  portImageModel.set(portImageModel.parse());
                  modelJSON.logo = portImageModel
                };

                // Parse acknowledgement logos into urls
                var logos = $(portalNode).children("acknowledgmentsLogo");
                modelJSON.acknowledgmentsLogos = [];
                _.each(logos, function(logo, i) {
                    if ( !logo ) return;

                    var imageModel = new PortalImage({
                      objectDOM: logo,
                      portalModel: this
                    });
                    imageModel.set(imageModel.parse());

                    if( imageModel.get("imageURL") ){
                      modelJSON.acknowledgmentsLogos.push( imageModel );
                    }
                }, this);

                // Parse the literature cited
                // This will only work for bibtex at the moment
                var bibtex = $(portalNode).children("literatureCited").children("bibtex");
                if (bibtex.length > 0) {
                    modelJSON.literatureCited = this.parseTextNode(portalNode, "literatureCited");
                }

                // Parse the portal content sections
                modelJSON.sections = [];
                $(portalNode).children("section").each(function(i, section){

                  //Get the section type, if there is one
                  var sectionTypeNode = $(section).find("optionName:contains(sectionType)"),
                      sectionType = "";

                  if( sectionTypeNode.length ){
                    var optionValueNode = sectionTypeNode.first().siblings("optionValue");
                    if( optionValueNode.length ){
                      sectionType = optionValueNode[0].textContent;
                    }
                  }

                  if( sectionType == "visualization" ){
                    // Create a new PortalVizSectionModel
                    modelJSON.sections.push( new PortalVizSectionModel({
                      objectDOM: section,
                      literatureCited: modelJSON.literatureCited
                    }) );
                  }
                  else{
                    // Create a new PortalSectionModel
                    modelJSON.sections.push( new PortalSectionModel({
                      objectDOM: section,
                      literatureCited: modelJSON.literatureCited,
                      portalModel: modelRef
                    }) );
                  }

                  //Parse the PortalSectionModel
                  modelJSON.sections[i].set( modelJSON.sections[i].parse(section) );
                });

                // Parse the EMLText elements
                modelJSON.acknowledgments = this.parseEMLTextNode(portalNode, "acknowledgments");

                // Parse the awards
                modelJSON.awards = [];
                var parse_it = this.parseTextNode;
                $(portalNode).children("award").each(function(i, award) {
                    var award_parsed = {};
                    $(award).children().each(function(i, award_attr) {
                        if(award_attr.nodeName != "funderLogo"){
                          // parse the text nodes
                          award_parsed[award_attr.nodeName] = parse_it(award, award_attr.nodeName);
                        } else {
                          // parse funderLogo which is type ImageType
                          var imageModel = new PortalImage({ objectDOM: award_attr });
                          imageModel.set(imageModel.parse());
                          award_parsed[award_attr.nodeName] = imageModel;
                        }
                    });
                    modelJSON.awards.push(award_parsed);
                });

                // Parse the associatedParties
                modelJSON.associatedParties = [];
                $(portalNode).children("associatedParty").each(function(i, associatedParty) {

                    modelJSON.associatedParties.push(new EMLParty({
                        objectDOM: associatedParty
                    }));

                });

                // Parse the options
                $(portalNode).find("option").each(function(i, option) {

                    var optionName = $(option).find("optionName")[0].textContent,
                        optionValue = $(option).find("optionValue")[0].textContent;

                    if (optionValue === "true") {
                        optionValue = true;
                    } else if (optionValue === "false") {
                        optionValue = false;
                    }

                    // TODO: keep a list of optionNames so that in the case of
                    // custom options, we can serialize them in serialize()
                    // otherwise it's not saved in the model which attributes
                    // are &lt;option>&lt;/option>s

                    // Convert the comma separated list of pages into an array
                    if(optionName === "pageOrder" &amp;&amp; optionValue &amp;&amp; optionValue.length){
                      optionValue = optionValue.split(',');
                    }

                    if( !_.has(modelJSON, optionName) ){
                      modelJSON[optionName] = optionValue;
                    }

                });

                // Convert all the hex colors to rgb
                if(modelJSON.primaryColor){
                  modelJSON.primaryColorRGB = this.hexToRGB(modelJSON.primaryColor);
                  modelJSON.primaryColorTransparent = "rgba(" +  modelJSON.primaryColorRGB.r +
                    "," + modelJSON.primaryColorRGB.g + "," + modelJSON.primaryColorRGB.b +
                    ", .7)";
                }
                if(modelJSON.secondaryColor){
                  modelJSON.secondaryColorRGB = this.hexToRGB(modelJSON.secondaryColor);
                  modelJSON.secondaryColorTransparent = "rgba(" +  modelJSON.secondaryColorRGB.r +
                    "," + modelJSON.secondaryColorRGB.g + "," + modelJSON.secondaryColorRGB.b +
                    ", .5)";
                }
                if(modelJSON.accentColor){
                  modelJSON.accentColorRGB = this.hexToRGB(modelJSON.accentColor);
                  modelJSON.accentColorTransparent = "rgba(" +  modelJSON.accentColorRGB.r +
                    "," + modelJSON.accentColorRGB.g + "," + modelJSON.accentColorRGB.b +
                    ", .5)";
                }

                if (gmaps) {
                    // Create a MapModel with all the map options
                    modelJSON.mapModel = new MapModel();
                    var mapOptions = modelJSON.mapModel.get("mapOptions");

                    if (modelJSON.mapZoomLevel) {
                        mapOptions.zoom = parseInt(modelJSON.mapZoomLevel);
                        mapOptions.minZoom = parseInt(modelJSON.mapZoomLevel);
                    }
                    if ((modelJSON.mapCenterLatitude || modelJSON.mapCenterLatitude === 0) &amp;&amp;
                        (modelJSON.mapCenterLongitude || modelJSON.mapCenterLongitude === 0)) {
                        mapOptions.center = modelJSON.mapModel.createLatLng(modelJSON.mapCenterLatitude, modelJSON.mapCenterLongitude);
                    }
                    if (modelJSON.mapShapeHue) {
                        modelJSON.mapModel.set("tileHue", modelJSON.mapShapeHue);
                    }
                }

                // Parse the FilterGroups
                modelJSON.filterGroups = [];
                var allFilters = modelJSON.searchModel.get("filters");
                $(portalNode).find("filterGroup").each(function(i, filterGroup) {

                  // Create a FilterGroup model
                  var filterGroupModel = new FilterGroup({
                      objectDOM: filterGroup
                  });
                  modelJSON.filterGroups.push(filterGroupModel);

                  // Add the Filters from this FilterGroup to the portal's Search model
                  allFilters.add(filterGroupModel.get("filters").models);

                });
                return modelJSON;
            },

            /**
             * Parses the XML nodes that are of type EMLText
             *
             * @param {Element} parentNode - The XML Element that contains all the EMLText nodes
             * @param {string} nodeName - The name of the XML node to parse
             * @param {boolean} isMultiple - If true, parses the nodes into an array
             * @return {(string|Array)} A string or array of strings comprising the text content
            */
            parseEMLTextNode: function(parentNode, nodeName, isMultiple) {

                var node = $(parentNode).children(nodeName);

                // If no matching nodes were found, return falsey values
                if (!node || !node.length) {

                    // Return an empty array if the isMultiple flag is true
                    if (isMultiple)
                        return [];
                    // Return null if the isMultiple flag is false
                    else
                        return null;
                }
                // If exactly one node is found and we are only expecting one, return the text content
                else if (node.length == 1 &amp;&amp; !isMultiple) {
                    return new EMLText({
                        objectDOM: node[0]
                    });
                } else {
                // If more than one node is found, parse into an array
                    return _.map(node, function(node) {
                        return new EMLText({
                            objectDOM: node
                        });
                    });

                }

            },

            /**
            * Sets the fileName attribute on this model using the portal label
            * @override
            */
            setMissingFileName: function(){

              var fileName = this.get("label");

              if( !fileName ){
                fileName = "portal.xml";
              }
              else{
                fileName = fileName.replace(/[^a-zA-Z0-9]/g, "_") + ".xml";
              }

              this.set("fileName", fileName);

            },

            /**
             * @typedef {Object} PortalModel#rgb - An RGB color value
             * @property {number} r - A value between 0 and 255 defining the intensity of red
             * @property {number} g - A value between 0 and 255 defining the intensity of green
             * @property {number} b - A value between 0 and 255 defining the intensity of blue
            */

            /**
             * Converts hex color values to RGB
             *
             * @param {string} hex - a color in hexadecimal format
             * @return {rgb} a color in RGB format
            */
            hexToRGB: function(hex){
              var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
              return result ? {
                  r: parseInt(result[1], 16),
                  g: parseInt(result[2], 16),
                  b: parseInt(result[3], 16)
              } : null;
              },

            /**
             * Finds the node in the given portal XML document afterwhich the
             * given node type should be inserted
             *
             * @param {Element} portalNode - The portal element of an XML document
             * @param {string} nodeName - The name of the node to be inserted
             *                             into xml
             * @return {(jQuery|boolean)} A jQuery object indicating a position,
             *                            or false when nodeName is not in the
             *                            portal schema
            */
            getXMLPosition: function(portalNode, nodeName){

              var nodeOrder = [ "label", "name", "description", "definition",
                                "logo", "section", "associatedParty",
                                "acknowledgments", "acknowledgmentsLogo",
                                "award", "literatureCited", "filterGroup",
                                "option"];

              var position = _.indexOf(nodeOrder, nodeName);

              // First check that nodeName is in the list of nodes
              if ( position == -1 ) {
                  return false;
              };

              // If there's already an occurence of nodeName...
              if($(portalNode).children(nodeName).length > 0){
                // ...insert it after the last occurence
                return $(portalNode).children(nodeName).last();
              } else {
                // Go through each node in the node list and find the position
                // after which this node will be inserted
                for (var i = position - 1; i >= 0; i--) {
                  if ( $(portalNode).children(nodeOrder[i]).length ) {
                    return $(portalNode).children(nodeOrder[i]).last();
                  }
                }
              }

              return false;
            },

            /**
             * Retrieves the model attributes and serializes into portal XML,
             * to produce the new or modified portal document.
             *
             * @return {string} - Returns the portal XML as a string.
            */
            serialize: function(){

              try{

                // So we can call getXMLPosition() from within if{}
                var model = this;

                var xmlDoc,
                    portalNode,
                    xmlString;

                xmlDoc = this.get("objectXML");

                // Check if there is a portal doc already
                if (xmlDoc == null){
                  // If not create one
                  xmlDoc = this.createXML();
                } else {
                  // If yes, clone it
                  xmlDoc = xmlDoc.cloneNode(true);
                };

                // Iterate over each root XML node to find the portal node
                $(xmlDoc).children().each(function(i, el) {
                    if (el.tagName.indexOf("portal") > -1) {
                        portalNode = el;
                    }
                });

                // Serialize the collection elements
                // ("name", "label", "description", "definition")
                portalNode = this.updateCollectionDOM(portalNode);
                var $portalNode = $(portalNode);

                /* ==== Serialize portal logo ==== */

                // Remove node if it exists already
                $(xmlDoc).find("logo").remove();

                // Get new values
                var logo = this.get("logo");

                // Don't serialize falsey values or empty logos
                if(logo &amp;&amp; logo.get("identifier")){

                  // Make new node
                  var logoSerialized = logo.updateDOM("logo");

                  //Add the logo node to the XMLDocument
                  xmlDoc.adoptNode(logoSerialized);

                  // Insert new node at correct position
                  var insertAfter = this.getXMLPosition(portalNode, "logo");
                  if(insertAfter){
                    insertAfter.after(logoSerialized);
                  }
                  else{
                    portalNode.appendChild(logoSerialized);
                  }

                };

                /* ==== Serialize acknowledgment logos ==== */

                // Remove element if it exists already
                $(xmlDoc).find("acknowledgmentsLogo").remove();

                var acknowledgmentsLogos = this.get("acknowledgmentsLogos");

                // Don't serialize falsey values
                if(acknowledgmentsLogos){

                  _.each(acknowledgmentsLogos, function(imageModel) {

                    // Don't serialize empty imageModels
                    if(
                      imageModel.get("identifier") ||
                      imageModel.get("label") ||
                      imageModel.get("associatedURL")
                    ){

                      var ackLogosSerialized = imageModel.updateDOM();

                      //Add the logo node to the XMLDocument
                      xmlDoc.adoptNode(ackLogosSerialized);

                      // Insert new node at correct position
                      var insertAfter = model.getXMLPosition(portalNode, "acknowledgmentsLogo");
                      if(insertAfter){
                        insertAfter.after(ackLogosSerialized);
                      }
                      else {
                        portalNode.appendChild(ackLogosSerialized);
                      }
                    }
                  })
                };

                /* ==== Serialize literature cited ==== */
                // Assumes the value of literatureCited is a block of bibtex text

                // Remove node if it exists already
                $(xmlDoc).find("literatureCited").remove();

                // Get new values
                var litCit = this.get("literatureCited");

                // Don't serialize falsey values
                if( litCit.length ){

                  // If there's only one element in litCited, it will be a string
                  // turn it into an array so that we can use _.each
                  if(typeof litCit == "string"){
                    litCit = [litCit]
                  }

                  // Make new &lt;literatureCited> element
                  var litCitSerialized = xmlDoc.createElement("literatureCited");

                  _.each(litCit, function(bibtex){

                    // Wrap in literature cited in cdata tags
                    var cdataLitCit = xmlDoc.createCDATASection(bibtex);
                    var bibtexSerialized = xmlDoc.createElement("bibtex");
                    // wrap in CDATA tags so that bibtex characters aren't escaped
                    bibtexSerialized.appendChild(cdataLitCit);
                    // &lt;bibxtex> is a subelement of &lt;literatureCited>
                    litCitSerialized.appendChild(bibtexSerialized);

                  });

                  // Insert new element at correct position
                  var insertAfter = this.getXMLPosition(portalNode, "literatureCited");
                  if(insertAfter){
                    insertAfter.after(litCitSerialized);
                  }
                  else{
                    portalNode.appendChild(litCitSerialized);
                  }
                }

                /* ==== Serialize portal content sections ==== */

                // Remove node if it exists already
                $portalNode.children("section").remove();

                var sections = this.get("sections");

                // Don't serialize falsey values
                if(sections){

                  _.each(sections, function(sectionModel) {

                    // Don't serialize sections with default values
                    if(!this.sectionIsDefault(sectionModel)){

                      var sectionSerialized = sectionModel.updateDOM();

                      //If there was an error serializing this section, or if
                      // nothing was returned, don't do anythiing further
                      if( !sectionSerialized ){
                        return;
                      }

                      //Add the section node to the XMLDocument
                      xmlDoc.adoptNode(sectionSerialized);

                      // Remove sections entirely if the content is blank
                      var newMD = $(sectionSerialized).find("markdown")[0];
                      if( !newMD || newMD.textContent == "" ){
                        $(sectionSerialized).find("markdown").remove();
                      }

                      // Remove the &lt;content> element if it's empty.
                      // This will trigger a validation error, prompting user to
                      // enter content.
                      if($(sectionSerialized).find("content").is(':empty')){
                        $(sectionSerialized).find("content").remove();
                      }

                      // Insert new node at correct position
                      var insertAfter = model.getXMLPosition(portalNode, "section");
                      if(insertAfter){
                        insertAfter.after(sectionSerialized);
                      }
                      else {
                        portalNode.appendChild(sectionSerialized);
                      }

                    }

                  }, this)
                };

                /* ====  Serialize the EMLText elements ("acknowledgments") ==== */

                var textFields = ["acknowledgments"];

                _.each(textFields, function(field){

                  var fieldName = field;

                  // Get the EMLText model
                  var emlTextModels = Array.isArray(this.get(field)) ? this.get(field) : [this.get(field)];
                  if( ! emlTextModels.length ) return;

                  // Get the node from the XML doc
                  var nodes = $portalNode.children(fieldName);

                  // Update the DOMs for each model
                  _.each(emlTextModels, function(thisTextModel, i){
                    //Don't serialize falsey values
                    if(!thisTextModel) return;

                    var node;

                    //Get the existing node or create a new one
                    if(nodes.length &lt; i+1){
                      node = xmlDoc.createElement(fieldName);
                      this.getXMLPosition(portalNode, fieldName).after(node);
                    }
                    else {
                       node = nodes[i];
                    }

                    var textModelSerialized = thisTextModel.updateDOM();

                    //If the text model wasn't serialized correctly or resulted in nothing
                    if(typeof textModelSerialized == "undefined" || !textModelSerialized){
                      //Remove the existing node
                      $(node).remove();
                    }
                    else{
                      xmlDoc.adoptNode(textModelSerialized);
                      $(node).replaceWith(textModelSerialized);
                    }

                  }, this);

                  // Remove the extra nodes
                  this.removeExtraNodes(nodes, emlTextModels);

                }, this);

                /* ====  Serialize awards ==== */

                // Remove award node if it exists already
                $portalNode.children("award").remove();

                // Get new values
                var awards = this.get("awards");

                // Don't serialize falsey values
                if(awards &amp;&amp; awards.length>0){

                  _.each(awards, function(award){

                    // Make new node
                    var awardSerialized = xmlDoc.createElement("award");

                    // create the &lt;award> subnodes
                    _.map(award, function(value, nodeName){

                      // serialize the simple text nodes
                      if(nodeName != "funderLogo"){
                        // Don't serialize falsey values
                        if(value){
                          // Make new sub-nodes
                          var awardSubnodeSerialized = xmlDoc.createElement(nodeName);
                          $(awardSubnodeSerialized).text(value);
                          $(awardSerialized).append(awardSubnodeSerialized);
                        }
                      } else {
                        // serialize "funderLogo" which is ImageType
                        var funderLogoSerialized = value.updateDOM();
                        xmlDoc.adoptNode(funderLogoSerialized);
                        $(awardSerialized).append(funderLogoSerialized);
                      }

                    });

                    // Insert new node at correct position
                    var insertAfter = model.getXMLPosition(portalNode, "award");
                    if(insertAfter){
                      insertAfter.after(awardSerialized);
                    }
                    else{
                      portalNode.appendChild(awardSerialized);
                    }

                  });

                }

                /* ====  Serialize associatedParties ==== */

                // Remove element if it exists already
                $portalNode.children("associatedParty").remove();

                // Get new values
                var parties = this.get("associatedParties");

                // Don't serialize falsey values
                if(parties){

                  // Serialize each associatedParty
                  _.each(parties, function(party){

                    // Update the DOM of the EMLParty
                    var partyEl  = party.updateDOM();
                        partyDoc = $.parseXML(party.formatXML( $(partyEl)[0] ));

                    // Make sure we don't insert empty EMLParty nodes into the EML
                    if(partyDoc.childNodes.length){
                      //Save a reference to the associated party element in the NodeList
                      var assocPartyEl = partyDoc.childNodes[0];
                      //Add the associated part element to the portal XML doc
                      xmlDoc.adoptNode(assocPartyEl);

                      // Get the last node of this type to insert after
                      var insertAfter = $portalNode.children("associatedParty").last();

                      // If there isn't a node found, find the EML position to insert after
                      if( !insertAfter.length ) {
                        insertAfter = model.getXMLPosition(portalNode, "associatedParty");
                      }

                      //Insert the party DOM at the insert position
                      if ( insertAfter &amp;&amp; insertAfter.length ){
                        insertAfter.after(assocPartyEl);
                      } else {
                        portalNode.appendChild(assocPartyEl);
                      }
                    }
                  });
                }

                try{
                  /* ====  Serialize options (including map options) ==== */
                  // This will only serialize the options named in `optNames` (below)
                  // Functionality needed in order to serialize new or custom options

                  // The standard list of options used in portals
                  var optNames = this.get("optionNames");

                  _.each(optNames, function(optName){

                    //Get the value on the model
                    var optValue = model.get(optName),
                        existingValue;

                    //Get the existing optionName element
                    var matchingOption = $portalNode.children("option")
                                                   .find("optionName:contains('" + optName + "')");

                    //
                    if( !matchingOption.length || matchingOption.first().text() != optName ){
                      matchingOption = false;
                    }
                    else{
                      //Get the value for this option from the Portal doc
                      existingValue = matchingOption.siblings("optionValue").text();
                    }

                    // Don't serialize null or undefined values. Also don't serialize values that match the default model value
                    if( (optValue || optValue === 0 || optValue === false) &amp;&amp;
                        (optValue != model.defaults()[optName]) ){

                      //Replace the existing option, if it exists
                      if( matchingOption ){
                        matchingOption.siblings("optionValue").text(optValue);
                      }
                      else{
                        // Make new node
                        // &lt;optionName> and &lt;optionValue> are subelements of &lt;option>
                        var optionSerialized   = xmlDoc.createElement("option"),
                            optNameSerialized  = xmlDoc.createElement("optionName"),
                            optValueSerialized = xmlDoc.createElement("optionValue");

                        $(optNameSerialized).text(optName);
                        $(optValueSerialized).text(optValue);

                        $(optionSerialized).append(optNameSerialized, optValueSerialized);

                        // Insert new node at correct position
                        var insertAfter = model.getXMLPosition(portalNode, "option");

                        if(insertAfter){
                          insertAfter.after(optionSerialized);
                        }

                      }

                    }
                    else{
                      //Remove the elements from the portal XML when the value is invalid
                      if( matchingOption ){
                        matchingOption.parent("option").remove();
                      }
                    }
                  });
                }
                catch(e){
                  console.error(e);
                }

                /* ====  Serialize FilterGroups ==== */

                // Get new filter group values
                var filterGroups = this.get("filterGroups");

                // Remove any filter groups in the current objectDOM
                $(xmlDoc).find("filterGroup").remove();

                // Make a new node for each filter group in the model
                _.each(filterGroups, function(filterGroup){

                  filterGroupSerialized = filterGroup.updateDOM();

                  //Add the new element to the XMLDocument
                  xmlDoc.adoptNode(filterGroupSerialized);

                  // Insert new node at correct position
                  var insertAfter = model.getXMLPosition(portalNode, "filterGroup");

                  if(insertAfter){
                    insertAfter.after(filterGroupSerialized);
                  }
                  else{
                    portalNode.appendChild(filterGroupSerialized);
                  }
                });

                /* ====  Remove duplicates ==== */

                //Do a final check to make sure there are no duplicate ids in the XML
                var elementsWithIDs = $(xmlDoc).find("[id]"),
                //Get an array of all the ids in this EML doc
                    allIDs = _.map(elementsWithIDs, function(el){ return $(el).attr("id") });

                //If there is at least one id in the EML...
                if(allIDs &amp;&amp; allIDs.length){
                  //Boil the array down to just the unique values
                  var uniqueIDs = _.uniq(allIDs);

                  //If the unique array is shorter than the array of all ids,
                  // then there is a duplicate somewhere
                  if(uniqueIDs.length &lt; allIDs.length){

                    //For each element in the EML that has an id,
                    _.each(elementsWithIDs, function(el){

                      //Get the id for this element
                      var id = $(el).attr("id");

                      //If there is more than one element in the EML with this id,
                      if( $(xmlDoc).find("[id='" + id + "']").length > 1 ){
                        //And if it is not a unit node, which we don't want to change,
                        if( !$(el).is("unit") )
                          //Then change the id attribute to a random uuid
                          $(el).attr("id", "urn-uuid-" + uuid.v4());
                      }

                    });

                  }
                }

                // Convert xml to xmlString and return xmlString
                xmlString = new XMLSerializer().serializeToString(xmlDoc);

                //If there isn't an XML declaration, add one
                if( xmlString.indexOf("&lt;?xml") == -1 ){
                  xmlString = '&lt;?xml version="1.0" encoding="UTF-8"?>' + xmlString;
                }

                return xmlString;
              }
              catch(e){
                console.error("Error while serializing the Portal XML document: ", e);
                this.set("errorMessage", e.stack);
                this.trigger("errorSaving", MetacatUI.appModel.get("portalEditSaveErrorMsg"));
                return;
              }
            },

            /**
             * Checks whether the given sectionModel has been updated by the
             * user, or whether all attributes match their default values.
             * For a section's markdown, the default value is either an empty
             * string or null. For a section's label, the default
             * value is either an empty string or a string that begins with the
             * value set to PortalModel.newSectionLabel. For all other attributes,
             * the defaults are set in PortalSectionModel.defaults.
             * @param {PortalSectionModel} sectionModel - The model to check against a default model
             * @return {boolean} returns true if the sectionModel matches a default model, and false when at least one attribute differs
            */
            sectionIsDefault: function(sectionModel){

              try{

                var defaults = sectionModel.defaults(),
                    currentMarkdown = sectionModel.get("content").get("markdown"),
                    labelRegex = new RegExp("^" + this.newSectionLabel, "i");

                // For each attribute, check whether it matches the default
                if(
                  // Check whether markdown matches the content that's
                  // auto-filled or whether it's empty
                  ( //currentMarkdown === this.markdownExample ||
                    currentMarkdown == "" ||
                    currentMarkdown == null
                  ) &amp;&amp;
                  ( sectionModel.get("image") === defaults.image ) &amp;&amp;
                  ( sectionModel.get("introduction") === defaults.introduction ) &amp;&amp;
                  // Check whether label starts with the default new page name,
                  // or whether it's empty
                  (
                    labelRegex.test( sectionModel.get("label") ) ||
                    sectionModel.get("label") == "" ||
                    sectionModel.get("label") == null
                  ) &amp;&amp;
                  ( sectionModel.get("literatureCited") === defaults.literatureCited ) &amp;&amp;
                  ( sectionModel.get("title") === defaults.title )
                ){
                  // All elements of the section match the default
                  return true
                } else {
                  // At least one attribute of the section has been updated
                  return false
                }

              }
              catch(e){
                // If there's a problem with this function for some reason,
                // return false so that the section is serialized to avoid
                // losing information
                console.log("Failed to check whether section model is default. Serializing it anyway. Error message:" + e);
                return false
              }

            },

            /**
             * Initialize the object XML for a brand spankin' new portal
             * @inheritdoc
             *
            */
            createXML: function() {

              // TODO: which attributes should a new XML portal doc should have?
              var xmlString = "&lt;por:portal xmlns:por=\"https://purl.dataone.org/portals-1.0.0\">&lt;/por:portal>",
                  xmlNew = $.parseXML(xmlString),
                  portalNode = xmlNew.getElementsByTagName("por:portal")[0];

              return(xmlNew);
            },

            /**
             * Overrides the default Backbone.Model.validate.function() to
             * check if this portal model has all the required values necessary
             * to save to the server.
             *
             * @param {Object} [attrs] - A literal object of model attributes to validate.
             * @param {Object} [options] - A literal object of options for this validation process
             * @return {Object} If there are errors, an object comprising error
             *                   messages. If no errors, returns nothing.
            */
            validate: function(attrs, options) {

              try{

                var errors = {},
                    requiredFields = MetacatUI.appModel.get("portalEditorRequiredFields") || {};

                //Execute the superclass validate() function
                var collectionErrors = this.constructor.__super__.validate.call(this);
                if( typeof collectionErrors == "object" &amp;&amp; Object.keys(collectionErrors).length ){
                  //Use the errors messages from the CollectionModel for this PortalModel
                  errors = collectionErrors;
                }

                // ---- Validate the description and name ----
                //Map the model attributes to the user-facing attribute name
                var textFields = {
                  description: "description",
                  name: "title"
                }
                //Iterate over each text field
                _.each( Object.keys(textFields), function(field){
                  //If this field is required, and it is a string
                  if( requiredFields[field] &amp;&amp; typeof this.get(field) == "string" ){
                    //If this is an empty string, set an error message
                    if( !this.get(field).trim().length ){
                      errors[field] = "A " + textFields[field] + " is required.";
                    }
                  }
                  //If this field is required, and it's not a string at all, set an error message
                  else if( requiredFields[field] ){
                    errors[field] = "A " + textFields[field] + " is required.";
                  }
                }, this);

                //---Validate the sections---
                //Iterate over each section model
                _.each( this.get("sections"), function(section){

                  //Validate the section model
                  var sectionErrors = section.validate();

                  //If there is at least one error, then add an error to the PortalModel error list
                  if( sectionErrors &amp;&amp; Object.keys(sectionErrors).length ){
                    errors.sections = "At least one section has an error";
                  }

                }, this);

                //----Validate the logo----
                if(requiredFields.logo &amp;&amp; (!this.get("logo") ||
                    !this.get("logo").get("identifier")))
                {
                  errors.logo = "A logo image is required";
                } else if(this.get("logo")){
                  logoErrors = this.get("logo").validate();
                  if(logoErrors &amp;&amp; Object.keys(logoErrors).length ){
                    errors.logo = "A logo image is required";
                  }
                }

                //---Validate the acknowledgmentsLogo---

                var nonEmptyAckLogos = this.get("acknowledgmentsLogos").filter(function(portalImage){
                  return(!portalImage.isEmpty())
                });

                if(
                  requiredFields.acknowledgmentsLogos &amp;&amp;
                  !nonEmptyAckLogos.length
                ){
                  errors.acknowledgmentsLogos = "At least one partner logo image is required.";
                }
                else if (
                  nonEmptyAckLogos &amp;&amp;
                  nonEmptyAckLogos.length
                ){

                  _.each( nonEmptyAckLogos, function(ackLogo){

                    // Validate the portal image model
                    var ackLogoErrors = ackLogo.validate();

                    // If there is at least one error, then add an error to the PortalModel error list
                    if( ackLogoErrors &amp;&amp; Object.keys(ackLogoErrors).length ){
                      errors.acknowledgmentsLogosImages = "At least one acknowledgment logo has an error";
                    }

                  }, this);

                }

                //TODO: Validate these other elements, listed below, as they are added to the portal editor

                //---Validate the associatedParties---

                //---Validate the acknowledgments---

                //---Validate the award---

                //---Validate the literatureCited---

                //---Validate the filterGroups---

                //Return the errors object
                if( Object.keys(errors).length )
                  return errors;
                else{
                  return;
                }

              }
              catch(e){
                console.error(e);
              }

            },

            /**
            * Checks for the existing block list for repository labels
            * If at least one other Portal has the same label, then it is not available.
            * @param {string} label - The label to query for
            */
            checkLabelAvailability: function(label){

              //Validate the label set on the model if one isn't given
              if(!label || typeof label != "string" ){
                var label = this.get("label");
                if(!label || typeof label != "string" ){
                  //Trigger an error event
                  this.trigger("errorValidatingLabel");
                  console.error("error validating label, no label provided");
                  return
                }
              }

              var model = this;

              if (!this.get("checkedNodeLabels")) {
                // query CN to fetch the latest node data
                model.updateNodeBlockList();

                this.listenTo(this, "change:checkedNodeLabels", function(){
                  this.checkPortalLabelAvailability(label);
                });
              }
              else {
                this.checkPortalLabelAvailability(label);
              }

            },

            /**
             * Queries the Solr discovery index for other Portal objects with this same label.
             * Also, checks for the existing block list for repository labels
             * If at least one other Portal has the same label, then it is not available.
             * @param {string} label - The label to query for
             */
            checkPortalLabelAvailability: function(label) {
              var model = this;

              // Stop Listening to the node model. We only need to retrieve this node label once.
              this.stopListening(this, "change:checkedNodeLabels", function(){
                this.checkPortalLabelAvailability(label);
              });

              // Convert the block list to lower case for case insensitive match
              var lowerCaseBlockList = this.get("labelBlockList").map(function(value) {
                return value.toLowerCase();
              });

              // Check the existing blockList before making a Solr call
              if (lowerCaseBlockList.indexOf(label.toLowerCase()) > -1) {
                model.trigger("labelTaken");
                return
              }

              // Query solr to see if other portals already use this label
              var requestSettings = {
                url: MetacatUI.appModel.get("queryServiceUrl") +
                     "q=label:\"" + label + "\"" +
                     " AND formatId:\"" + this.get("formatId") + "\"" +
                     "&amp;rows=0" +
                     "&amp;wt=json",
                error: function(response) {
                  model.trigger("errorValidatingLabel");
                },
                success: function(response){
                  if( response.response.numFound > 0 ){
                    //Add this label to the blockList so we don't have to query for it later
                    var blockList = model.get("labelBlockList");
                    if( Array.isArray(blockList) ){
                      blockList.push(label);
                    }

                    model.trigger("labelTaken");
                  } else {
                    if( MetacatUI.appModel.get("alternateRepositories").length ){

                      MetacatUI.appModel.setActiveAltRepo();
                      var activeAltRepo = MetacatUI.appModel.getActiveAltRepo();
                      if( activeAltRepo ){
                        var requestSettings = {
                          url: activeAltRepo.queryServiceUrl +
                               "q=label:\"" + label + "\"" +
                               " AND formatId:\"" + model.get("formatId") + "\"" +
                               "&amp;rows=0" +
                               "&amp;wt=json",
                          error: function(response) {
                            model.trigger("errorValidatingLabel");
                          },
                          success: function(response){
                            if( response.response.numFound > 0 ){
                              //Add this label to the blockList so we don't have to query for it later
                              var blockList = model.get("labelBlockList");
                              if( Array.isArray(blockList) ){
                                blockList.push(label);
                              }

                              model.trigger("labelTaken");
                            } else {
                              model.trigger("labelAvailable");
                            }
                          }
                        }
                        //Attach the User auth info and send the request
                        requestSettings = _.extend(requestSettings, MetacatUI.appUserModel.createAjaxSettings());
                        $.ajax(requestSettings);
                      }

                    }
                    else{
                      model.trigger("labelAvailable");
                    }
                  }
                }
              }
              //Attach the User auth info and send the request
              requestSettings = _.extend(requestSettings, MetacatUI.appUserModel.createAjaxSettings());
              $.ajax(requestSettings);
            },



            /**
             * Queries the CN Solr to retrieve the updated BlockList
             */
            updateNodeBlockList: function(){
              var model  = this;

              $.ajax({
                url: MetacatUI.appModel.get('nodeServiceUrl'),
                dataType: "text",
                error:  function(data, textStatus, xhr) {
                  // if there is an error in retrieving the node list;
                  // proceed with the existing node list to perform the checks
                  model.checkPortalLabelAvailability()
                },
                success: function(data, textStatus, xhr) {

                  var xmlResponse = $.parseXML(data) || null;
                  if(!xmlResponse) return;

                  // update the node block list on success
                  model.saveNodeBlockList(xmlResponse);
                }
              });
            },

            /**
             * Parses the retrieved XML document and saves the node information to the BlockList
             *
             * @param {XMLDocument} The XMLDocument returned from the fetch() AJAX call
             */
            saveNodeBlockList: function(xml){
              var model = this,
                children   = xml.children || xml.childNodes;

              //Traverse the XML response to get the MN info
              _.each(children, function(d1NodeList){

                var d1NodeListChildren = d1NodeList.children || d1NodeList.childNodes;

                //The first (and only) child should be the d1NodeList
                _.each(d1NodeListChildren, function(thisNode){

                  //Ignore parts of the XML that is not MN info
                  if(!thisNode.attributes) return;

                  //'node' will be a single node
                  var node = {},
                    nodeProperties = thisNode.children || thisNode.childNodes;

                  //Grab information about this node from XML nodes
                  _.each(nodeProperties, function(nodeProperty){

                    if(nodeProperty.nodeName == "property")
                      node[$(nodeProperty).attr("key")] = nodeProperty.textContent;
                    else
                      node[nodeProperty.nodeName] = nodeProperty.textContent;

                    //Check if this member node has v2 read capabilities - important for the Package service
                    if((nodeProperty.nodeName == "services") &amp;&amp; nodeProperty.childNodes.length){
                      var v2 = $(nodeProperty).find("service[name='MNRead'][version='v2'][available='true']").length;
                      node["readv2"] = v2;
                    }
                  });

                  //Grab information about this node from XLM attributes
                  _.each(thisNode.attributes, function(attribute){
                    node[attribute.nodeName] = attribute.nodeValue;
                  });

                  // Append Node name, node identifier and node short identifier to the array.
                  // node identifier
                  if (Array.isArray(model.get("labelBlockList")) &amp;&amp; ((model.get("labelBlockList")).indexOf(node.identifier) &lt; 0)) {
                    model.get("labelBlockList").push(node.identifier);
                  }

                  // node name
                  if(node.CN_node_name) {
                    node.name = node.CN_node_name;
                    if (Array.isArray(model.get("labelBlockList")) &amp;&amp; ((model.get("labelBlockList")).indexOf(node.name) &lt; 0)) {
                      model.get("labelBlockList").push(node.name);
                    }
                  }

                  // node short identifier
                  node.shortIdentifier = node.identifier.substring(node.identifier.lastIndexOf(":") + 1);
                  if (Array.isArray(model.get("labelBlockList")) &amp;&amp; ((model.get("labelBlockList")).indexOf(node.shortIdentifier) &lt; 0)) {
                    model.get("labelBlockList").push(node.shortIdentifier);
                  }

                });
              });

              this.set("checkedNodeLabels", "true");
            },

            /**
             * Removes nodes from the XML that do not have an accompanying model
             * (i.e. nodes which were probably removed by the user during editing)
             *
             * @param {jQuery} nodes - The nodes to potentially remove
             * @param {Model[]} models - The model to compare to
            */
            removeExtraNodes: function(nodes, models){
              // Remove the extra nodes
               var extraNodes =  nodes.length - models.length;
               if(extraNodes > 0){
                 for(var i = models.length; i &lt; nodes.length; i++){
                   $(nodes[i]).remove();
                 }
               }
            },

            /**
             * Saves the portal XML document to the server using the DataONE API
            */
            save: function(){

              var model = this;

              // Ensure empty filters (rule groups) are removed
              this.get("definitionFilters").removeEmptyFilters();

              // Validate before we try anything else
              if(!this.isValid()){
                //Trigger the invalid and cancelSave events
                this.trigger("invalid");
                this.trigger("cancelSave");
                //Don't save the model since it's invalid
                return false;
              }
              else{

                //Double-check that the label is available, if it was changed
                if( (this.isNew() || this.get("originalLabel") != this.get("label")) &amp;&amp; !this.get("labelDoubleChecked") ){
                  //If the label is taken
                  this.once("labelTaken", function(){

                    //Stop listening to the label availablity
                    this.stopListening("labelAvailable");

                    //Set that the label has been double-checked
                    this.set("labelDoubleChecked", true);

                    //If this portal is in a free trial of DataONE Plus, generate a new random label
                    // and start the save process again
                    if( MetacatUI.appModel.get("enableBookkeeperServices") ){

                      var subscription = MetacatUI.appUserModel.get("dataoneSubscription");
                      if(subscription &amp;&amp; subscription.isTrialing()) {
                        this.setRandomLabel();

                        this.set("labelDoubleChecked", true);

                        // Start the save process again
                        this.save();

                        return;
                      }

                    }
                    else{
                      //If the label is taken, trigger an invalid event
                      this.trigger("invalid");
                      //Trigger a cancellation of the save event
                      this.trigger("cancelSave");
                    }

                  });

                  this.once("labelAvailable", function(){
                    this.stopListening("labelTaken");
                    this.set("labelDoubleChecked", true);
                    this.save();
                  });

                  // Check label availability
                  this.checkLabelAvailability(this.get("label"));

                  // console.log("Double checking label");

                  //Don't proceed with the rest of the save
                  return;
                }
                else{
                  this.trigger("valid");
                }

              }

              //Check if the checksum has been calculated yet.
              if( !this.get("checksum") ){
                // Serialize the XML
                var xml = this.serialize();

                //If there is no xml returned from the serialize() function, then there
                // was an error, so don't save.
                if( typeof xml === "undefined" || !xml ){
                  //If no error message is set on the model, trigger an error now.
                  // If there is an error message already, it means the error has already
                  // been triggered inside the serialize() function.
                  if( !this.get("errorMessage") ){
                    this.trigger("errorSaving", MetacatUI.appModel.get("portalEditSaveErrorMsg"));
                  }

                  return;
                }

                var xmlBlob = new Blob([xml], {type : 'application/xml'});

                //Set the Blob as the upload file
                this.set("uploadFile", xmlBlob);

                //When it is calculated, restart this function
                this.off("checksumCalculated", this.save);
                this.on("checksumCalculated", this.save);
                //Calculate the checksum for this file
                this.calculateChecksum();

                //Exit this function until the checksum is done
                return;
              }

              this.constructor.__super__.save.call(this);
            },

            /**
            * Removes or hides the given section from this Portal
            * @param {PortalSectionModel|string} section - Either the PortalSectionModel
            * to remove, or the name of the section to remove. Some sections in the portals
            * are not tied to PortalSectionModels, because they are created from other parts of the Portal
            * document. For example, the Data, Metrics, and Members sections.
            */
            removeSection: function(section){

              try{

                //If this section is a string, remove it by adding custom options
                if(typeof section == "string"){
                  switch( section.toLowerCase() ){
                    case "data":
                      this.set("hideData", true);
                      break;
                    case "metrics":
                      this.set("hideMetrics", true);
                      break;
                    case "members":
                      this.set("hideMembers", true);
                      break;
                  }
                }
                //If this section is a section model, delete it from this Portal
                else if( PortalSectionModel.prototype.isPrototypeOf(section) ){

                  // Remove the section from the model's sections array object.
                  // Use clone() to create new array reference and ensure change
                  // event is tirggered.
                  var sectionModels = _.clone(this.get("sections"));
                  sectionModels.splice( $.inArray(section, sectionModels), 1);
                  this.set({sections: sectionModels});
                }
                else{
                  return;
                }
              }
              catch(e){
                console.error(e);
              }

            },

            /**
            * Adds the given section to this Portal
            * @param {PortalSectionModel|string} section - Either the PortalSectionModel
            * to add, or the name of the section to add. Some sections in the portals
            * are not tied to PortalSectionModels, because they are created from other parts of the Portal
            * document. For example, the Data, Metrics, and Members sections.
            */
            addSection: function(section){
              try{
                //If this section is a string, add it by adding custom options
                if(typeof section == "string"){
                  switch( section.toLowerCase() ){
                    case "data":
                      this.set("hideData", null);
                      break;
                    case "metrics":
                      this.set("hideMetrics", null);
                      break;
                    case "members":
                      this.set("hideMembers", null);
                      break;
                    case "freeform":

                      // Add a new, blank markdown section with a default image
                      var sectionModels = _.clone(this.get("sections")),
                          newSection = new PortalSectionModel({
                            portalModel: this,
                            // Include a default image if some are configured.
                            image: this.getRandomSectionImage()
                          });

                      sectionModels.push( newSection );
                      this.set("sections", sectionModels);
                      // Trigger event manually so we can just pass newSection
                      this.trigger("addSection", newSection);
                      break;
                  }
                }
                // If this section is a section model, add it to this Portal
                else if( PortalSectionModel.prototype.isPrototypeOf(section) ){
                  var sectionModels = _.clone(this.get("sections"));
                  sectionModels.push( section );
                  this.set({sections: sectionModels});
                  // trigger event manually so we can just pass newSection
                  this.trigger("addSection", section);
                }
                else{
                  return;
                }
              }
              catch(e){
                console.error(e);
              }
            },

            /**
             * removePortalImage - remove a PortalImage model from either the
             * logo, sections, or acknowledgmentsLogos node of the portal model.
             *
             * @param  {Image} portalImage the portalImage model to remove
             */
            removePortalImage: function(portalImage){
              try{
                // find the portalImage to remove
                switch (portalImage.get("nodeName")) {
                  case "logo":
                    if(portalImage === this.get("logo")){
                      this.set("logo", this.defaults().logo);
                    }
                    break;
                  case "image":
                    _.each(this.get("sections"), function(section, i) {
                      if(portalImage === section.get("image")){
                        section.set("image", section.defaults().image)
                      }
                    });
                    break;
                  case "acknowledgmentsLogo":
                    var ackLogos = _.clone(this.get("acknowledgmentsLogos"));
                    ackLogos.splice( $.inArray(portalImage, ackLogos), 1);
                    this.set({acknowledgmentsLogos: ackLogos});
                    break;
                }

              } catch(e){
                console.log("Failed to remove a portalImage model, error message: " + e);
              }

            },

            /**
            * Saves a reference to this Portal on the MetacatUI global object
            */
            cachePortal: function(){

              if( this.get("id") ){
                MetacatUI.portals = MetacatUI.portals || {};
                MetacatUI.portals[this.get("id")] = this;
              }

              this.on("change:id", this.cachePortal);
            },

            /**
            * Creates a URL for viewing more information about this object
            * @return {string}
            */
            createViewURL: function(){
              return MetacatUI.root + "/" + MetacatUI.appModel.get("portalTermPlural") + "/" + encodeURIComponent((this.get("label") || this.get("seriesId") || this.get("id")));
            },

            /**
            * Sets attributes on this Portal using the given Member Node data
            * @param {object} nodeInfoObject - A literal object taken from the NodeModel 'members' array
            */
            createNodeAttributes: function(nodeInfoObject) {
              var nodePortalModel = {};

              if (nodeInfoObject === undefined) {
                nodeInfoObject = {}
              }

              //TODO - check for undefined for each of the nodeInfo properties

              // Setting basic properties from the node info object
              this.set("name", nodeInfoObject.name);
              this.set("logo", nodeInfoObject.logo);
              this.set("description", nodeInfoObject.description);

              // Creating repo specific Filters
              var nodeFilterModel = new FilterModel({
                fields: ["datasource"],
                values: [nodeInfoObject.identifier],
                label: "Datasets for a repository",
                matchSubstring: false,
                operator: "OR"
              });

              // adding the filter in the node model
              this.get("definitionFilters").add(nodeFilterModel);

              // Set up the search model
              this.get("searchModel").get("filters").add(nodeFilterModel);

            },

            /**
            * Cleans up the given text so that it is XML-valid by escaping reserved characters, trimming white space, etc.
            *
            * @param {string} textString - The string to clean up
            * @return {string} - The cleaned up string
            */
            cleanXMLText: function(textString){

              if( typeof textString != "string" )
                return;

              textString = textString.trim();

              //Check for XML/HTML elements
              _.each(textString.match(/&lt;\s*[^>]*>/g), function(xmlNode){

                //Encode &lt;, >, and &lt;/ substrings
                var tagName = xmlNode.replace(/>/g, "&amp;gt;");
                tagName = tagName.replace(/&lt;/g, "&amp;lt;");

                //Replace the xmlNode in the full text string
                textString = textString.replace(xmlNode, tagName);

              });

              //Remove Unicode characters that are not valid XML characters
              //Create a regular expression that matches any character that is not a valid XML character
              // (see https://www.w3.org/TR/xml/#charsets)
              var invalidCharsRegEx = /[^\u0009\u000a\u000d\u0020-\uD7FF\uE000-\uFFFD]/g;
              textString = textString.replace(invalidCharsRegEx, "");

              return textString;

            },

            /**
            * Generates a random portal label for free trial portals
            * @fires PortalModel#change:label
            * @since 2.14.0
            */
            setRandomLabel: function() {

              if( this.isNew() ){
                var labelLength = MetacatUI.appModel.get("randomLabelNumericLength");
                var randomGeneratedLabel = Math.floor(Math.pow(10,labelLength - 1) + Math.random() * ( 9 * Math.pow(10,labelLength - 1)));
                randomGeneratedLabel = randomGeneratedLabel.toString();
                this.set("label", randomGeneratedLabel);
              }

            }

        });

        return PortalModel;
    });
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
